commit_sha,sha,filename,previous_filename,last_modified,status,additions,deletions,changes,patch,content_url,blob_url
d033abe4a66f2728c35886278148b0e38e7dbe4f,1def5e62740f585fceedf9954077eff871ad66d8,.golangci.yaml,,"Wed, 23 Aug 2023 01:41:23 GMT",added,12,0,12,"@@ -0,0 +1,12 @@
+linters:
+  enable:
+    - errcheck
+    - gosimple
+    - govet
+    - ineffassign
+    - staticcheck
+    - unused
+    - contextcheck
+    - goconst
+    - gofmt
+    - misspell",https://api.github.com/repos/gorilla/mux/contents/.golangci.yaml?ref=d033abe4a66f2728c35886278148b0e38e7dbe4f,https://github.com/gorilla/mux/blob/d033abe4a66f2728c35886278148b0e38e7dbe4f/.golangci.yaml
85123bf20e069b156415b871dea10517f6a8938a,9e49b24b880bb11775ecb3f9d881758c736e2b63,README.md,,"Thu, 17 Aug 2023 15:29:52 GMT",modified,2,1,3,"@@ -749,7 +749,8 @@ func TestMetricsHandler(t *testing.T) {
 
         rr := httptest.NewRecorder()
 	
-	// Need to create a router that we can pass the request through so that the vars will be added to the context
+	// To add the vars to the context, 
+	// we need to create a router through which we can pass the request.
 	router := mux.NewRouter()
         router.HandleFunc(""/metrics/{type}"", MetricsHandler)
         router.ServeHTTP(rr, req)",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=85123bf20e069b156415b871dea10517f6a8938a,https://github.com/gorilla/mux/blob/85123bf20e069b156415b871dea10517f6a8938a/README.md
79f2f457ca5017e08de9f86ada03939a82dbf714,cd85f4b382471e5c9c1c7ad707d8856da16beb05,route.go,,"Thu, 17 Aug 2023 04:48:59 GMT",modified,7,7,14,"@@ -240,7 +240,7 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // Headers adds a matcher for request header values.
 // It accepts a sequence of key/value pairs to be matched. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Headers(""Content-Type"", ""application/json"",
 //	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
@@ -265,7 +265,7 @@ func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // HeadersRegexp accepts a sequence of key/value pairs, where the value has regex
 // support. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
 //	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
@@ -293,7 +293,7 @@ func (r *Route) HeadersRegexp(pairs ...string) *Route {
 //
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Host(""www.example.com"")
 //	r.Host(""{subdomain}.domain.com"")
 //	r.Host(""{subdomain:[a-z]+}.domain.com"")
@@ -352,7 +352,7 @@ func (r *Route) Methods(methods ...string) *Route {
 //
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Path(""/products/"").Handler(ProductsHandler)
 //	r.Path(""/products/{key}"").Handler(ProductsHandler)
 //	r.Path(""/articles/{category}/{id:[0-9]+}"").
@@ -387,7 +387,7 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // It accepts a sequence of key/value pairs. Values may define variables.
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
 //
 // The above route will only match if the URL contains the defined queries
@@ -483,7 +483,7 @@ func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
 //
 // It will test the inner routes only if the parent route matched. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	s := r.Host(""www.example.com"").Subrouter()
 //	s.HandleFunc(""/products/"", ProductsHandler)
 //	s.HandleFunc(""/products/{key}"", ProductHandler)
@@ -534,7 +534,7 @@ func (r *Route) Subrouter() *Router {
 // The scheme of the resulting url will be the first argument that was passed to Schemes:
 //
 //	// url.String() will be ""https://example.com""
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	url, err := r.Host(""example.com"")
 //	             .Schemes(""https"", ""http"").URL()
 //",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=79f2f457ca5017e08de9f86ada03939a82dbf714,https://github.com/gorilla/mux/blob/79f2f457ca5017e08de9f86ada03939a82dbf714/route.go
395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,bd97d33b30c71dc1aa65d860319fa1a5c73d0af1,mux_test.go,,"Thu, 17 Aug 2023 01:34:43 GMT",modified,47,0,47,"@@ -2069,6 +2069,53 @@ func TestNoMatchMethodErrorHandler(t *testing.T) {
 	}
 }
 
+func TestMultipleDefinitionOfSamePathWithDifferentMethods(t *testing.T) {
+	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/api"", emptyHandler).Methods(""POST"")
+	r.HandleFunc(""/api"", emptyHandler).Queries(""time"", ""{time:[0-9]+}"").Methods(""GET"")
+
+	t.Run(""Post Method should be matched properly"", func(t *testing.T) {
+		req, _ := http.NewRequest(""POST"", ""http://localhost/api"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if !matched {
+			t.Error(""Should have matched route for methods"")
+		}
+		if match.MatchErr != nil {
+			t.Error(""Should not have any matching error. Found:"", match.MatchErr)
+		}
+	})
+
+	t.Run(""Get Method with invalid query value should not match"", func(t *testing.T) {
+		req, _ := http.NewRequest(""GET"", ""http://localhost/api?time=-4"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if matched {
+			t.Error(""Should not have matched route for methods"")
+		}
+		if match.MatchErr != ErrNotFound {
+			t.Error(""Should have ErrNotFound error. Found:"", match.MatchErr)
+		}
+	})
+
+	t.Run(""A mismach method of a valid path should return ErrMethodMismatch"", func(t *testing.T) {
+		r := NewRouter()
+		r.HandleFunc(""/api2"", emptyHandler).Methods(""POST"")
+		req, _ := http.NewRequest(""GET"", ""http://localhost/api2"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if matched {
+			t.Error(""Should not have matched route for methods"")
+		}
+		if match.MatchErr != ErrMethodMismatch {
+			t.Error(""Should have ErrMethodMismatch error. Found:"", match.MatchErr)
+		}
+	})
+
+}
+
 func TestErrMatchNotFound(t *testing.T) {
 	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,https://github.com/gorilla/mux/blob/395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92/mux_test.go
395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,abea99be68da2256691cf2226150f33c66b280f1,route.go,,"Thu, 17 Aug 2023 01:34:43 GMT",modified,10,0,10,"@@ -66,6 +66,16 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 
 			matchErr = nil // nolint:ineffassign
 			return false
+		} else {
+			// Multiple routes may share the same path but use different HTTP methods. For instance:
+			// Route 1: POST ""/users/{id}"".
+			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
+			//
+			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
+			// The router should return a ""Not Found"" error as no route fully matches this request.
+			if match.MatchErr == ErrMethodMismatch {
+				match.MatchErr = nil
+			}
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,https://github.com/gorilla/mux/blob/395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92/route.go
24c3e7f499efd8b1429cfe789c7e6a3631357045,f3cdc9c48a3f9c2b46eecf58801a35b2b834ac2c,README.md,,"Wed, 16 Aug 2023 02:08:21 GMT",modified,3,12,15,"@@ -247,20 +247,11 @@ type spaHandler struct {
 // file located at the index path on the SPA handler will be served. This
 // is suitable behavior for serving an SPA (single page application).
 func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-    // get the absolute path to prevent directory traversal
-	path, err := filepath.Abs(r.URL.Path)
-	if err != nil {
-        // if we failed to get the absolute path respond with a 400 bad request
-        // and stop
-		http.Error(w, err.Error(), http.StatusBadRequest)
-		return
-	}
-
-    // prepend the path with the path to the static directory
-	path = filepath.Join(h.staticPath, path)
+    // Join internally call path.Clean to prevent directory traversal
+    path := filepath.Join(h.staticPath, path)
 
     // check whether a file exists at the given path
-	_, err = os.Stat(path)
+	_, err := os.Stat(path)
 	if os.IsNotExist(err) {
 		// file does not exist, serve index.html
 		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=24c3e7f499efd8b1429cfe789c7e6a3631357045,https://github.com/gorilla/mux/blob/24c3e7f499efd8b1429cfe789c7e6a3631357045/README.md
546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4,80601351fd071c44b7c0a740e7d3a55520adcfc8,doc.go,,"Mon, 31 Jul 2023 01:44:28 GMT",modified,12,13,25,"@@ -10,18 +10,18 @@ http.ServeMux, mux.Router matches incoming requests against a list of
 registered routes and calls a handler for the route that matches the URL
 or other conditions. The main features are:
 
-	* Requests can be matched based on URL host, path, path prefix, schemes,
-	  header and query values, HTTP methods or using custom matchers.
-	* URL hosts, paths and query values can have variables with an optional
-	  regular expression.
-	* Registered URLs can be built, or ""reversed"", which helps maintaining
-	  references to resources.
-	* Routes can be used as subrouters: nested routes are only tested if the
-	  parent route matches. This is useful to define groups of routes that
-	  share common conditions like a host, a path prefix or other repeated
-	  attributes. As a bonus, this optimizes request matching.
-	* It implements the http.Handler interface so it is compatible with the
-	  standard http.ServeMux.
+  - Requests can be matched based on URL host, path, path prefix, schemes,
+    header and query values, HTTP methods or using custom matchers.
+  - URL hosts, paths and query values can have variables with an optional
+    regular expression.
+  - Registered URLs can be built, or ""reversed"", which helps maintaining
+    references to resources.
+  - Routes can be used as subrouters: nested routes are only tested if the
+    parent route matches. This is useful to define groups of routes that
+    share common conditions like a host, a path prefix or other repeated
+    attributes. As a bonus, this optimizes request matching.
+  - It implements the http.Handler interface so it is compatible with the
+    standard http.ServeMux.
 
 Let's start registering a couple of URL paths and handlers:
 
@@ -301,6 +301,5 @@ A more complex authentication middleware, which maps session token to users, cou
 	r.Use(amw.Middleware)
 
 Note: The handler chain will be stopped if your middleware doesn't call `next.ServeHTTP()` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to.
-
 */
 package mux",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4,https://github.com/gorilla/mux/blob/546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4/doc.go
546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4,1e089906fad5715477ba0c785562a43f0d987a8a,mux.go,,"Mon, 31 Jul 2023 01:44:28 GMT",modified,7,7,14,"@@ -31,17 +31,17 @@ func NewRouter() *Router {
 // It implements the http.Handler interface, so it can be registered to serve
 // requests:
 //
-//     var router = mux.NewRouter()
+//	var router = mux.NewRouter()
 //
-//     func main() {
-//         http.Handle(""/"", router)
-//     }
+//	func main() {
+//	    http.Handle(""/"", router)
+//	}
 //
 // Or, for Google App Engine, register it in a init() function:
 //
-//     func init() {
-//         http.Handle(""/"", router)
-//     }
+//	func init() {
+//	    http.Handle(""/"", router)
+//	}
 //
 // This will send all incoming requests to the router.
 type Router struct {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4,https://github.com/gorilla/mux/blob/546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4/mux.go
651928c42f7b60c7942e46d5f651dd1ece444246,8be6cedb260adf9827964b68e26e33eca59268a8,.github/workflows/issues.yml,,"Sun, 30 Jul 2023 16:37:42 GMT",modified,1,0,1,"@@ -8,6 +8,7 @@ on:
   pull_request_target:
     types:
       - opened
+      - reopened
 
 jobs:
   add-to-project:",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=651928c42f7b60c7942e46d5f651dd1ece444246,https://github.com/gorilla/mux/blob/651928c42f7b60c7942e46d5f651dd1ece444246/.github%2Fworkflows%2Fissues.yml
cfc696d6d239ff68ceb71ee35c9a4e4ef3f30ed9,ff9e3183e38af95a22603f0e6f1167c8a28836db,.github/workflows/issues.yml,,"Sun, 30 Jul 2023 16:23:57 GMT",modified,2,2,4,"@@ -5,7 +5,7 @@ on:
   issues:
     types:
       - opened
-  pull_request:
+  pull_request_target:
     types:
       - opened
 
@@ -17,4 +17,4 @@ jobs:
         uses: actions/add-to-project@v0.5.0
         with:
           project-url: https://github.com/orgs/gorilla/projects/4
-          github-token: ${{ secrets.ADD_TO_PROJECT_TOKEN }}
\ No newline at end of file
+          github-token: ${{ secrets.ADD_TO_PROJECT_TOKEN }}",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=cfc696d6d239ff68ceb71ee35c9a4e4ef3f30ed9,https://github.com/gorilla/mux/blob/cfc696d6d239ff68ceb71ee35c9a4e4ef3f30ed9/.github%2Fworkflows%2Fissues.yml
809d12850fc170caa4229eb2da58a4701c9837b8,bb9d80bc9b6bc381c1e0edc7b76683cc621b3183,LICENSE,,"Tue, 25 Jul 2023 17:19:44 GMT",modified,24,10,34,"@@ -1,13 +1,27 @@
-BSD 3-Clause License
+Copyright (c) 2023 The Gorilla Authors. All rights reserved.
 
-Copyright 2023 Gorilla web toolkit contributors
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
 
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+	 * Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+	 * Redistributions in binary form must reproduce the above
+copyright notice, this list of conditions and the following disclaimer
+in the documentation and/or other materials provided with the
+distribution.
+	 * Neither the name of Google Inc. nor the names of its
+contributors may be used to endorse or promote products derived from
+this software without specific prior written permission.
 
-1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",https://api.github.com/repos/gorilla/mux/contents/LICENSE?ref=809d12850fc170caa4229eb2da58a4701c9837b8,https://github.com/gorilla/mux/blob/809d12850fc170caa4229eb2da58a4701c9837b8/LICENSE
753457f3059d3db9a96f9f4c67d7f3724e97478d,4553c1fe6be67345ce17e2d9392e6f7a30d43016,README.md,,"Tue, 25 Jul 2023 16:35:16 GMT",modified,1,1,2,"@@ -6,7 +6,7 @@
 [![sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
 
 
-![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
+![Gorilla Logo](https://github.com/gorilla/.github/assets/53367916/d92caabf-98e0-473e-bfbf-ab554ba435e5)
 
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=753457f3059d3db9a96f9f4c67d7f3724e97478d,https://github.com/gorilla/mux/blob/753457f3059d3db9a96f9f4c67d7f3724e97478d/README.md
ff63d0e2fd6b3634b25a63c85c27a3dc80a3b8c8,1cedc459d8fe35ca3059883a8240f81bf6f87cd7,LICENSE,,"Sun, 23 Jul 2023 20:32:33 GMT",modified,10,24,34,"@@ -1,27 +1,13 @@
-Copyright (c) 2012-2018 The Gorilla Authors. All rights reserved.
+BSD 3-Clause License
 
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
+Copyright 2023 Gorilla web toolkit contributors
 
-	 * Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-	 * Redistributions in binary form must reproduce the above
-copyright notice, this list of conditions and the following disclaimer
-in the documentation and/or other materials provided with the
-distribution.
-	 * Neither the name of Google Inc. nor the names of its
-contributors may be used to endorse or promote products derived from
-this software without specific prior written permission.
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",https://api.github.com/repos/gorilla/mux/contents/LICENSE?ref=ff63d0e2fd6b3634b25a63c85c27a3dc80a3b8c8,https://github.com/gorilla/mux/blob/ff63d0e2fd6b3634b25a63c85c27a3dc80a3b8c8/LICENSE
2392d7d19e8c3b02af216a404709415813467766,b722392ee59266773c107a8e871d6b2a3085cb7c,AUTHORS,,"Sun, 23 Jul 2023 20:29:12 GMT",removed,0,8,8,"@@ -1,8 +0,0 @@
-# This is the official list of gorilla/mux authors for copyright purposes.
-#
-# Please keep the list sorted.
-
-Google LLC (https://opensource.google.com/)
-Kamil Kisielk <kamil@kamilkisiel.net>
-Matt Silverlock <matt@eatsleeprepeat.net>
-Rodrigo Moraes (https://github.com/moraes)",https://api.github.com/repos/gorilla/mux/contents/AUTHORS?ref=81b48a39f012296f51d582d3cefaaba1c2f5a01f,https://github.com/gorilla/mux/blob/81b48a39f012296f51d582d3cefaaba1c2f5a01f/AUTHORS
81b48a39f012296f51d582d3cefaaba1c2f5a01f,f4b12d30baf37382ec63e7a309bcab4d48c7ec41,.github/stale.yml,,"Sun, 23 Jul 2023 20:28:38 GMT",removed,0,12,12,"@@ -1,12 +0,0 @@
-daysUntilStale: 75
-daysUntilClose: 14
-# Issues with these labels will never be considered stale
-exemptLabels:
-  - proposal
-  - needs review
-  - build system
-staleLabel: stale
-markComment: >
-  This issue has been automatically marked as stale because it hasn't seen
-  a recent update. It'll be automatically closed in a few days.
-closeComment: false",https://api.github.com/repos/gorilla/mux/contents/.github%2Fstale.yml?ref=96847b8b06f990d7b53c8a5c647ee73d3e70582a,https://github.com/gorilla/mux/blob/96847b8b06f990d7b53c8a5c647ee73d3e70582a/.github%2Fstale.yml
96847b8b06f990d7b53c8a5c647ee73d3e70582a,2db2e1397ec7b63ebe94d7536548cba72f20e7bd,.github/release-drafter.yml,,"Sun, 23 Jul 2023 20:27:23 GMT",removed,0,8,8,"@@ -1,8 +0,0 @@
-# Config for https://github.com/apps/release-drafter
-template: |
-  
-  <summary of changes here>
-  
-  ## CHANGELOG
-
-  $CHANGES",https://api.github.com/repos/gorilla/mux/contents/.github%2Frelease-drafter.yml?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.github%2Frelease-drafter.yml
1fa2ee87bf61940bfac616e98513448af97a1813,ead3e1d49f7f1ee53f8f75746355afef2498d643,.circleci/config.yml,,"Sun, 23 Jul 2023 20:15:04 GMT",removed,0,70,70,"@@ -1,70 +0,0 @@
-version: 2.1
-
-jobs:
-  ""test"":
-    parameters:
-      version:
-        type: string
-        default: ""latest""
-      golint:
-        type: boolean
-        default: true
-      modules:
-        type: boolean
-        default: true
-      goproxy:
-        type: string
-        default: """"
-    docker:
-      - image: ""circleci/golang:<< parameters.version >>""
-    working_directory: /go/src/github.com/gorilla/mux
-    environment:
-      GO111MODULE: ""on""
-      GOPROXY: ""<< parameters.goproxy >>""
-    steps:
-      - checkout
-      - run:
-          name: ""Print the Go version""
-          command: >
-            go version
-      - run:
-          name: ""Fetch dependencies""
-          command: >
-            if [[ << parameters.modules >> = true ]]; then
-              go mod download
-              export GO111MODULE=on
-            else
-              go get -v ./...
-            fi
-      # Only run gofmt, vet & lint against the latest Go version
-      - run:
-          name: ""Run golint""
-          command: >
-            if [ << parameters.version >> = ""latest"" ] && [ << parameters.golint >> = true ]; then
-              go get -u golang.org/x/lint/golint
-              golint ./...
-            fi
-      - run:
-          name: ""Run gofmt""
-          command: >
-            if [[ << parameters.version >> = ""latest"" ]]; then
-              diff -u <(echo -n) <(gofmt -d -e .)
-            fi
-      - run:
-          name: ""Run go vet""
-          command: >
-            if [[ << parameters.version >> = ""latest"" ]]; then
-              go vet -v ./...
-            fi
-      - run:
-          name: ""Run go test (+ race detector)""
-          command: >
-            go test -v -race ./...
-
-workflows:
-  tests:
-    jobs:
-      - test:
-          matrix:
-            parameters:
-              version: [""latest"", ""1.15"", ""1.14"", ""1.13"", ""1.12"", ""1.11""]",https://api.github.com/repos/gorilla/mux/contents/.circleci%2Fconfig.yml?ref=abccd7e4d7c117370b7908f51e48decb38b6835b,https://github.com/gorilla/mux/blob/abccd7e4d7c117370b7908f51e48decb38b6835b/.circleci%2Fconfig.yml
1fa2ee87bf61940bfac616e98513448af97a1813,c6b74c3e0d0c70aa3e311cba355eab11fd7adf8d,.editorconfig,,"Sun, 23 Jul 2023 20:15:04 GMT",added,20,0,20,"@@ -0,0 +1,20 @@
+; https://editorconfig.org/
+
+root = true
+
+[*]
+insert_final_newline = true
+charset = utf-8
+trim_trailing_whitespace = true
+indent_style = space
+indent_size = 2
+
+[{Makefile,go.mod,go.sum,*.go,.gitmodules}]
+indent_style = tab
+indent_size = 4
+
+[*.md]
+indent_size = 4
+trim_trailing_whitespace = false
+
+eclint_indent_style = unset
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/.editorconfig?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.editorconfig
1fa2ee87bf61940bfac616e98513448af97a1813,055ca8222eab29c771cda4f97c671a0ab1876066,.github/workflows/issues.yml,,"Sun, 23 Jul 2023 20:15:04 GMT",added,20,0,20,"@@ -0,0 +1,20 @@
+# Add issues or pull-requests created to the project. 
+name: Add issue or pull request to Project
+
+on:
+  issues:
+    types:
+      - opened
+  pull_request:
+    types:
+      - opened
+
+jobs:
+  add-to-project:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Add issue to project
+        uses: actions/add-to-project@v0.5.0
+        with:
+          project-url: https://github.com/orgs/gorilla/projects/4
+          github-token: ${{ secrets.ADD_TO_PROJECT_TOKEN }}
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.github%2Fworkflows%2Fissues.yml
1fa2ee87bf61940bfac616e98513448af97a1813,af48d2289fd47fce511a9698f236c78164223cbc,.github/workflows/test.yml,,"Sun, 23 Jul 2023 20:15:04 GMT",added,55,0,55,"@@ -0,0 +1,55 @@
+name: CI
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+
+permissions:
+  contents: read
+
+jobs:
+  verify-and-test:
+    strategy:
+      matrix:
+        go: ['1.19','1.20']
+        os: [ubuntu-latest, macos-latest, windows-latest]
+      fail-fast: true
+    runs-on: ${{ matrix.os }}
+    steps:
+      - name: Checkout Code
+        uses: actions/checkout@v3
+
+      - name: Setup Go ${{ matrix.go }}
+        uses: actions/setup-go@v4
+        with:
+          go-version: ${{ matrix.go }}
+          cache: false
+
+      - name: Run GolangCI-Lint
+        uses: golangci/golangci-lint-action@v3
+        with:
+          version: v1.53
+          args: --timeout=5m
+
+      - name: Run GoSec
+        if: matrix.os == 'ubuntu-latest'
+        uses: securego/gosec@master
+        with:
+          args: ./...
+
+      - name: Run GoVulnCheck
+        uses: golang/govulncheck-action@v1
+        with:
+          go-version-input: ${{ matrix.go }}
+          go-package: ./...
+
+      - name: Run Tests
+        run: go test -race -cover -coverprofile=coverage -covermode=atomic -v ./...
+
+      - name: Upload coverage to Codecov
+        uses: codecov/codecov-action@v3
+        with:
+          files: ./coverage
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Ftest.yml?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.github%2Fworkflows%2Ftest.yml
1fa2ee87bf61940bfac616e98513448af97a1813,84039fec68771bc54be8f70617692068532536d2,.gitignore,,"Sun, 23 Jul 2023 20:15:04 GMT",added,1,0,1,"@@ -0,0 +1 @@
+coverage.coverprofile",https://api.github.com/repos/gorilla/mux/contents/.gitignore?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.gitignore
1fa2ee87bf61940bfac616e98513448af97a1813,98f5ab75f9d7ccbf249cd7271c44303ed719ebd3,Makefile,,"Sun, 23 Jul 2023 20:15:04 GMT",added,34,0,34,"@@ -0,0 +1,34 @@
+GO_LINT=$(shell which golangci-lint 2> /dev/null || echo '')
+GO_LINT_URI=github.com/golangci/golangci-lint/cmd/golangci-lint@latest
+
+GO_SEC=$(shell which gosec 2> /dev/null || echo '')
+GO_SEC_URI=github.com/securego/gosec/v2/cmd/gosec@latest
+
+GO_VULNCHECK=$(shell which govulncheck 2> /dev/null || echo '')
+GO_VULNCHECK_URI=golang.org/x/vuln/cmd/govulncheck@latest
+
+.PHONY: golangci-lint
+golangci-lint:
+	$(if $(GO_LINT), ,go install $(GO_LINT_URI))
+	@echo ""##### Running golangci-lint""
+	golangci-lint run -v
+	
+.PHONY: gosec
+gosec:
+	$(if $(GO_SEC), ,go install $(GO_SEC_URI))
+	@echo ""##### Running gosec""
+	gosec ./...
+
+.PHONY: govulncheck
+govulncheck:
+	$(if $(GO_VULNCHECK), ,go install $(GO_VULNCHECK_URI))
+	@echo ""##### Running govulncheck""
+	govulncheck ./...
+
+.PHONY: verify
+verify: golangci-lint gosec govulncheck
+
+.PHONY: test
+test:
+	@echo ""##### Running tests""
+	go test -race -cover -coverprofile=coverage.coverprofile -covermode=atomic -v ./...
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/Makefile?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/Makefile
1fa2ee87bf61940bfac616e98513448af97a1813,551f3c67478bb396842db0ef2287ba27b14ffbf6,README.md,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,5,3,8,"@@ -1,8 +1,10 @@
 # gorilla/mux
 
-[![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
-[![CircleCI](https://circleci.com/gh/gorilla/mux.svg?style=svg)](https://circleci.com/gh/gorilla/mux)
-[![Sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
+![testing](https://github.com/gorilla/mux/actions/workflows/test.yml/badge.svg)
+[![codecov](https://codecov.io/github/gorilla/mux/branch/main/graph/badge.svg)](https://codecov.io/github/gorilla/mux)
+[![godoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
+[![sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
+
 
 ![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/README.md
1fa2ee87bf61940bfac616e98513448af97a1813,7bcfa026847c645eb0e30e874095007366725c64,go.mod,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,1,1,2,"@@ -1,3 +1,3 @@
 module github.com/gorilla/mux
 
-go 1.12
+go 1.19",https://api.github.com/repos/gorilla/mux/contents/go.mod?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/go.mod
1fa2ee87bf61940bfac616e98513448af97a1813,4963b66fc955214e5b1099078afcd21f244a191a,middleware_test.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,76,19,95,"@@ -158,7 +158,10 @@ func TestMiddlewareExecution(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	t.Run(""responds normally without middleware"", func(t *testing.T) {
@@ -178,7 +181,10 @@ func TestMiddlewareExecution(t *testing.T) {
 
 		router.Use(func(h http.Handler) http.Handler {
 			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-				w.Write(mwStr)
+				_, err := w.Write(mwStr)
+				if err != nil {
+					t.Fatalf(""Failed writing HTTP response: %v"", err)
+				}
 				h.ServeHTTP(w, r)
 			})
 		})
@@ -196,11 +202,17 @@ func TestMiddlewareNotFound(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 	router.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
+			_, err := w.Write(mwStr)
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
@@ -221,7 +233,10 @@ func TestMiddlewareNotFound(t *testing.T) {
 		req := newRequest(""GET"", ""/notfound"")
 
 		router.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-			rw.Write([]byte(""Custom 404 handler""))
+			_, err := rw.Write([]byte(""Custom 404 handler""))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 		})
 		router.ServeHTTP(rw, req)
 
@@ -237,12 +252,18 @@ func TestMiddlewareMethodMismatch(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	}).Methods(""GET"")
 
 	router.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
+			_, err := w.Write(mwStr)
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
@@ -262,7 +283,10 @@ func TestMiddlewareMethodMismatch(t *testing.T) {
 		req := newRequest(""POST"", ""/"")
 
 		router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-			rw.Write([]byte(""Method not allowed""))
+			_, err := rw.Write([]byte(""Method not allowed""))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 		})
 		router.ServeHTTP(rw, req)
 
@@ -278,17 +302,26 @@ func TestMiddlewareNotFoundSubrouter(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	subrouter := router.PathPrefix(""/sub/"").Subrouter()
 	subrouter.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	router.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
+			_, err := w.Write(mwStr)
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
@@ -308,7 +341,10 @@ func TestMiddlewareNotFoundSubrouter(t *testing.T) {
 		req := newRequest(""GET"", ""/sub/notfound"")
 
 		subrouter.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-			rw.Write([]byte(""Custom 404 handler""))
+			_, err := rw.Write([]byte(""Custom 404 handler""))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 		})
 		router.ServeHTTP(rw, req)
 
@@ -324,17 +360,26 @@ func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	subrouter := router.PathPrefix(""/sub/"").Subrouter()
 	subrouter.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	}).Methods(""GET"")
 
 	router.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
+			_, err := w.Write(mwStr)
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
@@ -354,7 +399,10 @@ func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
 		req := newRequest(""POST"", ""/sub/"")
 
 		router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-			rw.Write([]byte(""Method not allowed""))
+			_, err := rw.Write([]byte(""Method not allowed""))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 		})
 		router.ServeHTTP(rw, req)
 
@@ -508,7 +556,10 @@ func TestMiddlewareOnMultiSubrouter(t *testing.T) {
 	secondSubRouter := router.PathPrefix(""/"").Subrouter()
 
 	router.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(notFound))
+		_, err := rw.Write([]byte(notFound))
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	firstSubRouter.HandleFunc(""/first"", func(w http.ResponseWriter, r *http.Request) {
@@ -521,14 +572,20 @@ func TestMiddlewareOnMultiSubrouter(t *testing.T) {
 
 	firstSubRouter.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write([]byte(first))
+			_, err := w.Write([]byte(first))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
 
 	secondSubRouter.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write([]byte(second))
+			_, err := w.Write([]byte(second))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/middleware_test.go
1fa2ee87bf61940bfac616e98513448af97a1813,f55a2de3136a57721bf6726c06e3a830941958e5,mux_httpserver_test.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,10,4,14,"@@ -5,7 +5,7 @@ package mux
 
 import (
 	""bytes""
-	""io/ioutil""
+	""io""
 	""net/http""
 	""net/http/httptest""
 	""testing""
@@ -14,10 +14,16 @@ import (
 func TestSchemeMatchers(t *testing.T) {
 	router := NewRouter()
 	router.HandleFunc(""/"", func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(""hello http world""))
+		_, err := rw.Write([]byte(""hello http world""))
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	}).Schemes(""http"")
 	router.HandleFunc(""/"", func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(""hello https world""))
+		_, err := rw.Write([]byte(""hello https world""))
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	}).Schemes(""https"")
 
 	assertResponseBody := func(t *testing.T, s *httptest.Server, expectedBody string) {
@@ -28,7 +34,7 @@ func TestSchemeMatchers(t *testing.T) {
 		if resp.StatusCode != 200 {
 			t.Fatalf(""expected a status code of 200, got %v"", resp.StatusCode)
 		}
-		body, err := ioutil.ReadAll(resp.Body)
+		body, err := io.ReadAll(resp.Body)
 		if err != nil {
 			t.Fatalf(""unexpected error reading body: %v"", err)
 		}",https://api.github.com/repos/gorilla/mux/contents/mux_httpserver_test.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/mux_httpserver_test.go
1fa2ee87bf61940bfac616e98513448af97a1813,4345254bc38739e31f9e71c43796588a363db134,mux_test.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,15,5,20,"@@ -10,7 +10,8 @@ import (
 	""context""
 	""errors""
 	""fmt""
-	""io/ioutil""
+	""io""
+	""log""
 	""net/http""
 	""net/http/httptest""
 	""net/url""
@@ -2136,7 +2137,10 @@ type methodsSubrouterTest struct {
 // methodHandler writes the method string in response.
 func methodHandler(method string) http.HandlerFunc {
 	return func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(method))
+		_, err := w.Write([]byte(method))
+		if err != nil {
+			log.Printf(""Failed writing HTTP response: %v"", err)
+		}
 	}
 }
 
@@ -2778,7 +2782,7 @@ func TestSubrouterCustomMethodNotAllowed(t *testing.T) {
 				tt.Errorf(""Expected status code 405 (got %d)"", w.Code)
 			}
 
-			b, err := ioutil.ReadAll(w.Body)
+			b, err := io.ReadAll(w.Body)
 			if err != nil {
 				tt.Errorf(""failed to read body: %v"", err)
 			}
@@ -2859,7 +2863,10 @@ func stringMapEqual(m1, m2 map[string]string) bool {
 // http.ResponseWriter.
 func stringHandler(s string) http.HandlerFunc {
 	return func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(s))
+		_, err := w.Write([]byte(s))
+		if err != nil {
+			log.Printf(""Failed writing HTTP response: %v"", err)
+		}
 	}
 }
 
@@ -2892,7 +2899,10 @@ func newRequest(method, url string) *http.Request {
 
 	// Simulate writing to wire
 	var buff bytes.Buffer
-	req.Write(&buff)
+	err = req.Write(&buff)
+	if err != nil {
+		log.Printf(""Failed writing HTTP request: %v"", err)
+	}
 	ioreader := bufio.NewReader(&buff)
 
 	// Parse request off of 'wire'",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/mux_test.go
1fa2ee87bf61940bfac616e98513448af97a1813,5d05cfa0e9ea01a497425a0c41a721c430c80099,regexp.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,1,1,2,"@@ -195,7 +195,7 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 
 // url builds a URL part using the given values.
 func (r *routeRegexp) url(values map[string]string) (string, error) {
-	urlValues := make([]interface{}, len(r.varsN), len(r.varsN))
+	urlValues := make([]interface{}, len(r.varsN))
 	for k, v := range r.varsN {
 		value, ok := values[v]
 		if !ok {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/regexp.go
1fa2ee87bf61940bfac616e98513448af97a1813,d7518f3e06b56f2623a2e0849cde2c89a0667c85,regexp_test.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,2,2,4,"@@ -54,7 +54,7 @@ func Benchmark_findQueryKey(b *testing.B) {
 			b.ReportAllocs()
 			b.ResetTimer()
 			for i := 0; i < b.N; i++ {
-				for key, _ := range all {
+				for key := range all {
 					_, _ = findFirstQueryKey(query, key)
 				}
 			}
@@ -79,7 +79,7 @@ func Benchmark_findQueryKeyGoLib(b *testing.B) {
 			b.ReportAllocs()
 			b.ResetTimer()
 			for i := 0; i < b.N; i++ {
-				for key, _ := range all {
+				for key := range all {
 					v := u.Query()[key]
 					if len(v) > 0 {
 						_ = v[0]",https://api.github.com/repos/gorilla/mux/contents/regexp_test.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/regexp_test.go
1fa2ee87bf61940bfac616e98513448af97a1813,ce1c9bfe1e94b8297f73bad8ea5d2fefe3bb0a1e,route.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,40,40,80,"@@ -64,7 +64,7 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 				match.MatchErr = nil
 			}
 
-			matchErr = nil
+			matchErr = nil // nolint:ineffassign
 			return false
 		}
 	}
@@ -230,9 +230,9 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // Headers adds a matcher for request header values.
 // It accepts a sequence of key/value pairs to be matched. For example:
 //
-//     r := mux.NewRouter()
-//     r.Headers(""Content-Type"", ""application/json"",
-//               ""X-Requested-With"", ""XMLHttpRequest"")
+//	r := mux.NewRouter()
+//	r.Headers(""Content-Type"", ""application/json"",
+//	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both request header values match.
 // If the value is an empty string, it will match any value if the key is set.
@@ -255,9 +255,9 @@ func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // HeadersRegexp accepts a sequence of key/value pairs, where the value has regex
 // support. For example:
 //
-//     r := mux.NewRouter()
-//     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
-//               ""X-Requested-With"", ""XMLHttpRequest"")
+//	r := mux.NewRouter()
+//	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
+//	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both the request header matches both regular expressions.
 // If the value is an empty string, it will match any value if the key is set.
@@ -283,10 +283,10 @@ func (r *Route) HeadersRegexp(pairs ...string) *Route {
 //
 // For example:
 //
-//     r := mux.NewRouter()
-//     r.Host(""www.example.com"")
-//     r.Host(""{subdomain}.domain.com"")
-//     r.Host(""{subdomain:[a-z]+}.domain.com"")
+//	r := mux.NewRouter()
+//	r.Host(""www.example.com"")
+//	r.Host(""{subdomain}.domain.com"")
+//	r.Host(""{subdomain:[a-z]+}.domain.com"")
 //
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
@@ -342,11 +342,11 @@ func (r *Route) Methods(methods ...string) *Route {
 //
 // For example:
 //
-//     r := mux.NewRouter()
-//     r.Path(""/products/"").Handler(ProductsHandler)
-//     r.Path(""/products/{key}"").Handler(ProductsHandler)
-//     r.Path(""/articles/{category}/{id:[0-9]+}"").
-//       Handler(ArticleHandler)
+//	r := mux.NewRouter()
+//	r.Path(""/products/"").Handler(ProductsHandler)
+//	r.Path(""/products/{key}"").Handler(ProductsHandler)
+//	r.Path(""/articles/{category}/{id:[0-9]+}"").
+//	  Handler(ArticleHandler)
 //
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
@@ -377,8 +377,8 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // It accepts a sequence of key/value pairs. Values may define variables.
 // For example:
 //
-//     r := mux.NewRouter()
-//     r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
+//	r := mux.NewRouter()
+//	r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
 //
 // The above route will only match if the URL contains the defined queries
 // values, e.g.: ?foo=bar&id=42.
@@ -473,11 +473,11 @@ func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
 //
 // It will test the inner routes only if the parent route matched. For example:
 //
-//     r := mux.NewRouter()
-//     s := r.Host(""www.example.com"").Subrouter()
-//     s.HandleFunc(""/products/"", ProductsHandler)
-//     s.HandleFunc(""/products/{key}"", ProductHandler)
-//     s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+//	r := mux.NewRouter()
+//	s := r.Host(""www.example.com"").Subrouter()
+//	s.HandleFunc(""/products/"", ProductsHandler)
+//	s.HandleFunc(""/products/{key}"", ProductHandler)
+//	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
 //
 // Here, the routes registered in the subrouter won't be tested if the host
 // doesn't match.
@@ -497,36 +497,36 @@ func (r *Route) Subrouter() *Router {
 // It accepts a sequence of key/value pairs for the route variables. For
 // example, given this route:
 //
-//     r := mux.NewRouter()
-//     r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
-//       Name(""article"")
+//	r := mux.NewRouter()
+//	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+//	  Name(""article"")
 //
 // ...a URL for it can be built using:
 //
-//     url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+//	url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
 //
 // ...which will return an url.URL with the following path:
 //
-//     ""/articles/technology/42""
+//	""/articles/technology/42""
 //
 // This also works for host variables:
 //
-//     r := mux.NewRouter()
-//     r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
-//       Host(""{subdomain}.domain.com"").
-//       Name(""article"")
+//	r := mux.NewRouter()
+//	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+//	  Host(""{subdomain}.domain.com"").
+//	  Name(""article"")
 //
-//     // url.String() will be ""http://news.domain.com/articles/technology/42""
-//     url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-//                                      ""category"", ""technology"",
-//                                      ""id"", ""42"")
+//	// url.String() will be ""http://news.domain.com/articles/technology/42""
+//	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+//	                                 ""category"", ""technology"",
+//	                                 ""id"", ""42"")
 //
 // The scheme of the resulting url will be the first argument that was passed to Schemes:
 //
-//     // url.String() will be ""https://example.com""
-//     r := mux.NewRouter()
-//     url, err := r.Host(""example.com"")
-//                  .Schemes(""https"", ""http"").URL()
+//	// url.String() will be ""https://example.com""
+//	r := mux.NewRouter()
+//	url, err := r.Host(""example.com"")
+//	             .Schemes(""https"", ""http"").URL()
 //
 // All variables defined in the route are required, and their values must
 // conform to the corresponding patterns.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/route.go
abccd7e4d7c117370b7908f51e48decb38b6835b,f836a4e798345d9ca36d97059a6c945bc5ce389e,README.md,,"Sat, 15 Jul 2023 20:07:06 GMT",modified,0,6,6,"@@ -6,12 +6,6 @@
 
 ![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 
----
-
-**The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit**
-
----
-
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=abccd7e4d7c117370b7908f51e48decb38b6835b,https://github.com/gorilla/mux/blob/abccd7e4d7c117370b7908f51e48decb38b6835b/README.md
7456b4e9ae7b67e27ffaa2e497941e77d39bc884,f836a4e798345d9ca36d97059a6c945bc5ce389e,README.md,,"Sat, 15 Jul 2023 14:48:51 GMT",modified,0,6,6,"@@ -6,12 +6,6 @@
 
 ![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 
----
-
-**The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit**
-
----
-
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=7456b4e9ae7b67e27ffaa2e497941e77d39bc884,https://github.com/gorilla/mux/blob/7456b4e9ae7b67e27ffaa2e497941e77d39bc884/README.md
eb99d7a67714bbab6db27f896a8c8c947b51b610,64a20e7dff65748c6ea4ca4833603cc1666fb4e3,README.md,,"Fri, 09 Dec 2022 15:56:57 GMT",modified,1,1,2,"@@ -8,7 +8,7 @@
 
 ---
 
-The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit
+**The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit**
 
 ---
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=eb99d7a67714bbab6db27f896a8c8c947b51b610,https://github.com/gorilla/mux/blob/eb99d7a67714bbab6db27f896a8c8c947b51b610/README.md
5e1e8c8d45ad101414d06762b0f7f6200babc929,35aa29b671da84f8107373348b4504e1d304edd9,README.md,,"Fri, 09 Dec 2022 15:56:37 GMT",modified,1,1,2,"@@ -8,7 +8,7 @@
 
 ---
 
-⚠️ **[The Gorilla Toolkit is looking for a new maintainer](https://github.com/gorilla/mux/issues/659)**
+The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit
 
 ---
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=5e1e8c8d45ad101414d06762b0f7f6200babc929,https://github.com/gorilla/mux/blob/5e1e8c8d45ad101414d06762b0f7f6200babc929/README.md
07eedffb4388b4ed26b86c67aedca1e513e7553b,f09a5b35a8756b1318262e3a04f3e028d0ecb34e,README.md,,"Wed, 17 Aug 2022 20:49:02 GMT",modified,1,1,2,"@@ -576,7 +576,7 @@ func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler
 r := mux.NewRouter()
 r.HandleFunc(""/"", handler)
 
-amw := authenticationMiddleware{}
+amw := authenticationMiddleware{tokenUsers: make(map[string]string)}
 amw.Populate()
 
 r.Use(amw.Middleware)",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=07eedffb4388b4ed26b86c67aedca1e513e7553b,https://github.com/gorilla/mux/blob/07eedffb4388b4ed26b86c67aedca1e513e7553b/README.md
c889844abd3601217c96aabc4b2dd89f6d904c01,37c11edc3a4c74a9f192c35db40594da04a14e54,regexp.go,,"Sun, 26 Jun 2022 11:46:01 GMT",modified,4,4,8,"@@ -22,10 +22,10 @@ type routeRegexpOptions struct {
 type regexpType int
 
 const (
-	regexpTypePath   regexpType = 0
-	regexpTypeHost   regexpType = 1
-	regexpTypePrefix regexpType = 2
-	regexpTypeQuery  regexpType = 3
+	regexpTypePath regexpType = iota
+	regexpTypeHost
+	regexpTypePrefix
+	regexpTypeQuery
 )
 
 // newRouteRegexp parses a route template and returns a routeRegexp,",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=c889844abd3601217c96aabc4b2dd89f6d904c01,https://github.com/gorilla/mux/blob/c889844abd3601217c96aabc4b2dd89f6d904c01/regexp.go
91708ff8e35bafc8612f690a25f5dd0be6f16864,c7e6872b1ccda49d372958b2d294fcd8d29aa738,README.md,,"Sun, 12 Dec 2021 16:29:04 GMT",modified,5,1,6,"@@ -6,7 +6,11 @@
 
 ![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 
-https://www.gorillatoolkit.org/pkg/mux
+---
+
+⚠️ **[The Gorilla Toolkit is looking for a new maintainer](https://github.com/gorilla/mux/issues/659)**
+
+---
 
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=91708ff8e35bafc8612f690a25f5dd0be6f16864,https://github.com/gorilla/mux/blob/91708ff8e35bafc8612f690a25f5dd0be6f16864/README.md
91708ff8e35bafc8612f690a25f5dd0be6f16864,907ab91d782bdc91fdb71c30b60bf46976fde46d,mux_httpserver_test.go,,"Sun, 12 Dec 2021 16:29:04 GMT",modified,1,0,1,"@@ -1,3 +1,4 @@
+//go:build go1.9
 // +build go1.9
 
 package mux",https://api.github.com/repos/gorilla/mux/contents/mux_httpserver_test.go?ref=91708ff8e35bafc8612f690a25f5dd0be6f16864,https://github.com/gorilla/mux/blob/91708ff8e35bafc8612f690a25f5dd0be6f16864/mux_httpserver_test.go
3cf0d013e53d62a96c096366d300c84489c26dd5,f126a602ba651622867542c10bcb009cd65ac63f,mux.go,,"Tue, 14 Sep 2021 12:12:19 GMT",modified,2,0,2,"@@ -46,9 +46,11 @@ func NewRouter() *Router {
 // This will send all incoming requests to the router.
 type Router struct {
 	// Configurable Handler to be used when no route matches.
+	// This can be used to render your own 404 Not Found errors.
 	NotFoundHandler http.Handler
 
 	// Configurable Handler to be used when the request method does not match the route.
+	// This can be used to render your own 405 Method Not Allowed errors.
 	MethodNotAllowedHandler http.Handler
 
 	// Routes to be matched, in order.",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=3cf0d013e53d62a96c096366d300c84489c26dd5,https://github.com/gorilla/mux/blob/3cf0d013e53d62a96c096366d300c84489c26dd5/mux.go
d07530f46e1eec4e40346e24af34dcc6750ad39f,ead3e1d49f7f1ee53f8f75746355afef2498d643,.circleci/config.yml,,"Sat, 12 Sep 2020 19:20:56 GMT",modified,43,60,103,"@@ -1,87 +1,70 @@
-version: 2.0
+version: 2.1
 
 jobs:
-  # Base test configuration for Go library tests Each distinct version should
-  # inherit this base, and override (at least) the container image used.
-  ""test"": &test
+  ""test"":
+    parameters:
+      version:
+        type: string
+        default: ""latest""
+      golint:
+        type: boolean
+        default: true
+      modules:
+        type: boolean
+        default: true
+      goproxy:
+        type: string
+        default: """"
     docker:
-      - image: circleci/golang:latest
+      - image: ""circleci/golang:<< parameters.version >>""
     working_directory: /go/src/github.com/gorilla/mux
-    steps: &steps
-      # Our build steps: we checkout the repo, fetch our deps, lint, and finally
-      # run ""go test"" on the package.
+    environment:
+      GO111MODULE: ""on""
+      GOPROXY: ""<< parameters.goproxy >>""
+    steps:
       - checkout
-      # Logs the version in our build logs, for posterity
-      - run: go version
+      - run:
+          name: ""Print the Go version""
+          command: >
+            go version
       - run:
           name: ""Fetch dependencies""
           command: >
-            go get -t -v ./...
+            if [[ << parameters.modules >> = true ]]; then
+              go mod download
+              export GO111MODULE=on
+            else
+              go get -v ./...
+            fi
       # Only run gofmt, vet & lint against the latest Go version
       - run:
           name: ""Run golint""
           command: >
-            if [ ""${LATEST}"" = true ] && [ -z ""${SKIP_GOLINT}"" ]; then
+            if [ << parameters.version >> = ""latest"" ] && [ << parameters.golint >> = true ]; then
               go get -u golang.org/x/lint/golint
               golint ./...
             fi
       - run:
           name: ""Run gofmt""
           command: >
-            if [[ ""${LATEST}"" = true ]]; then
+            if [[ << parameters.version >> = ""latest"" ]]; then
               diff -u <(echo -n) <(gofmt -d -e .)
             fi
       - run:
           name: ""Run go vet""
-          command:  >
-            if [[ ""${LATEST}"" = true ]]; then
+          command: >
+            if [[ << parameters.version >> = ""latest"" ]]; then
               go vet -v ./...
             fi
-      - run: go test -v -race ./...
-
-  ""latest"":
-    <<: *test
-    environment:
-      LATEST: true
-
-  ""1.12"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.12
-
-  ""1.11"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.11
-
-  ""1.10"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.10
-
-  ""1.9"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.9
-
-  ""1.8"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.8
-
-  ""1.7"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.7
+      - run:
+          name: ""Run go test (+ race detector)""
+          command: >
+            go test -v -race ./...
 
 workflows:
-  version: 2
-  build:
+  tests:
     jobs:
-      - ""latest""
-      - ""1.12""
-      - ""1.11""
-      - ""1.10""
-      - ""1.9""
-      - ""1.8""
-      - ""1.7""
+      - test:
+          matrix:
+            parameters:
+              version: [""latest"", ""1.15"", ""1.14"", ""1.13"", ""1.12"", ""1.11""]",https://api.github.com/repos/gorilla/mux/contents/.circleci%2Fconfig.yml?ref=d07530f46e1eec4e40346e24af34dcc6750ad39f,https://github.com/gorilla/mux/blob/d07530f46e1eec4e40346e24af34dcc6750ad39f/.circleci%2Fconfig.yml
98cb6bf42e086f6af920b965c38cacc07402d51b,96dbe3371924fa13f0940f6d7e2c803e93a505e2,old_test.go,,"Sat, 11 Jul 2020 20:05:21 GMT",modified,22,1,23,"@@ -260,6 +260,18 @@ var hostMatcherTests = []hostMatcherTest{
 		vars:    map[string]string{""foo"": ""abc"", ""bar"": ""def"", ""baz"": ""ghi""},
 		result:  true,
 	},
+	{
+		matcher: NewRouter().NewRoute().Host(""{foo:[a-z][a-z][a-z]}.{bar:[a-z][a-z][a-z]}.{baz:[a-z][a-z][a-z]}:{port:.*}""),
+		url:     ""http://abc.def.ghi:65535/"",
+		vars:    map[string]string{""foo"": ""abc"", ""bar"": ""def"", ""baz"": ""ghi"", ""port"": ""65535""},
+		result:  true,
+	},
+	{
+		matcher: NewRouter().NewRoute().Host(""{foo:[a-z][a-z][a-z]}.{bar:[a-z][a-z][a-z]}.{baz:[a-z][a-z][a-z]}""),
+		url:     ""http://abc.def.ghi:65535/"",
+		vars:    map[string]string{""foo"": ""abc"", ""bar"": ""def"", ""baz"": ""ghi""},
+		result:  true,
+	},
 	{
 		matcher: NewRouter().NewRoute().Host(""{foo:[a-z][a-z][a-z]}.{bar:[a-z][a-z][a-z]}.{baz:[a-z][a-z][a-z]}""),
 		url:     ""http://a.b.c/"",
@@ -365,6 +377,11 @@ var urlBuildingTests = []urlBuildingTest{
 		vars:  []string{""subdomain"", ""bar""},
 		url:   ""http://bar.domain.com"",
 	},
+	{
+		route: new(Route).Host(""{subdomain}.domain.com:{port:.*}""),
+		vars:  []string{""subdomain"", ""bar"", ""port"", ""65535""},
+		url:   ""http://bar.domain.com:65535"",
+	},
 	{
 		route: new(Route).Host(""foo.domain.com"").Path(""/articles""),
 		vars:  []string{},
@@ -412,7 +429,11 @@ func TestHeaderMatcher(t *testing.T) {
 
 func TestHostMatcher(t *testing.T) {
 	for _, v := range hostMatcherTests {
-		request, _ := http.NewRequest(""GET"", v.url, nil)
+		request, err := http.NewRequest(""GET"", v.url, nil)
+		if err != nil {
+			t.Errorf(""http.NewRequest failed %#v"", err)
+			continue
+		}
 		var routeMatch RouteMatch
 		result := v.matcher.Match(request, &routeMatch)
 		vars := routeMatch.Vars",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=98cb6bf42e086f6af920b965c38cacc07402d51b,https://github.com/gorilla/mux/blob/98cb6bf42e086f6af920b965c38cacc07402d51b/old_test.go
98cb6bf42e086f6af920b965c38cacc07402d51b,0144842bb23ee4cdf617a8f179548c25781a4afa,regexp.go,,"Sat, 11 Jul 2020 20:05:21 GMT",modified,6,0,6,"@@ -325,6 +325,12 @@ func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
 		host := getHost(req)
+		if v.host.wildcardHostPort {
+			// Don't be strict on the port match
+			if i := strings.Index(host, "":""); i != -1 {
+				host = host[:i]
+			}
+		}
 		matches := v.host.regexp.FindStringSubmatchIndex(host)
 		if len(matches) > 0 {
 			extractVars(host, matches, v.host.varsN, m.Vars)",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=98cb6bf42e086f6af920b965c38cacc07402d51b,https://github.com/gorilla/mux/blob/98cb6bf42e086f6af920b965c38cacc07402d51b/regexp.go
948bec34b5168796bf3fc4dbb09215baa970351a,782a34b22a6084db1085924cafe97ca8a374d3d1,mux.go,,"Sun, 17 May 2020 04:02:54 GMT",modified,1,2,3,"@@ -435,8 +435,7 @@ func Vars(r *http.Request) map[string]string {
 // CurrentRoute returns the matched route for the current request, if any.
 // This only works when called inside the handler of the matched route
 // because the matched route is stored in the request context which is cleared
-// after the handler returns, unless the KeepContext option is set on the
-// Router.
+// after the handler returns.
 func CurrentRoute(r *http.Request) *Route {
 	if rv := r.Context().Value(routeKey); rv != nil {
 		return rv.(*Route)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=948bec34b5168796bf3fc4dbb09215baa970351a,https://github.com/gorilla/mux/blob/948bec34b5168796bf3fc4dbb09215baa970351a/mux.go
75dcda0896e109a2a22c9315bca3bb21b87b2ba5,96dd94ad1302e9be48e920f9ca45834694bd80a1,regexp.go,,"Sun, 12 Jan 2020 19:17:43 GMT",modified,41,4,45,"@@ -230,14 +230,51 @@ func (r *routeRegexp) getURLQuery(req *http.Request) string {
 		return """"
 	}
 	templateKey := strings.SplitN(r.template, ""="", 2)[0]
-	for key, vals := range req.URL.Query() {
-		if key == templateKey && len(vals) > 0 {
-			return key + ""="" + vals[0]
-		}
+	val, ok := findFirstQueryKey(req.URL.RawQuery, templateKey)
+	if ok {
+		return templateKey + ""="" + val
 	}
 	return """"
 }
 
+// findFirstQueryKey returns the same result as (*url.URL).Query()[key][0].
+// If key was not found, empty string and false is returned.
+func findFirstQueryKey(rawQuery, key string) (value string, ok bool) {
+	query := []byte(rawQuery)
+	for len(query) > 0 {
+		foundKey := query
+		if i := bytes.IndexAny(foundKey, ""&;""); i >= 0 {
+			foundKey, query = foundKey[:i], foundKey[i+1:]
+		} else {
+			query = query[:0]
+		}
+		if len(foundKey) == 0 {
+			continue
+		}
+		var value []byte
+		if i := bytes.IndexByte(foundKey, '='); i >= 0 {
+			foundKey, value = foundKey[:i], foundKey[i+1:]
+		}
+		if len(foundKey) < len(key) {
+			// Cannot possibly be key.
+			continue
+		}
+		keyString, err := url.QueryUnescape(string(foundKey))
+		if err != nil {
+			continue
+		}
+		if keyString != key {
+			continue
+		}
+		valueString, err := url.QueryUnescape(string(value))
+		if err != nil {
+			continue
+		}
+		return valueString, true
+	}
+	return """", false
+}
+
 func (r *routeRegexp) matchQueryString(req *http.Request) bool {
 	return r.regexp.MatchString(r.getURLQuery(req))
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=75dcda0896e109a2a22c9315bca3bb21b87b2ba5,https://github.com/gorilla/mux/blob/75dcda0896e109a2a22c9315bca3bb21b87b2ba5/regexp.go
75dcda0896e109a2a22c9315bca3bb21b87b2ba5,0d80e6a5d387e8bbd4544ffacd18e815f90ba405,regexp_test.go,,"Sun, 12 Jan 2020 19:17:43 GMT",added,91,0,91,"@@ -0,0 +1,91 @@
+package mux
+
+import (
+	""net/url""
+	""reflect""
+	""strconv""
+	""testing""
+)
+
+func Test_findFirstQueryKey(t *testing.T) {
+	tests := []string{
+		""a=1&b=2"",
+		""a=1&a=2&a=banana"",
+		""ascii=%3Ckey%3A+0x90%3E"",
+		""a=1;b=2"",
+		""a=1&a=2;a=banana"",
+		""a=="",
+		""a=%2"",
+		""a=20&%20%3F&=%23+%25%21%3C%3E%23%22%7B%7D%7C%5C%5E%5B%5D%60%E2%98%BA%09:%2F@$%27%28%29%2A%2C%3B&a=30"",
+		""a=1& ?&=#+%!<>#\""{}|\\^[]`☺\t:/@$'()*,;&a=5"",
+		""a=xxxxxxxxxxxxxxxx&b=YYYYYYYYYYYYYYY&c=ppppppppppppppppppp&f=ttttttttttttttttt&a=uuuuuuuuuuuuu"",
+	}
+	for _, query := range tests {
+		t.Run(query, func(t *testing.T) {
+			// Check against url.ParseQuery, ignoring the error.
+			all, _ := url.ParseQuery(query)
+			for key, want := range all {
+				t.Run(key, func(t *testing.T) {
+					got, ok := findFirstQueryKey(query, key)
+					if !ok {
+						t.Error(""Did not get expected key"", key)
+					}
+					if !reflect.DeepEqual(got, want[0]) {
+						t.Errorf(""findFirstQueryKey(%s,%s) = %v, want %v"", query, key, got, want[0])
+					}
+				})
+			}
+		})
+	}
+}
+
+func Benchmark_findQueryKey(b *testing.B) {
+	tests := []string{
+		""a=1&b=2"",
+		""ascii=%3Ckey%3A+0x90%3E"",
+		""a=20&%20%3F&=%23+%25%21%3C%3E%23%22%7B%7D%7C%5C%5E%5B%5D%60%E2%98%BA%09:%2F@$%27%28%29%2A%2C%3B&a=30"",
+		""a=xxxxxxxxxxxxxxxx&bbb=YYYYYYYYYYYYYYY&cccc=ppppppppppppppppppp&ddddd=ttttttttttttttttt&a=uuuuuuuuuuuuu"",
+		""a=;b=;c=;d=;e=;f=;g=;h=;i=,j=;k="",
+	}
+	for i, query := range tests {
+		b.Run(strconv.Itoa(i), func(b *testing.B) {
+			// Check against url.ParseQuery, ignoring the error.
+			all, _ := url.ParseQuery(query)
+			b.ReportAllocs()
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				for key, _ := range all {
+					_, _ = findFirstQueryKey(query, key)
+				}
+			}
+		})
+	}
+}
+
+func Benchmark_findQueryKeyGoLib(b *testing.B) {
+	tests := []string{
+		""a=1&b=2"",
+		""ascii=%3Ckey%3A+0x90%3E"",
+		""a=20&%20%3F&=%23+%25%21%3C%3E%23%22%7B%7D%7C%5C%5E%5B%5D%60%E2%98%BA%09:%2F@$%27%28%29%2A%2C%3B&a=30"",
+		""a=xxxxxxxxxxxxxxxx&bbb=YYYYYYYYYYYYYYY&cccc=ppppppppppppppppppp&ddddd=ttttttttttttttttt&a=uuuuuuuuuuuuu"",
+		""a=;b=;c=;d=;e=;f=;g=;h=;i=,j=;k="",
+	}
+	for i, query := range tests {
+		b.Run(strconv.Itoa(i), func(b *testing.B) {
+			// Check against url.ParseQuery, ignoring the error.
+			all, _ := url.ParseQuery(query)
+			var u url.URL
+			u.RawQuery = query
+			b.ReportAllocs()
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				for key, _ := range all {
+					v := u.Query()[key]
+					if len(v) > 0 {
+						_ = v[0]
+					}
+				}
+			}
+		})
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/regexp_test.go?ref=75dcda0896e109a2a22c9315bca3bb21b87b2ba5,https://github.com/gorilla/mux/blob/75dcda0896e109a2a22c9315bca3bb21b87b2ba5/regexp_test.go
49c01487a141b49f8ffe06277f3dca3ee80a55fa,b5a15ed9836cf346ccd1005b9cf7e25612f95f82,regexp.go,,"Thu, 21 Nov 2019 17:05:00 GMT",modified,9,9,18,"@@ -181,16 +181,16 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 			}
 		}
 		return r.regexp.MatchString(host)
-	} else {
-		if r.regexpType == regexpTypeQuery {
-			return r.matchQueryString(req)
-		}
-		path := req.URL.Path
-		if r.options.useEncodedPath {
-			path = req.URL.EscapedPath()
-		}
-		return r.regexp.MatchString(path)
 	}
+
+	if r.regexpType == regexpTypeQuery {
+		return r.matchQueryString(req)
+	}
+	path := req.URL.Path
+	if r.options.useEncodedPath {
+		path = req.URL.EscapedPath()
+	}
+	return r.regexp.MatchString(path)
 }
 
 // url builds a URL part using the given values.",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=49c01487a141b49f8ffe06277f3dca3ee80a55fa,https://github.com/gorilla/mux/blob/49c01487a141b49f8ffe06277f3dca3ee80a55fa/regexp.go
4de8a5a4d283677c69afa1a86a044c8451633a18,2d8d2b3ef097ab966938ec7202a5bebfa6826bbd,mux_test.go,,"Tue, 19 Nov 2019 13:02:14 GMT",modified,2,2,4,"@@ -684,8 +684,8 @@ func TestHeaders(t *testing.T) {
 		},
 		{
 			title:       ""Headers route, regex header values to match"",
-			route:       new(Route).Headers(""foo"", ""ba[zr]""),
-			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar""}),
+			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baw""}),
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=4de8a5a4d283677c69afa1a86a044c8451633a18,https://github.com/gorilla/mux/blob/4de8a5a4d283677c69afa1a86a044c8451633a18/mux_test.go
2854a05fd3e2a9ecec0802bcb6eda09bbc0eea9f,cb51c565ebd3ab5eb70ab12f94dae23f725944e4,middleware.go,,"Sun, 17 Nov 2019 01:33:21 GMT",modified,10,15,25,"@@ -58,22 +58,17 @@ func CORSMethodMiddleware(r *Router) MiddlewareFunc {
 func getAllMethodsForRoute(r *Router, req *http.Request) ([]string, error) {
 	var allMethods []string
 
-	err := r.Walk(func(route *Route, _ *Router, _ []*Route) error {
-		for _, m := range route.matchers {
-			if _, ok := m.(*routeRegexp); ok {
-				if m.Match(req, &RouteMatch{}) {
-					methods, err := route.GetMethods()
-					if err != nil {
-						return err
-					}
-
-					allMethods = append(allMethods, methods...)
-				}
-				break
+	for _, route := range r.routes {
+		var match RouteMatch
+		if route.Match(req, &match) || match.MatchErr == ErrMethodMismatch {
+			methods, err := route.GetMethods()
+			if err != nil {
+				return nil, err
 			}
+
+			allMethods = append(allMethods, methods...)
 		}
-		return nil
-	})
+	}
 
-	return allMethods, err
+	return allMethods, nil
 }",https://api.github.com/repos/gorilla/mux/contents/middleware.go?ref=2854a05fd3e2a9ecec0802bcb6eda09bbc0eea9f,https://github.com/gorilla/mux/blob/2854a05fd3e2a9ecec0802bcb6eda09bbc0eea9f/middleware.go
2854a05fd3e2a9ecec0802bcb6eda09bbc0eea9f,e9f0ef550fba61d894104cbd4c8430eae380b8ce,middleware_test.go,,"Sun, 17 Nov 2019 01:33:21 GMT",modified,20,0,20,"@@ -478,6 +478,26 @@ func TestCORSMethodMiddleware(t *testing.T) {
 	}
 }
 
+func TestCORSMethodMiddlewareSubrouter(t *testing.T) {
+	router := NewRouter().StrictSlash(true)
+
+	subrouter := router.PathPrefix(""/test"").Subrouter()
+	subrouter.HandleFunc(""/hello"", stringHandler(""a"")).Methods(http.MethodGet, http.MethodOptions, http.MethodPost)
+	subrouter.HandleFunc(""/hello/{name}"", stringHandler(""b"")).Methods(http.MethodGet, http.MethodOptions)
+
+	subrouter.Use(CORSMethodMiddleware(subrouter))
+
+	rw := NewRecorder()
+	req := newRequest(""GET"", ""/test/hello/asdf"")
+	router.ServeHTTP(rw, req)
+
+	actualMethods := rw.Header().Get(""Access-Control-Allow-Methods"")
+	expectedMethods := ""GET,OPTIONS""
+	if actualMethods != expectedMethods {
+		t.Fatalf(""expected methods %q but got: %q"", expectedMethods, actualMethods)
+	}
+}
+
 func TestMiddlewareOnMultiSubrouter(t *testing.T) {
 	first := ""first""
 	second := ""second""",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=2854a05fd3e2a9ecec0802bcb6eda09bbc0eea9f,https://github.com/gorilla/mux/blob/2854a05fd3e2a9ecec0802bcb6eda09bbc0eea9f/middleware_test.go
946b6237eb8d0ce3225f502b7fd4208d0b60ce5f,cb51c565ebd3ab5eb70ab12f94dae23f725944e4,middleware.go,,"Fri, 15 Nov 2019 19:16:01 GMT",modified,10,15,25,"@@ -58,22 +58,17 @@ func CORSMethodMiddleware(r *Router) MiddlewareFunc {
 func getAllMethodsForRoute(r *Router, req *http.Request) ([]string, error) {
 	var allMethods []string
 
-	err := r.Walk(func(route *Route, _ *Router, _ []*Route) error {
-		for _, m := range route.matchers {
-			if _, ok := m.(*routeRegexp); ok {
-				if m.Match(req, &RouteMatch{}) {
-					methods, err := route.GetMethods()
-					if err != nil {
-						return err
-					}
-
-					allMethods = append(allMethods, methods...)
-				}
-				break
+	for _, route := range r.routes {
+		var match RouteMatch
+		if route.Match(req, &match) || match.MatchErr == ErrMethodMismatch {
+			methods, err := route.GetMethods()
+			if err != nil {
+				return nil, err
 			}
+
+			allMethods = append(allMethods, methods...)
 		}
-		return nil
-	})
+	}
 
-	return allMethods, err
+	return allMethods, nil
 }",https://api.github.com/repos/gorilla/mux/contents/middleware.go?ref=946b6237eb8d0ce3225f502b7fd4208d0b60ce5f,https://github.com/gorilla/mux/blob/946b6237eb8d0ce3225f502b7fd4208d0b60ce5f/middleware.go
946b6237eb8d0ce3225f502b7fd4208d0b60ce5f,e9f0ef550fba61d894104cbd4c8430eae380b8ce,middleware_test.go,,"Fri, 15 Nov 2019 19:16:01 GMT",modified,20,0,20,"@@ -478,6 +478,26 @@ func TestCORSMethodMiddleware(t *testing.T) {
 	}
 }
 
+func TestCORSMethodMiddlewareSubrouter(t *testing.T) {
+	router := NewRouter().StrictSlash(true)
+
+	subrouter := router.PathPrefix(""/test"").Subrouter()
+	subrouter.HandleFunc(""/hello"", stringHandler(""a"")).Methods(http.MethodGet, http.MethodOptions, http.MethodPost)
+	subrouter.HandleFunc(""/hello/{name}"", stringHandler(""b"")).Methods(http.MethodGet, http.MethodOptions)
+
+	subrouter.Use(CORSMethodMiddleware(subrouter))
+
+	rw := NewRecorder()
+	req := newRequest(""GET"", ""/test/hello/asdf"")
+	router.ServeHTTP(rw, req)
+
+	actualMethods := rw.Header().Get(""Access-Control-Allow-Methods"")
+	expectedMethods := ""GET,OPTIONS""
+	if actualMethods != expectedMethods {
+		t.Fatalf(""expected methods %q but got: %q"", expectedMethods, actualMethods)
+	}
+}
+
 func TestMiddlewareOnMultiSubrouter(t *testing.T) {
 	first := ""first""
 	second := ""second""",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=946b6237eb8d0ce3225f502b7fd4208d0b60ce5f,https://github.com/gorilla/mux/blob/946b6237eb8d0ce3225f502b7fd4208d0b60ce5f/middleware_test.go
f395758b854c4efa789b8c1e9b73479704c548cb,665940a2682ec86e06822ab1fba0db9a7eb77a61,context.go,,"Thu, 24 Oct 2019 12:12:56 GMT",removed,0,18,18,"@@ -1,18 +0,0 @@
-package mux
-
-import (
-	""context""
-	""net/http""
-)
-
-func contextGet(r *http.Request, key interface{}) interface{} {
-	return r.Context().Value(key)
-}
-
-func contextSet(r *http.Request, key, val interface{}) *http.Request {
-	if val == nil {
-		return r
-	}
-
-	return r.WithContext(context.WithValue(r.Context(), key, val))
-}",https://api.github.com/repos/gorilla/mux/contents/context.go?ref=ff4e71f144166b1dfe3017a146f8ed32a82e688b,https://github.com/gorilla/mux/blob/ff4e71f144166b1dfe3017a146f8ed32a82e688b/context.go
f395758b854c4efa789b8c1e9b73479704c548cb,d8a56b422f9128eb49fe92931531d7f9322ceaba,context_test.go,,"Thu, 24 Oct 2019 12:12:56 GMT",removed,0,30,30,"@@ -1,30 +0,0 @@
-package mux
-
-import (
-	""context""
-	""net/http""
-	""testing""
-	""time""
-)
-
-func TestNativeContextMiddleware(t *testing.T) {
-	withTimeout := func(h http.Handler) http.Handler {
-		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			ctx, cancel := context.WithTimeout(r.Context(), time.Minute)
-			defer cancel()
-			h.ServeHTTP(w, r.WithContext(ctx))
-		})
-	}
-
-	r := NewRouter()
-	r.Handle(""/path/{foo}"", withTimeout(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-		vars := Vars(r)
-		if vars[""foo""] != ""bar"" {
-			t.Fatal(""Expected foo var to be set"")
-		}
-	})))
-
-	rec := NewRecorder()
-	req := newRequest(""GET"", ""/path/bar"")
-	r.ServeHTTP(rec, req)
-}",https://api.github.com/repos/gorilla/mux/contents/context_test.go?ref=ff4e71f144166b1dfe3017a146f8ed32a82e688b,https://github.com/gorilla/mux/blob/ff4e71f144166b1dfe3017a146f8ed32a82e688b/context_test.go
f395758b854c4efa789b8c1e9b73479704c548cb,c9ba6470735b9b6fe0a9559ff523febb8880ebab,mux.go,,"Thu, 24 Oct 2019 12:12:56 GMT",modified,12,10,22,"@@ -5,6 +5,7 @@
 package mux
 
 import (
+	""context""
 	""errors""
 	""fmt""
 	""net/http""
@@ -58,8 +59,7 @@ type Router struct {
 
 	// If true, do not clear the request context after handling the request.
 	//
-	// Deprecated: No effect when go1.7+ is used, since the context is stored
-	// on the request itself.
+	// Deprecated: No effect, since the context is stored on the request itself.
 	KeepContext bool
 
 	// Slice of middlewares to be called after a match is found
@@ -195,8 +195,8 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	var handler http.Handler
 	if r.Match(req, &match) {
 		handler = match.Handler
-		req = setVars(req, match.Vars)
-		req = setCurrentRoute(req, match.Route)
+		req = requestWithVars(req, match.Vars)
+		req = requestWithRoute(req, match.Route)
 	}
 
 	if handler == nil && match.MatchErr == ErrMethodMismatch {
@@ -426,7 +426,7 @@ const (
 
 // Vars returns the route variables for the current request, if any.
 func Vars(r *http.Request) map[string]string {
-	if rv := contextGet(r, varsKey); rv != nil {
+	if rv := r.Context().Value(varsKey); rv != nil {
 		return rv.(map[string]string)
 	}
 	return nil
@@ -438,18 +438,20 @@ func Vars(r *http.Request) map[string]string {
 // after the handler returns, unless the KeepContext option is set on the
 // Router.
 func CurrentRoute(r *http.Request) *Route {
-	if rv := contextGet(r, routeKey); rv != nil {
+	if rv := r.Context().Value(routeKey); rv != nil {
 		return rv.(*Route)
 	}
 	return nil
 }
 
-func setVars(r *http.Request, val interface{}) *http.Request {
-	return contextSet(r, varsKey, val)
+func requestWithVars(r *http.Request, vars map[string]string) *http.Request {
+	ctx := context.WithValue(r.Context(), varsKey, vars)
+	return r.WithContext(ctx)
 }
 
-func setCurrentRoute(r *http.Request, val interface{}) *http.Request {
-	return contextSet(r, routeKey, val)
+func requestWithRoute(r *http.Request, route *Route) *http.Request {
+	ctx := context.WithValue(r.Context(), routeKey, route)
+	return r.WithContext(ctx)
 }
 
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=f395758b854c4efa789b8c1e9b73479704c548cb,https://github.com/gorilla/mux/blob/f395758b854c4efa789b8c1e9b73479704c548cb/mux.go
f395758b854c4efa789b8c1e9b73479704c548cb,1c906689a8e532fedd7adc114df628f7c6d6b53c,mux_test.go,,"Thu, 24 Oct 2019 12:12:56 GMT",modified,24,0,24,"@@ -7,6 +7,7 @@ package mux
 import (
 	""bufio""
 	""bytes""
+	""context""
 	""errors""
 	""fmt""
 	""io/ioutil""
@@ -16,6 +17,7 @@ import (
 	""reflect""
 	""strings""
 	""testing""
+	""time""
 )
 
 func (r *Route) GoString() string {
@@ -2804,6 +2806,28 @@ func TestSubrouterNotFound(t *testing.T) {
 	}
 }
 
+func TestContextMiddleware(t *testing.T) {
+	withTimeout := func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			ctx, cancel := context.WithTimeout(r.Context(), time.Minute)
+			defer cancel()
+			h.ServeHTTP(w, r.WithContext(ctx))
+		})
+	}
+
+	r := NewRouter()
+	r.Handle(""/path/{foo}"", withTimeout(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		vars := Vars(r)
+		if vars[""foo""] != ""bar"" {
+			t.Fatal(""Expected foo var to be set"")
+		}
+	})))
+
+	rec := NewRecorder()
+	req := newRequest(""GET"", ""/path/bar"")
+	r.ServeHTTP(rec, req)
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=f395758b854c4efa789b8c1e9b73479704c548cb,https://github.com/gorilla/mux/blob/f395758b854c4efa789b8c1e9b73479704c548cb/mux_test.go
f395758b854c4efa789b8c1e9b73479704c548cb,5f5c496de0129816966873f31cce8b41c76668fe,test_helpers.go,,"Thu, 24 Oct 2019 12:12:56 GMT",modified,1,1,2,"@@ -15,5 +15,5 @@ import ""net/http""
 // can be set by making a route that captures the required variables,
 // starting a server and sending the request to that server.
 func SetURLVars(r *http.Request, val map[string]string) *http.Request {
-	return setVars(r, val)
+	return requestWithVars(r, val)
 }",https://api.github.com/repos/gorilla/mux/contents/test_helpers.go?ref=f395758b854c4efa789b8c1e9b73479704c548cb,https://github.com/gorilla/mux/blob/f395758b854c4efa789b8c1e9b73479704c548cb/test_helpers.go
ff4e71f144166b1dfe3017a146f8ed32a82e688b,5d2f4d3a9939238e74e4c56daa45dd9610fd8a11,mux_httpserver_test.go,,"Fri, 18 Oct 2019 00:48:19 GMT",added,49,0,49,"@@ -0,0 +1,49 @@
+// +build go1.9
+
+package mux
+
+import (
+	""bytes""
+	""io/ioutil""
+	""net/http""
+	""net/http/httptest""
+	""testing""
+)
+
+func TestSchemeMatchers(t *testing.T) {
+	router := NewRouter()
+	router.HandleFunc(""/"", func(rw http.ResponseWriter, r *http.Request) {
+		rw.Write([]byte(""hello http world""))
+	}).Schemes(""http"")
+	router.HandleFunc(""/"", func(rw http.ResponseWriter, r *http.Request) {
+		rw.Write([]byte(""hello https world""))
+	}).Schemes(""https"")
+
+	assertResponseBody := func(t *testing.T, s *httptest.Server, expectedBody string) {
+		resp, err := s.Client().Get(s.URL)
+		if err != nil {
+			t.Fatalf(""unexpected error getting from server: %v"", err)
+		}
+		if resp.StatusCode != 200 {
+			t.Fatalf(""expected a status code of 200, got %v"", resp.StatusCode)
+		}
+		body, err := ioutil.ReadAll(resp.Body)
+		if err != nil {
+			t.Fatalf(""unexpected error reading body: %v"", err)
+		}
+		if !bytes.Equal(body, []byte(expectedBody)) {
+			t.Fatalf(""response should be hello world, was: %q"", string(body))
+		}
+	}
+
+	t.Run(""httpServer"", func(t *testing.T) {
+		s := httptest.NewServer(router)
+		defer s.Close()
+		assertResponseBody(t, s, ""hello http world"")
+	})
+	t.Run(""httpsServer"", func(t *testing.T) {
+		s := httptest.NewTLSServer(router)
+		defer s.Close()
+		assertResponseBody(t, s, ""hello https world"")
+	})
+}",https://api.github.com/repos/gorilla/mux/contents/mux_httpserver_test.go?ref=ff4e71f144166b1dfe3017a146f8ed32a82e688b,https://github.com/gorilla/mux/blob/ff4e71f144166b1dfe3017a146f8ed32a82e688b/mux_httpserver_test.go
ff4e71f144166b1dfe3017a146f8ed32a82e688b,9a740bb8e99a401d8d1a60f9747563c6196656ea,mux_test.go,,"Fri, 18 Oct 2019 00:48:19 GMT",modified,2,4,6,"@@ -11,6 +11,7 @@ import (
 	""fmt""
 	""io/ioutil""
 	""net/http""
+	""net/http/httptest""
 	""net/url""
 	""reflect""
 	""strings""
@@ -2895,10 +2896,7 @@ func newRequestWithHeaders(method, url string, headers ...string) *http.Request
 
 // newRequestHost a new request with a method, url, and host header
 func newRequestHost(method, url, host string) *http.Request {
-	req, err := http.NewRequest(method, url, nil)
-	if err != nil {
-		panic(err)
-	}
+	req := httptest.NewRequest(method, url, nil)
 	req.Host = host
 	return req
 }",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=ff4e71f144166b1dfe3017a146f8ed32a82e688b,https://github.com/gorilla/mux/blob/ff4e71f144166b1dfe3017a146f8ed32a82e688b/mux_test.go
ff4e71f144166b1dfe3017a146f8ed32a82e688b,f088a95124adccc9f71aa4e66fab5f976fa41414,old_test.go,,"Fri, 18 Oct 2019 00:48:19 GMT",modified,5,12,17,"@@ -385,6 +385,11 @@ var urlBuildingTests = []urlBuildingTest{
 		vars:  []string{""subdomain"", ""foo"", ""category"", ""technology"", ""id"", ""42""},
 		url:   ""http://foo.domain.com/articles/technology/42"",
 	},
+	{
+		route: new(Route).Host(""example.com"").Schemes(""https"", ""http""),
+		vars:  []string{},
+		url:   ""https://example.com"",
+	},
 }
 
 func TestHeaderMatcher(t *testing.T) {
@@ -502,18 +507,6 @@ func TestUrlBuilding(t *testing.T) {
 		url := u.String()
 		if url != v.url {
 			t.Errorf(""expected %v, got %v"", v.url, url)
-			/*
-				reversePath := """"
-				reverseHost := """"
-				if v.route.pathTemplate != nil {
-						reversePath = v.route.pathTemplate.Reverse
-				}
-				if v.route.hostTemplate != nil {
-						reverseHost = v.route.hostTemplate.Reverse
-				}
-
-				t.Errorf(""%#v:\nexpected: %q\ngot: %q\nreverse path: %q\nreverse host: %q"", v.route, v.url, url, reversePath, reverseHost)
-			*/
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=ff4e71f144166b1dfe3017a146f8ed32a82e688b,https://github.com/gorilla/mux/blob/ff4e71f144166b1dfe3017a146f8ed32a82e688b/old_test.go
ff4e71f144166b1dfe3017a146f8ed32a82e688b,750afe570d05396cda6b4ce037f6ff2f97cafe30,route.go,,"Fri, 18 Oct 2019 00:48:19 GMT",modified,29,3,32,"@@ -412,11 +412,30 @@ func (r *Route) Queries(pairs ...string) *Route {
 type schemeMatcher []string
 
 func (m schemeMatcher) Match(r *http.Request, match *RouteMatch) bool {
-	return matchInArray(m, r.URL.Scheme)
+	scheme := r.URL.Scheme
+	// https://golang.org/pkg/net/http/#Request
+	// ""For [most] server requests, fields other than Path and RawQuery will be
+	// empty.""
+	// Since we're an http muxer, the scheme is either going to be http or https
+	// though, so we can just set it based on the tls termination state.
+	if scheme == """" {
+		if r.TLS == nil {
+			scheme = ""http""
+		} else {
+			scheme = ""https""
+		}
+	}
+	return matchInArray(m, scheme)
 }
 
 // Schemes adds a matcher for URL schemes.
 // It accepts a sequence of schemes to be matched, e.g.: ""http"", ""https"".
+// If the request's URL has a scheme set, it will be matched against.
+// Generally, the URL scheme will only be set if a previous handler set it,
+// such as the ProxyHeaders handler from gorilla/handlers.
+// If unset, the scheme will be determined based on the request's TLS
+// termination state.
+// The first argument to Schemes will be used when constructing a route URL.
 func (r *Route) Schemes(schemes ...string) *Route {
 	for k, v := range schemes {
 		schemes[k] = strings.ToLower(v)
@@ -493,15 +512,22 @@ func (r *Route) Subrouter() *Router {
 // This also works for host variables:
 //
 //     r := mux.NewRouter()
-//     r.Host(""{subdomain}.domain.com"").
-//       HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+//     r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+//       Host(""{subdomain}.domain.com"").
 //       Name(""article"")
 //
 //     // url.String() will be ""http://news.domain.com/articles/technology/42""
 //     url, err := r.Get(""article"").URL(""subdomain"", ""news"",
 //                                      ""category"", ""technology"",
 //                                      ""id"", ""42"")
 //
+// The scheme of the resulting url will be the first argument that was passed to Schemes:
+//
+//     // url.String() will be ""https://example.com""
+//     r := mux.NewRouter()
+//     url, err := r.Host(""example.com"")
+//                  .Schemes(""https"", ""http"").URL()
+//
 // All variables defined in the route are required, and their values must
 // conform to the corresponding patterns.
 func (r *Route) URL(pairs ...string) (*url.URL, error) {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=ff4e71f144166b1dfe3017a146f8ed32a82e688b,https://github.com/gorilla/mux/blob/ff4e71f144166b1dfe3017a146f8ed32a82e688b/route.go
884b5ffcbd3a11b730f0b75f5c86ac408753c34d,0293a928e9b707a052e2961e58a88cc9e633cc89,regexp.go,,"Fri, 30 Aug 2019 12:11:56 GMT",modified,1,1,2,"@@ -195,7 +195,7 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 
 // url builds a URL part using the given values.
 func (r *routeRegexp) url(values map[string]string) (string, error) {
-	urlValues := make([]interface{}, len(r.varsN))
+	urlValues := make([]interface{}, len(r.varsN), len(r.varsN))
 	for k, v := range r.varsN {
 		value, ok := values[v]
 		if !ok {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=884b5ffcbd3a11b730f0b75f5c86ac408753c34d,https://github.com/gorilla/mux/blob/884b5ffcbd3a11b730f0b75f5c86ac408753c34d/regexp.go
884b5ffcbd3a11b730f0b75f5c86ac408753c34d,4098cb79d0239ff3f510102b3ffa8b0f154e0eb1,route.go,,"Fri, 30 Aug 2019 12:11:56 GMT",modified,2,2,4,"@@ -635,7 +635,7 @@ func (r *Route) GetQueriesRegexp() ([]string, error) {
 	if r.regexp.queries == nil {
 		return nil, errors.New(""mux: route doesn't have queries"")
 	}
-	var queries []string
+	queries := make([]string, 0, len(r.regexp.queries))
 	for _, query := range r.regexp.queries {
 		queries = append(queries, query.regexp.String())
 	}
@@ -654,7 +654,7 @@ func (r *Route) GetQueriesTemplates() ([]string, error) {
 	if r.regexp.queries == nil {
 		return nil, errors.New(""mux: route doesn't have queries"")
 	}
-	var queries []string
+	queries := make([]string, 0, len(r.regexp.queries))
 	for _, query := range r.regexp.queries {
 		queries = append(queries, query.template)
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=884b5ffcbd3a11b730f0b75f5c86ac408753c34d,https://github.com/gorilla/mux/blob/884b5ffcbd3a11b730f0b75f5c86ac408753c34d/route.go
e1863a64f3c620ef604fb7905a0351e69f6a51e4,edcee572ac248f1503eb6c1abbeadd43a594dfbd,mux_test.go,,"Tue, 27 Aug 2019 12:58:13 GMT",modified,3,3,6,"@@ -2046,7 +2046,7 @@ func TestNoMatchMethodErrorHandler(t *testing.T) {
 
 	resp := NewRecorder()
 	r.ServeHTTP(resp, req)
-	if resp.Code != 405 {
+	if resp.Code != http.StatusMethodNotAllowed {
 		t.Errorf(""Expecting code %v"", 405)
 	}
 
@@ -2725,7 +2725,7 @@ func TestMethodNotAllowed(t *testing.T) {
 
 	router.ServeHTTP(w, req)
 
-	if w.Code != 405 {
+	if w.Code != http.StatusMethodNotAllowed {
 		t.Fatalf(""Expected status code 405 (got %d)"", w.Code)
 	}
 }
@@ -2798,7 +2798,7 @@ func TestSubrouterNotFound(t *testing.T) {
 
 	router.ServeHTTP(w, req)
 
-	if w.Code != 404 {
+	if w.Code != http.StatusNotFound {
 		t.Fatalf(""Expected status code 404 (got %d)"", w.Code)
 	}
 }",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e1863a64f3c620ef604fb7905a0351e69f6a51e4,https://github.com/gorilla/mux/blob/e1863a64f3c620ef604fb7905a0351e69f6a51e4/mux_test.go
9536e4053d763b54d935f1ce731a315cfb42b979,e252d391f8fc5900fbd0daa188ba2ab58a8b0d47,mux_test.go,,"Mon, 26 Aug 2019 00:11:59 GMT",modified,58,0,58,"@@ -9,6 +9,7 @@ import (
 	""bytes""
 	""errors""
 	""fmt""
+	""io/ioutil""
 	""net/http""
 	""net/url""
 	""reflect""
@@ -2729,6 +2730,63 @@ func TestMethodNotAllowed(t *testing.T) {
 	}
 }
 
+type customMethodNotAllowedHandler struct {
+	msg string
+}
+
+func (h customMethodNotAllowedHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+	w.WriteHeader(http.StatusMethodNotAllowed)
+	fmt.Fprint(w, h.msg)
+}
+
+func TestSubrouterCustomMethodNotAllowed(t *testing.T) {
+	handler := func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }
+
+	router := NewRouter()
+	router.HandleFunc(""/test"", handler).Methods(http.MethodGet)
+	router.MethodNotAllowedHandler = customMethodNotAllowedHandler{msg: ""custom router handler""}
+
+	subrouter := router.PathPrefix(""/sub"").Subrouter()
+	subrouter.HandleFunc(""/test"", handler).Methods(http.MethodGet)
+	subrouter.MethodNotAllowedHandler = customMethodNotAllowedHandler{msg: ""custom sub router handler""}
+
+	testCases := map[string]struct {
+		path   string
+		expMsg string
+	}{
+		""router method not allowed"": {
+			path:   ""/test"",
+			expMsg: ""custom router handler"",
+		},
+		""subrouter method not allowed"": {
+			path:   ""/sub/test"",
+			expMsg: ""custom sub router handler"",
+		},
+	}
+
+	for name, tc := range testCases {
+		t.Run(name, func(tt *testing.T) {
+			w := NewRecorder()
+			req := newRequest(http.MethodPut, tc.path)
+
+			router.ServeHTTP(w, req)
+
+			if w.Code != http.StatusMethodNotAllowed {
+				tt.Errorf(""Expected status code 405 (got %d)"", w.Code)
+			}
+
+			b, err := ioutil.ReadAll(w.Body)
+			if err != nil {
+				tt.Errorf(""failed to read body: %v"", err)
+			}
+
+			if string(b) != tc.expMsg {
+				tt.Errorf(""expected msg %q, got %q"", tc.expMsg, string(b))
+			}
+		})
+	}
+}
+
 func TestSubrouterNotFound(t *testing.T) {
 	handler := func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }
 	router := NewRouter()",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=9536e4053d763b54d935f1ce731a315cfb42b979,https://github.com/gorilla/mux/blob/9536e4053d763b54d935f1ce731a315cfb42b979/mux_test.go
9536e4053d763b54d935f1ce731a315cfb42b979,7343d78a78033e27de9bfe1618901dc00dad4485,route.go,,"Mon, 26 Aug 2019 00:11:59 GMT",modified,1,1,2,"@@ -74,7 +74,7 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 		return false
 	}
 
-	if match.MatchErr == ErrMethodMismatch {
+	if match.MatchErr == ErrMethodMismatch && r.handler != nil {
 		// We found a route which matches request method, clear MatchErr
 		match.MatchErr = nil
 		// Then override the mis-matched handler",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=9536e4053d763b54d935f1ce731a315cfb42b979,https://github.com/gorilla/mux/blob/9536e4053d763b54d935f1ce731a315cfb42b979/route.go
e0cdff45b7de56d3ad24ef9871c14fe4238475aa,35eea9f1063546bbcfc3f86f45bb752596cdc354,README.md,,"Sat, 24 Aug 2019 00:44:47 GMT",modified,1,1,2,"@@ -4,7 +4,7 @@
 [![CircleCI](https://circleci.com/gh/gorilla/mux.svg?style=svg)](https://circleci.com/gh/gorilla/mux)
 [![Sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
 
-![Gorilla Logo](http://www.gorillatoolkit.org/static/images/gorilla-icon-64.png)
+![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 
 https://www.gorillatoolkit.org/pkg/mux
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=e0cdff45b7de56d3ad24ef9871c14fe4238475aa,https://github.com/gorilla/mux/blob/e0cdff45b7de56d3ad24ef9871c14fe4238475aa/README.md
e67b3c02c7195c052acff13261f0c9fd1ba53011,28df9a9f2ed5f9f21efca72a8baabf9cbc35daa5,README.md,,"Sat, 20 Jul 2019 20:14:35 GMT",modified,0,1,1,"@@ -1,7 +1,6 @@
 # gorilla/mux
 
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
-[![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
 [![CircleCI](https://circleci.com/gh/gorilla/mux.svg?style=svg)](https://circleci.com/gh/gorilla/mux)
 [![Sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=e67b3c02c7195c052acff13261f0c9fd1ba53011,https://github.com/gorilla/mux/blob/e67b3c02c7195c052acff13261f0c9fd1ba53011/README.md
7a1bf406d6f5f8cfef4802eb0d949606c6ee7aea,9c5b86a59ed3fef57c22e45f78b9e0d340cdb981,README.md,,"Sat, 20 Jul 2019 14:53:35 GMT",modified,88,0,88,"@@ -26,6 +26,7 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 * [Examples](#examples)
 * [Matching Routes](#matching-routes)
 * [Static Files](#static-files)
+* [Serving Single Page Applications](#serving-single-page-applications) (e.g. React, Vue, Ember.js, etc.)
 * [Registered URLs](#registered-urls)
 * [Walking Routes](#walking-routes)
 * [Graceful Shutdown](#graceful-shutdown)
@@ -212,6 +213,93 @@ func main() {
 }
 ```
 
+### Serving Single Page Applications
+
+Most of the time it makes sense to serve your SPA on a separate web server from your API,
+but sometimes it's desirable to serve them both from one place. It's possible to write a simple
+handler for serving your SPA (for use with React Router's [BrowserRouter](https://reacttraining.com/react-router/web/api/BrowserRouter) for example), and leverage
+mux's powerful routing for your API endpoints.
+
+```go
+package main
+
+import (
+	""encoding/json""
+	""log""
+	""net/http""
+	""os""
+	""path/filepath""
+	""time""
+
+	""github.com/gorilla/mux""
+)
+
+// spaHandler implements the http.Handler interface, so we can use it
+// to respond to HTTP requests. The path to the static directory and
+// path to the index file within that static directory are used to
+// serve the SPA in the given static directory.
+type spaHandler struct {
+	staticPath string
+	indexPath  string
+}
+
+// ServeHTTP inspects the URL path to locate a file within the static dir
+// on the SPA handler. If a file is found, it will be served. If not, the
+// file located at the index path on the SPA handler will be served. This
+// is suitable behavior for serving an SPA (single page application).
+func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
+    // get the absolute path to prevent directory traversal
+	path, err := filepath.Abs(r.URL.Path)
+	if err != nil {
+        // if we failed to get the absolute path respond with a 400 bad request
+        // and stop
+		http.Error(w, err.Error(), http.StatusBadRequest)
+		return
+	}
+
+    // prepend the path with the path to the static directory
+	path = filepath.Join(h.staticPath, path)
+
+    // check whether a file exists at the given path
+	_, err = os.Stat(path)
+	if os.IsNotExist(err) {
+		// file does not exist, serve index.html
+		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))
+		return
+	} else if err != nil {
+        // if we got an error (that wasn't that the file doesn't exist) stating the
+        // file, return a 500 internal server error and stop
+		http.Error(w, err.Error(), http.StatusInternalServerError)
+		return
+	}
+
+    // otherwise, use http.FileServer to serve the static dir
+	http.FileServer(http.Dir(h.staticPath)).ServeHTTP(w, r)
+}
+
+func main() {
+	router := mux.NewRouter()
+
+	router.HandleFunc(""/api/health"", func(w http.ResponseWriter, r *http.Request) {
+		// an example API handler
+		json.NewEncoder(w).Encode(map[string]bool{""ok"": true})
+	})
+
+	spa := spaHandler{staticPath: ""build"", indexPath: ""index.html""}
+	router.PathPrefix(""/"").Handler(spa)
+
+	srv := &http.Server{
+		Handler: router,
+		Addr:    ""127.0.0.1:8000"",
+		// Good practice: enforce timeouts for servers you create!
+		WriteTimeout: 15 * time.Second,
+		ReadTimeout:  15 * time.Second,
+	}
+
+	log.Fatal(srv.ListenAndServe())
+}
+```
+
 ### Registered URLs
 
 Now let's see how to build registered URLs.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=7a1bf406d6f5f8cfef4802eb0d949606c6ee7aea,https://github.com/gorilla/mux/blob/7a1bf406d6f5f8cfef4802eb0d949606c6ee7aea/README.md
7a1bf406d6f5f8cfef4802eb0d949606c6ee7aea,df170a3994039cc1eec4706d616c9443a4c0dcc8,go.mod,,"Sat, 20 Jul 2019 14:53:35 GMT",modified,2,0,2,"@@ -1 +1,3 @@
 module github.com/gorilla/mux
+
+go 1.12",https://api.github.com/repos/gorilla/mux/contents/go.mod?ref=7a1bf406d6f5f8cfef4802eb0d949606c6ee7aea,https://github.com/gorilla/mux/blob/7a1bf406d6f5f8cfef4802eb0d949606c6ee7aea/go.mod
eab9c4f3d22d907d728aa0f5918934357866249e,26f9582ac844175bea315323aeba63ff4245e2ed,mux.go,,"Sat, 20 Jul 2019 14:49:38 GMT",modified,2,4,6,"@@ -111,10 +111,8 @@ func copyRouteConf(r routeConf) routeConf {
 		c.regexp.queries = append(c.regexp.queries, copyRouteRegexp(q))
 	}
 
-	c.matchers = make([]matcher, 0, len(r.matchers))
-	for _, m := range r.matchers {
-		c.matchers = append(c.matchers, m)
-	}
+	c.matchers = make([]matcher, len(r.matchers))
+	copy(c.matchers, r.matchers)
 
 	return c
 }",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=eab9c4f3d22d907d728aa0f5918934357866249e,https://github.com/gorilla/mux/blob/eab9c4f3d22d907d728aa0f5918934357866249e/mux.go
50fbc3e7fbfcdb4fb850686588071e5f0bdd4a0a,34c00dd25ad407ade21a7debc829bb11439c3070,mux_test.go,,"Sat, 20 Jul 2019 14:48:32 GMT",modified,1,1,2,"@@ -1943,7 +1943,7 @@ type TestA301ResponseWriter struct {
 }
 
 func (ho *TestA301ResponseWriter) Header() http.Header {
-	return http.Header(ho.hh)
+	return ho.hh
 }
 
 func (ho *TestA301ResponseWriter) Write(b []byte) (int, error) {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=50fbc3e7fbfcdb4fb850686588071e5f0bdd4a0a,https://github.com/gorilla/mux/blob/50fbc3e7fbfcdb4fb850686588071e5f0bdd4a0a/mux_test.go
d83b6ffe499a29cc05fc977988d0392851779620,536bc119f68265ce3bed2d8eac3ff17a29d37067,.circleci/config.yml,,"Mon, 01 Jul 2019 20:26:33 GMT",modified,26,14,40,"@@ -8,23 +8,35 @@ jobs:
       - image: circleci/golang:latest
     working_directory: /go/src/github.com/gorilla/mux
     steps: &steps
+      # Our build steps: we checkout the repo, fetch our deps, lint, and finally
+      # run ""go test"" on the package.
       - checkout
+      # Logs the version in our build logs, for posterity
       - run: go version
-      - run: go get -t -v ./...
+      - run:
+          name: ""Fetch dependencies""
+          command: >
+            go get -t -v ./...
       # Only run gofmt, vet & lint against the latest Go version
-      - run: >
-          if [[ ""$LATEST"" = true ]]; then
-            go get -u golang.org/x/lint/golint
-            golint ./...
-          fi
-      - run: >
-          if [[ ""$LATEST"" = true ]]; then
-            diff -u <(echo -n) <(gofmt -d .)
-          fi
-      - run: >
-          if [[ ""$LATEST"" = true ]]; then
-            go vet -v .
-          fi
+      - run:
+          name: ""Run golint""
+          command: >
+            if [ ""${LATEST}"" = true ] && [ -z ""${SKIP_GOLINT}"" ]; then
+              go get -u golang.org/x/lint/golint
+              golint ./...
+            fi
+      - run:
+          name: ""Run gofmt""
+          command: >
+            if [[ ""${LATEST}"" = true ]]; then
+              diff -u <(echo -n) <(gofmt -d -e .)
+            fi
+      - run:
+          name: ""Run go vet""
+          command:  >
+            if [[ ""${LATEST}"" = true ]]; then
+              go vet -v ./...
+            fi
       - run: go test -v -race ./...
 
   ""latest"":",https://api.github.com/repos/gorilla/mux/contents/.circleci%2Fconfig.yml?ref=d83b6ffe499a29cc05fc977988d0392851779620,https://github.com/gorilla/mux/blob/d83b6ffe499a29cc05fc977988d0392851779620/.circleci%2Fconfig.yml
00bdffe0f3c77e27d2cf6f5c70232a2d3e4d9c15,f4b12d30baf37382ec63e7a309bcab4d48c7ec41,.github/stale.yml,,"Sun, 30 Jun 2019 04:17:52 GMT",modified,5,5,10,"@@ -1,10 +1,10 @@
-daysUntilStale: 60
-daysUntilClose: 7
+daysUntilStale: 75
+daysUntilClose: 14
 # Issues with these labels will never be considered stale
 exemptLabels:
-  - v2
-  - needs-review
-  - work-required
+  - proposal
+  - needs review
+  - build system
 staleLabel: stale
 markComment: >
   This issue has been automatically marked as stale because it hasn't seen",https://api.github.com/repos/gorilla/mux/contents/.github%2Fstale.yml?ref=00bdffe0f3c77e27d2cf6f5c70232a2d3e4d9c15,https://github.com/gorilla/mux/blob/00bdffe0f3c77e27d2cf6f5c70232a2d3e4d9c15/.github%2Fstale.yml
05347690167e152b85ece29fdfa9cc12a7b8c385,d7d96d14d9980db2af389ab4d29e8b108234144a,.circleci/config.yml,,"Sat, 29 Jun 2019 20:52:29 GMT",modified,14,2,16,"@@ -11,8 +11,20 @@ jobs:
       - checkout
       - run: go version
       - run: go get -t -v ./...
-      - run: diff -u <(echo -n) <(gofmt -d .)
-      - run: if [[ ""$LATEST"" = true ]]; then go vet -v .; fi
+      # Only run gofmt, vet & lint against the latest Go version
+      - run: >
+          if [[ ""$LATEST"" = true ]]; then
+            go get -u golang.org/x/lint/golint
+            golint ./...
+          fi
+      - run: >
+          if [[ ""$LATEST"" = true ]]; then
+            diff -u <(echo -n) <(gofmt -d .)
+          fi
+      - run: >
+          if [[ ""$LATEST"" = true ]]; then
+            go vet -v .
+          fi
       - run: go test -v -race ./...
 
   ""latest"":",https://api.github.com/repos/gorilla/mux/contents/.circleci%2Fconfig.yml?ref=05347690167e152b85ece29fdfa9cc12a7b8c385,https://github.com/gorilla/mux/blob/05347690167e152b85ece29fdfa9cc12a7b8c385/.circleci%2Fconfig.yml
05347690167e152b85ece29fdfa9cc12a7b8c385,92e422eed7af33c5ba7d455e60dc7ebf7c856b01,README.md,,"Sat, 29 Jun 2019 20:52:29 GMT",modified,68,0,68,"@@ -30,6 +30,7 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 * [Walking Routes](#walking-routes)
 * [Graceful Shutdown](#graceful-shutdown)
 * [Middleware](#middleware)
+* [Handling CORS Requests](#handling-cors-requests)
 * [Testing Handlers](#testing-handlers)
 * [Full Example](#full-example)
 
@@ -492,6 +493,73 @@ r.Use(amw.Middleware)
 
 Note: The handler chain will be stopped if your middleware doesn't call `next.ServeHTTP()` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to. Middlewares _should_ write to `ResponseWriter` if they _are_ going to terminate the request, and they _should not_ write to `ResponseWriter` if they _are not_ going to terminate it.
 
+### Handling CORS Requests
+
+[CORSMethodMiddleware](https://godoc.org/github.com/gorilla/mux#CORSMethodMiddleware) intends to make it easier to strictly set the `Access-Control-Allow-Methods` response header.
+
+* You will still need to use your own CORS handler to set the other CORS headers such as `Access-Control-Allow-Origin`
+* The middleware will set the `Access-Control-Allow-Methods` header to all the method matchers (e.g. `r.Methods(http.MethodGet, http.MethodPut, http.MethodOptions)` -> `Access-Control-Allow-Methods: GET,PUT,OPTIONS`) on a route
+* If you do not specify any methods, then:
+> _Important_: there must be an `OPTIONS` method matcher for the middleware to set the headers.
+
+Here is an example of using `CORSMethodMiddleware` along with a custom `OPTIONS` handler to set all the required CORS headers:
+
+```go
+package main
+
+import (
+	""net/http""
+	""github.com/gorilla/mux""
+)
+
+func main() {
+    r := mux.NewRouter()
+
+    // IMPORTANT: you must specify an OPTIONS method matcher for the middleware to set CORS headers
+    r.HandleFunc(""/foo"", fooHandler).Methods(http.MethodGet, http.MethodPut, http.MethodPatch, http.MethodOptions)
+    r.Use(mux.CORSMethodMiddleware(r))
+    
+    http.ListenAndServe("":8080"", r)
+}
+
+func fooHandler(w http.ResponseWriter, r *http.Request) {
+    w.Header().Set(""Access-Control-Allow-Origin"", ""*"")
+    if r.Method == http.MethodOptions {
+        return
+    }
+
+    w.Write([]byte(""foo""))
+}
+```
+
+And an request to `/foo` using something like:
+
+```bash
+curl localhost:8080/foo -v
+```
+
+Would look like:
+
+```bash
+*   Trying ::1...
+* TCP_NODELAY set
+* Connected to localhost (::1) port 8080 (#0)
+> GET /foo HTTP/1.1
+> Host: localhost:8080
+> User-Agent: curl/7.59.0
+> Accept: */*
+> 
+< HTTP/1.1 200 OK
+< Access-Control-Allow-Methods: GET,PUT,PATCH,OPTIONS
+< Access-Control-Allow-Origin: *
+< Date: Fri, 28 Jun 2019 20:13:30 GMT
+< Content-Length: 3
+< Content-Type: text/plain; charset=utf-8
+< 
+* Connection #0 to host localhost left intact
+foo
+```
+
 ### Testing Handlers
 
 Testing handlers in a Go web application is straightforward, and _mux_ doesn't complicate this any further. Given two files: `endpoints.go` and `endpoints_test.go`, here's how we'd test an application using _mux_.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=05347690167e152b85ece29fdfa9cc12a7b8c385,https://github.com/gorilla/mux/blob/05347690167e152b85ece29fdfa9cc12a7b8c385/README.md
05347690167e152b85ece29fdfa9cc12a7b8c385,00929fcee5bab178b6b0fc04d864e6c7621d80b6,example_cors_method_middleware_test.go,,"Sat, 29 Jun 2019 20:52:29 GMT",added,37,0,37,"@@ -0,0 +1,37 @@
+package mux_test
+
+import (
+	""fmt""
+	""net/http""
+	""net/http/httptest""
+
+	""github.com/gorilla/mux""
+)
+
+func ExampleCORSMethodMiddleware() {
+	r := mux.NewRouter()
+
+	r.HandleFunc(""/foo"", func(w http.ResponseWriter, r *http.Request) {
+		// Handle the request
+	}).Methods(http.MethodGet, http.MethodPut, http.MethodPatch)
+	r.HandleFunc(""/foo"", func(w http.ResponseWriter, r *http.Request) {
+		w.Header().Set(""Access-Control-Allow-Origin"", ""http://example.com"")
+		w.Header().Set(""Access-Control-Max-Age"", ""86400"")
+	}).Methods(http.MethodOptions)
+
+	r.Use(mux.CORSMethodMiddleware(r))
+
+	rw := httptest.NewRecorder()
+	req, _ := http.NewRequest(""OPTIONS"", ""/foo"", nil)                 // needs to be OPTIONS
+	req.Header.Set(""Access-Control-Request-Method"", ""POST"")           // needs to be non-empty
+	req.Header.Set(""Access-Control-Request-Headers"", ""Authorization"") // needs to be non-empty
+	req.Header.Set(""Origin"", ""http://example.com"")                    // needs to be non-empty
+
+	r.ServeHTTP(rw, req)
+
+	fmt.Println(rw.Header().Get(""Access-Control-Allow-Methods""))
+	fmt.Println(rw.Header().Get(""Access-Control-Allow-Origin""))
+	// Output:
+	// GET,PUT,PATCH,OPTIONS
+	// http://example.com
+}",https://api.github.com/repos/gorilla/mux/contents/example_cors_method_middleware_test.go?ref=05347690167e152b85ece29fdfa9cc12a7b8c385,https://github.com/gorilla/mux/blob/05347690167e152b85ece29fdfa9cc12a7b8c385/example_cors_method_middleware_test.go
05347690167e152b85ece29fdfa9cc12a7b8c385,cf2b26dc037a47aee4da5100e2ef81f975bf6621,middleware.go,,"Sat, 29 Jun 2019 20:52:29 GMT",modified,34,27,61,"@@ -32,41 +32,48 @@ func (r *Router) useInterface(mw middleware) {
 	r.middlewares = append(r.middlewares, mw)
 }
 
-// CORSMethodMiddleware sets the Access-Control-Allow-Methods response header
-// on a request, by matching routes based only on paths. It also handles
-// OPTIONS requests, by settings Access-Control-Allow-Methods, and then
-// returning without calling the next http handler.
+// CORSMethodMiddleware automatically sets the Access-Control-Allow-Methods response header
+// on requests for routes that have an OPTIONS method matcher to all the method matchers on
+// the route. Routes that do not explicitly handle OPTIONS requests will not be processed
+// by the middleware. See examples for usage.
 func CORSMethodMiddleware(r *Router) MiddlewareFunc {
 	return func(next http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
-			var allMethods []string
-
-			err := r.Walk(func(route *Route, _ *Router, _ []*Route) error {
-				for _, m := range route.matchers {
-					if _, ok := m.(*routeRegexp); ok {
-						if m.Match(req, &RouteMatch{}) {
-							methods, err := route.GetMethods()
-							if err != nil {
-								return err
-							}
-
-							allMethods = append(allMethods, methods...)
-						}
-						break
-					}
-				}
-				return nil
-			})
-
+			allMethods, err := getAllMethodsForRoute(r, req)
 			if err == nil {
-				w.Header().Set(""Access-Control-Allow-Methods"", strings.Join(append(allMethods, ""OPTIONS""), "",""))
-
-				if req.Method == ""OPTIONS"" {
-					return
+				for _, v := range allMethods {
+					if v == http.MethodOptions {
+						w.Header().Set(""Access-Control-Allow-Methods"", strings.Join(allMethods, "",""))
+					}
 				}
 			}
 
 			next.ServeHTTP(w, req)
 		})
 	}
 }
+
+// getAllMethodsForRoute returns all the methods from method matchers matching a given
+// request.
+func getAllMethodsForRoute(r *Router, req *http.Request) ([]string, error) {
+	var allMethods []string
+
+	err := r.Walk(func(route *Route, _ *Router, _ []*Route) error {
+		for _, m := range route.matchers {
+			if _, ok := m.(*routeRegexp); ok {
+				if m.Match(req, &RouteMatch{}) {
+					methods, err := route.GetMethods()
+					if err != nil {
+						return err
+					}
+
+					allMethods = append(allMethods, methods...)
+				}
+				break
+			}
+		}
+		return nil
+	})
+
+	return allMethods, err
+}",https://api.github.com/repos/gorilla/mux/contents/middleware.go?ref=05347690167e152b85ece29fdfa9cc12a7b8c385,https://github.com/gorilla/mux/blob/05347690167e152b85ece29fdfa9cc12a7b8c385/middleware.go
05347690167e152b85ece29fdfa9cc12a7b8c385,27647afe4305df3cd8d3de9464058401860cfe97,middleware_test.go,,"Sat, 29 Jun 2019 20:52:29 GMT",modified,99,29,128,"@@ -2,9 +2,7 @@ package mux
 
 import (
 	""bytes""
-	""fmt""
 	""net/http""
-	""net/http/httptest""
 	""testing""
 )
 
@@ -367,42 +365,114 @@ func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
 }
 
 func TestCORSMethodMiddleware(t *testing.T) {
-	router := NewRouter()
-
-	cases := []struct {
-		path                   string
-		response               string
-		method                 string
-		testURL                string
-		expectedAllowedMethods string
+	testCases := []struct {
+		name                                    string
+		registerRoutes                          func(r *Router)
+		requestHeader                           http.Header
+		requestMethod                           string
+		requestPath                             string
+		expectedAccessControlAllowMethodsHeader string
+		expectedResponse                        string
 	}{
-		{""/g/{o}"", ""a"", ""POST"", ""/g/asdf"", ""POST,PUT,GET,OPTIONS""},
-		{""/g/{o}"", ""b"", ""PUT"", ""/g/bla"", ""POST,PUT,GET,OPTIONS""},
-		{""/g/{o}"", ""c"", ""GET"", ""/g/orilla"", ""POST,PUT,GET,OPTIONS""},
-		{""/g"", ""d"", ""POST"", ""/g"", ""POST,OPTIONS""},
+		{
+			name: ""does not set without OPTIONS matcher"",
+			registerRoutes: func(r *Router) {
+				r.HandleFunc(""/foo"", stringHandler(""a"")).Methods(http.MethodGet, http.MethodPut, http.MethodPatch)
+			},
+			requestMethod:                           ""GET"",
+			requestPath:                             ""/foo"",
+			expectedAccessControlAllowMethodsHeader: """",
+			expectedResponse:                        ""a"",
+		},
+		{
+			name: ""sets on non OPTIONS"",
+			registerRoutes: func(r *Router) {
+				r.HandleFunc(""/foo"", stringHandler(""a"")).Methods(http.MethodGet, http.MethodPut, http.MethodPatch)
+				r.HandleFunc(""/foo"", stringHandler(""b"")).Methods(http.MethodOptions)
+			},
+			requestMethod:                           ""GET"",
+			requestPath:                             ""/foo"",
+			expectedAccessControlAllowMethodsHeader: ""GET,PUT,PATCH,OPTIONS"",
+			expectedResponse:                        ""a"",
+		},
+		{
+			name: ""sets without preflight headers"",
+			registerRoutes: func(r *Router) {
+				r.HandleFunc(""/foo"", stringHandler(""a"")).Methods(http.MethodGet, http.MethodPut, http.MethodPatch)
+				r.HandleFunc(""/foo"", stringHandler(""b"")).Methods(http.MethodOptions)
+			},
+			requestMethod:                           ""OPTIONS"",
+			requestPath:                             ""/foo"",
+			expectedAccessControlAllowMethodsHeader: ""GET,PUT,PATCH,OPTIONS"",
+			expectedResponse:                        ""b"",
+		},
+		{
+			name: ""does not set on error"",
+			registerRoutes: func(r *Router) {
+				r.HandleFunc(""/foo"", stringHandler(""a""))
+			},
+			requestMethod:                           ""OPTIONS"",
+			requestPath:                             ""/foo"",
+			expectedAccessControlAllowMethodsHeader: """",
+			expectedResponse:                        ""a"",
+		},
+		{
+			name: ""sets header on valid preflight"",
+			registerRoutes: func(r *Router) {
+				r.HandleFunc(""/foo"", stringHandler(""a"")).Methods(http.MethodGet, http.MethodPut, http.MethodPatch)
+				r.HandleFunc(""/foo"", stringHandler(""b"")).Methods(http.MethodOptions)
+			},
+			requestMethod: ""OPTIONS"",
+			requestPath:   ""/foo"",
+			requestHeader: http.Header{
+				""Access-Control-Request-Method"":  []string{""GET""},
+				""Access-Control-Request-Headers"": []string{""Authorization""},
+				""Origin"":                         []string{""http://example.com""},
+			},
+			expectedAccessControlAllowMethodsHeader: ""GET,PUT,PATCH,OPTIONS"",
+			expectedResponse:                        ""b"",
+		},
+		{
+			name: ""does not set methods from unmatching routes"",
+			registerRoutes: func(r *Router) {
+				r.HandleFunc(""/foo"", stringHandler(""c"")).Methods(http.MethodDelete)
+				r.HandleFunc(""/foo/bar"", stringHandler(""a"")).Methods(http.MethodGet, http.MethodPut, http.MethodPatch)
+				r.HandleFunc(""/foo/bar"", stringHandler(""b"")).Methods(http.MethodOptions)
+			},
+			requestMethod: ""OPTIONS"",
+			requestPath:   ""/foo/bar"",
+			requestHeader: http.Header{
+				""Access-Control-Request-Method"":  []string{""GET""},
+				""Access-Control-Request-Headers"": []string{""Authorization""},
+				""Origin"":                         []string{""http://example.com""},
+			},
+			expectedAccessControlAllowMethodsHeader: ""GET,PUT,PATCH,OPTIONS"",
+			expectedResponse:                        ""b"",
+		},
 	}
 
-	for _, tt := range cases {
-		router.HandleFunc(tt.path, stringHandler(tt.response)).Methods(tt.method)
-	}
+	for _, tt := range testCases {
+		t.Run(tt.name, func(t *testing.T) {
+			router := NewRouter()
 
-	router.Use(CORSMethodMiddleware(router))
+			tt.registerRoutes(router)
 
-	for i, tt := range cases {
-		t.Run(fmt.Sprintf(""cases[%d]"", i), func(t *testing.T) {
-			rr := httptest.NewRecorder()
-			req := newRequest(tt.method, tt.testURL)
+			router.Use(CORSMethodMiddleware(router))
 
-			router.ServeHTTP(rr, req)
+			rw := NewRecorder()
+			req := newRequest(tt.requestMethod, tt.requestPath)
+			req.Header = tt.requestHeader
 
-			if rr.Body.String() != tt.response {
-				t.Errorf(""Expected body '%s', found '%s'"", tt.response, rr.Body.String())
-			}
+			router.ServeHTTP(rw, req)
 
-			allowedMethods := rr.Header().Get(""Access-Control-Allow-Methods"")
+			actualMethodsHeader := rw.Header().Get(""Access-Control-Allow-Methods"")
+			if actualMethodsHeader != tt.expectedAccessControlAllowMethodsHeader {
+				t.Fatalf(""Expected Access-Control-Allow-Methods to equal %s but got %s"", tt.expectedAccessControlAllowMethodsHeader, actualMethodsHeader)
+			}
 
-			if allowedMethods != tt.expectedAllowedMethods {
-				t.Errorf(""Expected Access-Control-Allow-Methods '%s', found '%s'"", tt.expectedAllowedMethods, allowedMethods)
+			actualResponse := rw.Body.String()
+			if actualResponse != tt.expectedResponse {
+				t.Fatalf(""Expected response to equal %s but got %s"", tt.expectedResponse, actualResponse)
 			}
 		})
 	}",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=05347690167e152b85ece29fdfa9cc12a7b8c385,https://github.com/gorilla/mux/blob/05347690167e152b85ece29fdfa9cc12a7b8c385/middleware_test.go
d70f7b4baacbd8115844925606cf68ee63d438cc,232be82e47a6abe7fbf9e73ccadde10b3022264c,ISSUE_TEMPLATE.md,,"Sat, 29 Jun 2019 18:01:59 GMT",removed,0,11,11,"@@ -1,11 +0,0 @@
-**What version of Go are you running?** (Paste the output of `go version`)
-
-
-**What version of gorilla/mux are you at?** (Paste the output of `git rev-parse HEAD` inside `$GOPATH/src/github.com/gorilla/mux`)
-
-
-**Describe your problem** (and what you have tried so far)
-
-
-**Paste a minimal, runnable, reproduction of your issue below** (use backticks to format it)
-",https://api.github.com/repos/gorilla/mux/contents/ISSUE_TEMPLATE.md?ref=48f941fa99947e50375f2b0dd4b3b060d15b2fe8,https://github.com/gorilla/mux/blob/48f941fa99947e50375f2b0dd4b3b060d15b2fe8/ISSUE_TEMPLATE.md
48f941fa99947e50375f2b0dd4b3b060d15b2fe8,30df27461b1afb11a4006dedaf3bc7c6f0581598,middleware_test.go,,"Sat, 29 Jun 2019 17:24:12 GMT",modified,210,172,382,"@@ -2,6 +2,7 @@ package mux
 
 import (
 	""bytes""
+	""fmt""
 	""net/http""
 	""net/http/httptest""
 	""testing""
@@ -28,20 +29,20 @@ func TestMiddlewareAdd(t *testing.T) {
 
 	router.useInterface(mw)
 	if len(router.middlewares) != 1 || router.middlewares[0] != mw {
-		t.Fatal(""Middleware was not added correctly"")
+		t.Fatal(""Middleware interface was not added correctly"")
 	}
 
 	router.Use(mw.Middleware)
 	if len(router.middlewares) != 2 {
-		t.Fatal(""MiddlewareFunc method was not added correctly"")
+		t.Fatal(""Middleware method was not added correctly"")
 	}
 
 	banalMw := func(handler http.Handler) http.Handler {
 		return handler
 	}
 	router.Use(banalMw)
 	if len(router.middlewares) != 3 {
-		t.Fatal(""MiddlewareFunc method was not added correctly"")
+		t.Fatal(""Middleware function was not added correctly"")
 	}
 }
 
@@ -55,34 +56,37 @@ func TestMiddleware(t *testing.T) {
 	rw := NewRecorder()
 	req := newRequest(""GET"", ""/"")
 
-	// Test regular middleware call
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 1 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
-	}
-
-	// Middleware should not be called for 404
-	req = newRequest(""GET"", ""/not/found"")
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 1 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
-	}
+	t.Run(""regular middleware call"", func(t *testing.T) {
+		router.ServeHTTP(rw, req)
+		if mw.timesCalled != 1 {
+			t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+		}
+	})
 
-	// Middleware should not be called if there is a method mismatch
-	req = newRequest(""POST"", ""/"")
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 1 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
-	}
+	t.Run(""not called for 404"", func(t *testing.T) {
+		req = newRequest(""GET"", ""/not/found"")
+		router.ServeHTTP(rw, req)
+		if mw.timesCalled != 1 {
+			t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+		}
+	})
 
-	// Add the middleware again as function
-	router.Use(mw.Middleware)
-	req = newRequest(""GET"", ""/"")
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 3 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 3, mw.timesCalled)
-	}
+	t.Run(""not called for method mismatch"", func(t *testing.T) {
+		req = newRequest(""POST"", ""/"")
+		router.ServeHTTP(rw, req)
+		if mw.timesCalled != 1 {
+			t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+		}
+	})
 
+	t.Run(""regular call using function middleware"", func(t *testing.T) {
+		router.Use(mw.Middleware)
+		req = newRequest(""GET"", ""/"")
+		router.ServeHTTP(rw, req)
+		if mw.timesCalled != 3 {
+			t.Fatalf(""Expected %d calls, but got only %d"", 3, mw.timesCalled)
+		}
+	})
 }
 
 func TestMiddlewareSubrouter(t *testing.T) {
@@ -98,42 +102,56 @@ func TestMiddlewareSubrouter(t *testing.T) {
 	rw := NewRecorder()
 	req := newRequest(""GET"", ""/"")
 
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 0 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 0, mw.timesCalled)
-	}
+	t.Run(""not called for route outside subrouter"", func(t *testing.T) {
+		router.ServeHTTP(rw, req)
+		if mw.timesCalled != 0 {
+			t.Fatalf(""Expected %d calls, but got only %d"", 0, mw.timesCalled)
+		}
+	})
 
-	req = newRequest(""GET"", ""/sub/"")
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 0 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 0, mw.timesCalled)
-	}
+	t.Run(""not called for subrouter root 404"", func(t *testing.T) {
+		req = newRequest(""GET"", ""/sub/"")
+		router.ServeHTTP(rw, req)
+		if mw.timesCalled != 0 {
+			t.Fatalf(""Expected %d calls, but got only %d"", 0, mw.timesCalled)
+		}
+	})
 
-	req = newRequest(""GET"", ""/sub/x"")
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 1 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
-	}
+	t.Run(""called once for route inside subrouter"", func(t *testing.T) {
+		req = newRequest(""GET"", ""/sub/x"")
+		router.ServeHTTP(rw, req)
+		if mw.timesCalled != 1 {
+			t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+		}
+	})
 
-	req = newRequest(""GET"", ""/sub/not/found"")
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 1 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
-	}
+	t.Run(""not called for 404 inside subrouter"", func(t *testing.T) {
+		req = newRequest(""GET"", ""/sub/not/found"")
+		router.ServeHTTP(rw, req)
+		if mw.timesCalled != 1 {
+			t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+		}
+	})
 
-	router.useInterface(mw)
+	t.Run(""middleware added to router"", func(t *testing.T) {
+		router.useInterface(mw)
 
-	req = newRequest(""GET"", ""/"")
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 2 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 2, mw.timesCalled)
-	}
+		t.Run(""called once for route outside subrouter"", func(t *testing.T) {
+			req = newRequest(""GET"", ""/"")
+			router.ServeHTTP(rw, req)
+			if mw.timesCalled != 2 {
+				t.Fatalf(""Expected %d calls, but got only %d"", 2, mw.timesCalled)
+			}
+		})
 
-	req = newRequest(""GET"", ""/sub/x"")
-	router.ServeHTTP(rw, req)
-	if mw.timesCalled != 4 {
-		t.Fatalf(""Expected %d calls, but got only %d"", 4, mw.timesCalled)
-	}
+		t.Run(""called twice for route inside subrouter"", func(t *testing.T) {
+			req = newRequest(""GET"", ""/sub/x"")
+			router.ServeHTTP(rw, req)
+			if mw.timesCalled != 4 {
+				t.Fatalf(""Expected %d calls, but got only %d"", 4, mw.timesCalled)
+			}
+		})
+	})
 }
 
 func TestMiddlewareExecution(t *testing.T) {
@@ -145,30 +163,33 @@ func TestMiddlewareExecution(t *testing.T) {
 		w.Write(handlerStr)
 	})
 
-	rw := NewRecorder()
-	req := newRequest(""GET"", ""/"")
+	t.Run(""responds normally without middleware"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/"")
 
-	// Test handler-only call
-	router.ServeHTTP(rw, req)
+		router.ServeHTTP(rw, req)
 
-	if !bytes.Equal(rw.Body.Bytes(), handlerStr) {
-		t.Fatal(""Handler response is not what it should be"")
-	}
+		if !bytes.Equal(rw.Body.Bytes(), handlerStr) {
+			t.Fatal(""Handler response is not what it should be"")
+		}
+	})
 
-	// Test middleware call
-	rw = NewRecorder()
+	t.Run(""responds with handler and middleware response"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/"")
 
-	router.Use(func(h http.Handler) http.Handler {
-		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
-			h.ServeHTTP(w, r)
+		router.Use(func(h http.Handler) http.Handler {
+			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+				w.Write(mwStr)
+				h.ServeHTTP(w, r)
+			})
 		})
-	})
 
-	router.ServeHTTP(rw, req)
-	if !bytes.Equal(rw.Body.Bytes(), append(mwStr, handlerStr...)) {
-		t.Fatal(""Middleware + handler response is not what it should be"")
-	}
+		router.ServeHTTP(rw, req)
+		if !bytes.Equal(rw.Body.Bytes(), append(mwStr, handlerStr...)) {
+			t.Fatal(""Middleware + handler response is not what it should be"")
+		}
+	})
 }
 
 func TestMiddlewareNotFound(t *testing.T) {
@@ -187,26 +208,29 @@ func TestMiddlewareNotFound(t *testing.T) {
 	})
 
 	// Test not found call with default handler
-	rw := NewRecorder()
-	req := newRequest(""GET"", ""/notfound"")
+	t.Run(""not called"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/notfound"")
 
-	router.ServeHTTP(rw, req)
-	if bytes.Contains(rw.Body.Bytes(), mwStr) {
-		t.Fatal(""Middleware was called for a 404"")
-	}
+		router.ServeHTTP(rw, req)
+		if bytes.Contains(rw.Body.Bytes(), mwStr) {
+			t.Fatal(""Middleware was called for a 404"")
+		}
+	})
 
-	// Test not found call with custom handler
-	rw = NewRecorder()
-	req = newRequest(""GET"", ""/notfound"")
+	t.Run(""not called with custom not found handler"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/notfound"")
 
-	router.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(""Custom 404 handler""))
-	})
-	router.ServeHTTP(rw, req)
+		router.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+			rw.Write([]byte(""Custom 404 handler""))
+		})
+		router.ServeHTTP(rw, req)
 
-	if bytes.Contains(rw.Body.Bytes(), mwStr) {
-		t.Fatal(""Middleware was called for a custom 404"")
-	}
+		if bytes.Contains(rw.Body.Bytes(), mwStr) {
+			t.Fatal(""Middleware was called for a custom 404"")
+		}
+	})
 }
 
 func TestMiddlewareMethodMismatch(t *testing.T) {
@@ -225,27 +249,29 @@ func TestMiddlewareMethodMismatch(t *testing.T) {
 		})
 	})
 
-	// Test method mismatch
-	rw := NewRecorder()
-	req := newRequest(""POST"", ""/"")
+	t.Run(""not called"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""POST"", ""/"")
 
-	router.ServeHTTP(rw, req)
-	if bytes.Contains(rw.Body.Bytes(), mwStr) {
-		t.Fatal(""Middleware was called for a method mismatch"")
-	}
+		router.ServeHTTP(rw, req)
+		if bytes.Contains(rw.Body.Bytes(), mwStr) {
+			t.Fatal(""Middleware was called for a method mismatch"")
+		}
+	})
 
-	// Test not found call
-	rw = NewRecorder()
-	req = newRequest(""POST"", ""/"")
+	t.Run(""not called with custom method not allowed handler"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""POST"", ""/"")
 
-	router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(""Method not allowed""))
-	})
-	router.ServeHTTP(rw, req)
+		router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+			rw.Write([]byte(""Method not allowed""))
+		})
+		router.ServeHTTP(rw, req)
 
-	if bytes.Contains(rw.Body.Bytes(), mwStr) {
-		t.Fatal(""Middleware was called for a method mismatch"")
-	}
+		if bytes.Contains(rw.Body.Bytes(), mwStr) {
+			t.Fatal(""Middleware was called for a method mismatch"")
+		}
+	})
 }
 
 func TestMiddlewareNotFoundSubrouter(t *testing.T) {
@@ -269,27 +295,29 @@ func TestMiddlewareNotFoundSubrouter(t *testing.T) {
 		})
 	})
 
-	// Test not found call for default handler
-	rw := NewRecorder()
-	req := newRequest(""GET"", ""/sub/notfound"")
+	t.Run(""not called"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/sub/notfound"")
 
-	router.ServeHTTP(rw, req)
-	if bytes.Contains(rw.Body.Bytes(), mwStr) {
-		t.Fatal(""Middleware was called for a 404"")
-	}
+		router.ServeHTTP(rw, req)
+		if bytes.Contains(rw.Body.Bytes(), mwStr) {
+			t.Fatal(""Middleware was called for a 404"")
+		}
+	})
 
-	// Test not found call with custom handler
-	rw = NewRecorder()
-	req = newRequest(""GET"", ""/sub/notfound"")
+	t.Run(""not called with custom not found handler"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/sub/notfound"")
 
-	subrouter.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(""Custom 404 handler""))
-	})
-	router.ServeHTTP(rw, req)
+		subrouter.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+			rw.Write([]byte(""Custom 404 handler""))
+		})
+		router.ServeHTTP(rw, req)
 
-	if bytes.Contains(rw.Body.Bytes(), mwStr) {
-		t.Fatal(""Middleware was called for a custom 404"")
-	}
+		if bytes.Contains(rw.Body.Bytes(), mwStr) {
+			t.Fatal(""Middleware was called for a custom 404"")
+		}
+	})
 }
 
 func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
@@ -313,27 +341,29 @@ func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
 		})
 	})
 
-	// Test method mismatch without custom handler
-	rw := NewRecorder()
-	req := newRequest(""POST"", ""/sub/"")
+	t.Run(""not called"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""POST"", ""/sub/"")
 
-	router.ServeHTTP(rw, req)
-	if bytes.Contains(rw.Body.Bytes(), mwStr) {
-		t.Fatal(""Middleware was called for a method mismatch"")
-	}
+		router.ServeHTTP(rw, req)
+		if bytes.Contains(rw.Body.Bytes(), mwStr) {
+			t.Fatal(""Middleware was called for a method mismatch"")
+		}
+	})
 
-	// Test method mismatch with custom handler
-	rw = NewRecorder()
-	req = newRequest(""POST"", ""/sub/"")
+	t.Run(""not called with custom method not allowed handler"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""POST"", ""/sub/"")
 
-	router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(""Method not allowed""))
-	})
-	router.ServeHTTP(rw, req)
+		router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+			rw.Write([]byte(""Method not allowed""))
+		})
+		router.ServeHTTP(rw, req)
 
-	if bytes.Contains(rw.Body.Bytes(), mwStr) {
-		t.Fatal(""Middleware was called for a method mismatch"")
-	}
+		if bytes.Contains(rw.Body.Bytes(), mwStr) {
+			t.Fatal(""Middleware was called for a method mismatch"")
+		}
+	})
 }
 
 func TestCORSMethodMiddleware(t *testing.T) {
@@ -358,21 +388,23 @@ func TestCORSMethodMiddleware(t *testing.T) {
 
 	router.Use(CORSMethodMiddleware(router))
 
-	for _, tt := range cases {
-		rr := httptest.NewRecorder()
-		req := newRequest(tt.method, tt.testURL)
+	for i, tt := range cases {
+		t.Run(fmt.Sprintf(""cases[%d]"", i), func(t *testing.T) {
+			rr := httptest.NewRecorder()
+			req := newRequest(tt.method, tt.testURL)
 
-		router.ServeHTTP(rr, req)
+			router.ServeHTTP(rr, req)
 
-		if rr.Body.String() != tt.response {
-			t.Errorf(""Expected body '%s', found '%s'"", tt.response, rr.Body.String())
-		}
+			if rr.Body.String() != tt.response {
+				t.Errorf(""Expected body '%s', found '%s'"", tt.response, rr.Body.String())
+			}
 
-		allowedMethods := rr.Header().Get(""Access-Control-Allow-Methods"")
+			allowedMethods := rr.Header().Get(""Access-Control-Allow-Methods"")
 
-		if allowedMethods != tt.expectedAllowedMethods {
-			t.Errorf(""Expected Access-Control-Allow-Methods '%s', found '%s'"", tt.expectedAllowedMethods, allowedMethods)
-		}
+			if allowedMethods != tt.expectedAllowedMethods {
+				t.Errorf(""Expected Access-Control-Allow-Methods '%s', found '%s'"", tt.expectedAllowedMethods, allowedMethods)
+			}
+		})
 	}
 }
 
@@ -411,27 +443,33 @@ func TestMiddlewareOnMultiSubrouter(t *testing.T) {
 		})
 	})
 
-	rw := NewRecorder()
-	req := newRequest(""GET"", ""/first"")
+	t.Run(""/first uses first middleware"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/first"")
 
-	router.ServeHTTP(rw, req)
-	if rw.Body.String() != first {
-		t.Fatalf(""Middleware did not run: expected %s middleware to write a response (got %s)"", first, rw.Body.String())
-	}
+		router.ServeHTTP(rw, req)
+		if rw.Body.String() != first {
+			t.Fatalf(""Middleware did not run: expected %s middleware to write a response (got %s)"", first, rw.Body.String())
+		}
+	})
 
-	rw = NewRecorder()
-	req = newRequest(""GET"", ""/second"")
+	t.Run(""/second uses second middleware"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/second"")
 
-	router.ServeHTTP(rw, req)
-	if rw.Body.String() != second {
-		t.Fatalf(""Middleware did not run: expected %s middleware to write a response (got %s)"", second, rw.Body.String())
-	}
+		router.ServeHTTP(rw, req)
+		if rw.Body.String() != second {
+			t.Fatalf(""Middleware did not run: expected %s middleware to write a response (got %s)"", second, rw.Body.String())
+		}
+	})
 
-	rw = NewRecorder()
-	req = newRequest(""GET"", ""/second/not-exist"")
+	t.Run(""uses not found handler"", func(t *testing.T) {
+		rw := NewRecorder()
+		req := newRequest(""GET"", ""/second/not-exist"")
 
-	router.ServeHTTP(rw, req)
-	if rw.Body.String() != notFound {
-		t.Fatalf(""Notfound handler did not run: expected %s for not-exist, (got %s)"", notFound, rw.Body.String())
-	}
+		router.ServeHTTP(rw, req)
+		if rw.Body.String() != notFound {
+			t.Fatalf(""Notfound handler did not run: expected %s for not-exist, (got %s)"", notFound, rw.Body.String())
+		}
+	})
 }",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=48f941fa99947e50375f2b0dd4b3b060d15b2fe8,https://github.com/gorilla/mux/blob/48f941fa99947e50375f2b0dd4b3b060d15b2fe8/middleware_test.go
64954673e972292a409b5c8d13b16ed797b905d0,d003ad922f33f1df0d67feb59cdc4bb9f2851a21,.travis.yml,,"Fri, 28 Jun 2019 23:07:30 GMT",removed,0,24,24,"@@ -1,24 +0,0 @@
-language: go
-
-
-matrix:
-  include:
-    - go: 1.7.x
-    - go: 1.8.x
-    - go: 1.9.x
-    - go: 1.10.x
-    - go: 1.11.x
-    - go: 1.x
-      env: LATEST=true
-    - go: tip
-  allow_failures:
-    - go: tip
-
-install:
-  - # Skip
-
-script:
-  - go get -t -v ./...
-  - diff -u <(echo -n) <(gofmt -d .)
-  - if [[ ""$LATEST"" = true ]]; then go vet .; fi
-  - go test -v -race ./...",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=4248f5cd8717eaea35eded08100714b2b2bac756,https://github.com/gorilla/mux/blob/4248f5cd8717eaea35eded08100714b2b2bac756/.travis.yml
4248f5cd8717eaea35eded08100714b2b2bac756,bd5a38b55d82f96fff772c14fa769c142103bdbe,doc.go,,"Fri, 28 Jun 2019 15:33:07 GMT",modified,1,1,2,"@@ -295,7 +295,7 @@ A more complex authentication middleware, which maps session token to users, cou
 	r := mux.NewRouter()
 	r.HandleFunc(""/"", handler)
 
-	amw := authenticationMiddleware{}
+	amw := authenticationMiddleware{tokenUsers: make(map[string]string)}
 	amw.Populate()
 
 	r.Use(amw.Middleware)",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=4248f5cd8717eaea35eded08100714b2b2bac756,https://github.com/gorilla/mux/blob/4248f5cd8717eaea35eded08100714b2b2bac756/doc.go
212aa90d7cec051ab29930d5c56f758f6f69a789,c0fb9de31d007d919b92cb33b1d58141e2e67c5b,.circleci/config.yml,,"Mon, 24 Jun 2019 16:05:39 GMT",added,63,0,63,"@@ -0,0 +1,63 @@
+version: 2.0
+
+jobs:
+  # Base test configuration for Go library tests Each distinct version should
+  # inherit this base, and override (at least) the container image used.
+  ""test"": &test
+    docker:
+      - image: circleci/golang:latest
+    working_directory: /go/src/github.com/gorilla/mux
+    steps: &steps
+      - checkout
+      - run: go version
+      - run: go get -t -v ./...
+      - run: diff -u <(echo -n) <(gofmt -d .)
+      - run: if [[ ""$LATEST"" = true ]]; then go vet -v .; fi
+      - run: go test -v -race ./...
+
+  ""latest"":
+    <<: *test
+    environment:
+      LATEST: true
+
+  ""1.12"":
+    <<: *test
+    docker:
+      - image: circleci/golang:1.12
+
+  ""1.11"":
+    <<: *test
+    docker:
+      - image: circleci/golang:1.11
+
+  ""1.10"":
+    <<: *test
+    docker:
+      - image: circleci/golang:1.10
+
+  ""1.9"":
+    <<: *test
+    docker:
+      - image: circleci/golang:1.9
+
+  ""1.8"":
+    <<: *test
+    docker:
+      - image: circleci/golang:1.8
+
+  ""1.7"":
+    <<: *test
+    docker:
+      - image: circleci/golang:1.7
+
+workflows:
+  version: 2
+  build:
+    jobs:
+      - ""latest""
+      - ""1.12""
+      - ""1.11""
+      - ""1.10""
+      - ""1.9""
+      - ""1.8""
+      - ""1.7""",https://api.github.com/repos/gorilla/mux/contents/.circleci%2Fconfig.yml?ref=212aa90d7cec051ab29930d5c56f758f6f69a789,https://github.com/gorilla/mux/blob/212aa90d7cec051ab29930d5c56f758f6f69a789/.circleci%2Fconfig.yml
212aa90d7cec051ab29930d5c56f758f6f69a789,08f63a101ebbf95fb35d188af062aeb895ebeecc,README.md,,"Mon, 24 Jun 2019 16:05:39 GMT",modified,1,0,1,"@@ -2,6 +2,7 @@
 
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
+[![CircleCI](https://circleci.com/gh/gorilla/mux.svg?style=svg)](https://circleci.com/gh/gorilla/mux)
 [![Sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
 
 ![Gorilla Logo](http://www.gorillatoolkit.org/static/images/gorilla-icon-64.png)",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=212aa90d7cec051ab29930d5c56f758f6f69a789,https://github.com/gorilla/mux/blob/212aa90d7cec051ab29930d5c56f758f6f69a789/README.md
ed099d42384823742bba0bf9a72b53b55c9e2e38,ac1abcd473e3224bf5117b692ec09792e7ceedb4,regexp.go,,"Fri, 17 May 2019 00:20:44 GMT",modified,27,10,37,"@@ -113,6 +113,13 @@ func newRouteRegexp(tpl string, typ regexpType, options routeRegexpOptions) (*ro
 	if typ != regexpTypePrefix {
 		pattern.WriteByte('$')
 	}
+
+	var wildcardHostPort bool
+	if typ == regexpTypeHost {
+		if !strings.Contains(pattern.String(), "":"") {
+			wildcardHostPort = true
+		}
+	}
 	reverse.WriteString(raw)
 	if endSlash {
 		reverse.WriteByte('/')
@@ -131,13 +138,14 @@ func newRouteRegexp(tpl string, typ regexpType, options routeRegexpOptions) (*ro
 
 	// Done!
 	return &routeRegexp{
-		template:   template,
-		regexpType: typ,
-		options:    options,
-		regexp:     reg,
-		reverse:    reverse.String(),
-		varsN:      varsN,
-		varsR:      varsR,
+		template:         template,
+		regexpType:       typ,
+		options:          options,
+		regexp:           reg,
+		reverse:          reverse.String(),
+		varsN:            varsN,
+		varsR:            varsR,
+		wildcardHostPort: wildcardHostPort,
 	}, nil
 }
 
@@ -158,11 +166,22 @@ type routeRegexp struct {
 	varsN []string
 	// Variable regexps (validators).
 	varsR []*regexp.Regexp
+	// Wildcard host-port (no strict port match in hostname)
+	wildcardHostPort bool
 }
 
 // Match matches the regexp against the URL host or path.
 func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
-	if r.regexpType != regexpTypeHost {
+	if r.regexpType == regexpTypeHost {
+		host := getHost(req)
+		if r.wildcardHostPort {
+			// Don't be strict on the port match
+			if i := strings.Index(host, "":""); i != -1 {
+				host = host[:i]
+			}
+		}
+		return r.regexp.MatchString(host)
+	} else {
 		if r.regexpType == regexpTypeQuery {
 			return r.matchQueryString(req)
 		}
@@ -172,8 +191,6 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 		}
 		return r.regexp.MatchString(path)
 	}
-
-	return r.regexp.MatchString(getHost(req))
 }
 
 // url builds a URL part using the given values.",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=ed099d42384823742bba0bf9a72b53b55c9e2e38,https://github.com/gorilla/mux/blob/ed099d42384823742bba0bf9a72b53b55c9e2e38/regexp.go
c5c6c98bc25355028a63748a498942a6398ccd22,d003ad922f33f1df0d67feb59cdc4bb9f2851a21,.travis.yml,,"Sat, 16 Mar 2019 13:32:43 GMT",modified,1,1,2,"@@ -1,5 +1,5 @@
 language: go
-sudo: false
+
 
 matrix:
   include:",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=c5c6c98bc25355028a63748a498942a6398ccd22,https://github.com/gorilla/mux/blob/c5c6c98bc25355028a63748a498942a6398ccd22/.travis.yml
15a353a636720571d19e37b34a14499c3afa9991,a2cd193e4870256ae36709056aeb70aa410b7990,mux.go,,"Thu, 28 Feb 2019 18:12:03 GMT",modified,6,0,6,"@@ -283,6 +283,12 @@ func (r *Router) NewRoute() *Route {
 	return route
 }
 
+// Name registers a new route with a name.
+// See Route.Name().
+func (r *Router) Name(name string) *Route {
+	return r.NewRoute().Name(name)
+}
+
 // Handle registers a new route with a matcher for the URL path.
 // See Route.Path() and Route.Handler().
 func (r *Router) Handle(path string, handler http.Handler) *Route {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=15a353a636720571d19e37b34a14499c3afa9991,https://github.com/gorilla/mux/blob/15a353a636720571d19e37b34a14499c3afa9991/mux.go
15a353a636720571d19e37b34a14499c3afa9991,f5c1e9c5bc7b4d8eebe528430e02d62bf615314b,mux_test.go,,"Thu, 28 Feb 2019 18:12:03 GMT",modified,4,3,7,"@@ -1441,10 +1441,11 @@ func TestNamedRoutes(t *testing.T) {
 	r3.NewRoute().Name(""g"")
 	r3.NewRoute().Name(""h"")
 	r3.NewRoute().Name(""i"")
+	r3.Name(""j"")
 
-	if r1.namedRoutes == nil || len(r1.namedRoutes) != 9 {
-		t.Errorf(""Expected 9 named routes, got %v"", r1.namedRoutes)
-	} else if r1.Get(""i"") == nil {
+	if r1.namedRoutes == nil || len(r1.namedRoutes) != 10 {
+		t.Errorf(""Expected 10 named routes, got %v"", r1.namedRoutes)
+	} else if r1.Get(""j"") == nil {
 		t.Errorf(""Subroute name not registered"")
 	}
 }",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=15a353a636720571d19e37b34a14499c3afa9991,https://github.com/gorilla/mux/blob/15a353a636720571d19e37b34a14499c3afa9991/mux_test.go
8eaa9f13091105874ef3e20c65922e382cef3c64,a34d6c4910dc0b9571e4a473e01c37cf782c354e,.travis.yml,,"Thu, 28 Feb 2019 17:36:07 GMT",modified,1,1,2,"@@ -20,5 +20,5 @@ install:
 script:
   - go get -t -v ./...
   - diff -u <(echo -n) <(gofmt -d .)
-  - if [[ ""$LATEST"" = true ]]; then go tool vet .; fi
+  - if [[ ""$LATEST"" = true ]]; then go vet .; fi
   - go test -v -race ./...",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=8eaa9f13091105874ef3e20c65922e382cef3c64,https://github.com/gorilla/mux/blob/8eaa9f13091105874ef3e20c65922e382cef3c64/.travis.yml
8559a4f775fc329165fe32bd4c2543de8ada8fce,8479c68c1df7e866c42981389c610b488a179041,route.go,,"Sun, 17 Feb 2019 15:38:49 GMT",modified,1,1,2,"@@ -383,7 +383,7 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // The above route will only match if the URL contains the defined queries
 // values, e.g.: ?foo=bar&id=42.
 //
-// It the value is an empty string, it will match any value if the key is set.
+// If the value is an empty string, it will match any value if the key is set.
 //
 // Variables can define an optional regexp pattern to be matched:
 //",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=8559a4f775fc329165fe32bd4c2543de8ada8fce,https://github.com/gorilla/mux/blob/8559a4f775fc329165fe32bd4c2543de8ada8fce/route.go
a7962380ca08b5a188038c69871b8d3fbdf31e89,24016cbb7d99562ed4027a4c401d0f1f2f66e5ac,middleware_test.go,,"Fri, 25 Jan 2019 16:05:53 GMT",modified,3,3,6,"@@ -151,7 +151,7 @@ func TestMiddlewareExecution(t *testing.T) {
 	// Test handler-only call
 	router.ServeHTTP(rw, req)
 
-	if bytes.Compare(rw.Body.Bytes(), handlerStr) != 0 {
+	if !bytes.Equal(rw.Body.Bytes(), handlerStr) {
 		t.Fatal(""Handler response is not what it should be"")
 	}
 
@@ -166,7 +166,7 @@ func TestMiddlewareExecution(t *testing.T) {
 	})
 
 	router.ServeHTTP(rw, req)
-	if bytes.Compare(rw.Body.Bytes(), append(mwStr, handlerStr...)) != 0 {
+	if !bytes.Equal(rw.Body.Bytes(), append(mwStr, handlerStr...)) {
 		t.Fatal(""Middleware + handler response is not what it should be"")
 	}
 }
@@ -368,7 +368,7 @@ func TestCORSMethodMiddleware(t *testing.T) {
 			t.Errorf(""Expected body '%s', found '%s'"", tt.response, rr.Body.String())
 		}
 
-		allowedMethods := rr.HeaderMap.Get(""Access-Control-Allow-Methods"")
+		allowedMethods := rr.Header().Get(""Access-Control-Allow-Methods"")
 
 		if allowedMethods != tt.expectedAllowedMethods {
 			t.Errorf(""Expected Access-Control-Allow-Methods '%s', found '%s'"", tt.expectedAllowedMethods, allowedMethods)",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=a7962380ca08b5a188038c69871b8d3fbdf31e89,https://github.com/gorilla/mux/blob/a7962380ca08b5a188038c69871b8d3fbdf31e89/middleware_test.go
a7962380ca08b5a188038c69871b8d3fbdf31e89,61653d7fc27e459ca21277e53acf6f0d7f43a804,mux_test.go,,"Fri, 25 Jan 2019 16:05:53 GMT",modified,1,4,5,"@@ -1123,10 +1123,7 @@ func TestSchemes(t *testing.T) {
 
 func TestMatcherFunc(t *testing.T) {
 	m := func(r *http.Request, m *RouteMatch) bool {
-		if r.URL.Host == ""aaa.bbb.ccc"" {
-			return true
-		}
-		return false
+		return r.URL.Host == ""aaa.bbb.ccc""
 	}
 
 	tests := []routeTest{",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a7962380ca08b5a188038c69871b8d3fbdf31e89,https://github.com/gorilla/mux/blob/a7962380ca08b5a188038c69871b8d3fbdf31e89/mux_test.go
797e653da60e4619dcb0ae703714147b5a7454c6,c661599ab21ffd6353680587b77ff73328e624b6,README.md,,"Fri, 25 Jan 2019 11:41:49 GMT",modified,1,1,2,"@@ -503,8 +503,8 @@ package main
 
 func HealthCheckHandler(w http.ResponseWriter, r *http.Request) {
     // A very simple health check.
-    w.WriteHeader(http.StatusOK)
     w.Header().Set(""Content-Type"", ""application/json"")
+    w.WriteHeader(http.StatusOK)
 
     // In the future we could report back on the status of our DB, or our cache
     // (e.g. Redis) by performing a simple PING, and include them in the response.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=797e653da60e4619dcb0ae703714147b5a7454c6,https://github.com/gorilla/mux/blob/797e653da60e4619dcb0ae703714147b5a7454c6/README.md
08e7f807d38d6a870193019bb439056118661505,5198024d01c3316f7612023aa438dbf3548f211c,mux_test.go,,"Tue, 08 Jan 2019 14:29:30 GMT",modified,32,0,32,"@@ -2715,6 +2715,38 @@ func Test_copyRouteConf(t *testing.T) {
 	}
 }
 
+func TestMethodNotAllowed(t *testing.T) {
+	handler := func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }
+	router := NewRouter()
+	router.HandleFunc(""/thing"", handler).Methods(http.MethodGet)
+	router.HandleFunc(""/something"", handler).Methods(http.MethodGet)
+
+	w := NewRecorder()
+	req := newRequest(http.MethodPut, ""/thing"")
+
+	router.ServeHTTP(w, req)
+
+	if w.Code != 405 {
+		t.Fatalf(""Expected status code 405 (got %d)"", w.Code)
+	}
+}
+
+func TestSubrouterNotFound(t *testing.T) {
+	handler := func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }
+	router := NewRouter()
+	router.Path(""/a"").Subrouter().HandleFunc(""/thing"", handler).Methods(http.MethodGet)
+	router.Path(""/b"").Subrouter().HandleFunc(""/something"", handler).Methods(http.MethodGet)
+
+	w := NewRecorder()
+	req := newRequest(http.MethodPut, ""/not-present"")
+
+	router.ServeHTTP(w, req)
+
+	if w.Code != 404 {
+		t.Fatalf(""Expected status code 404 (got %d)"", w.Code)
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=08e7f807d38d6a870193019bb439056118661505,https://github.com/gorilla/mux/blob/08e7f807d38d6a870193019bb439056118661505/mux_test.go
08e7f807d38d6a870193019bb439056118661505,16a7cdf4eadc120fcf92a86cb3c623c6785aa516,route.go,,"Tue, 08 Jan 2019 14:29:30 GMT",modified,12,5,17,"@@ -43,11 +43,6 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 		return false
 	}
 
-	// Set MatchErr to nil to prevent
-	// subsequent matching subrouters from failing to run middleware.
-	// If not reset, the middleware would see a non-nil MatchErr and be skipped,
-	// even when there was a matching route.
-	match.MatchErr = nil
 	var matchErr error
 
 	// Match everything.
@@ -57,6 +52,18 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 				matchErr = ErrMethodMismatch
 				continue
 			}
+
+			// Ignore ErrNotFound errors. These errors arise from match call
+			// to Subrouters.
+			//
+			// This prevents subsequent matching subrouters from failing to
+			// run middleware. If not ignored, the middleware would see a
+			// non-nil MatchErr and be skipped, even when there was a
+			// matching route.
+			if match.MatchErr == ErrNotFound {
+				match.MatchErr = nil
+			}
+
 			matchErr = nil
 			return false
 		}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=08e7f807d38d6a870193019bb439056118661505,https://github.com/gorilla/mux/blob/08e7f807d38d6a870193019bb439056118661505/route.go
f3ff42f93a451d7ffb2ff11cb9485f3f88089c83,8ad57ac8226c1067ff5d5c17dd1c3b8894da5585,mux_test.go,,"Fri, 04 Jan 2019 15:08:45 GMT",modified,19,1,20,"@@ -104,7 +104,15 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
-		// BUG {new(Route).Host(""aaa.bbb.ccc:1234""), newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""), map[string]string{}, ""aaa.bbb.ccc:1234"", """", true},
+		{
+			title:       ""Host route with port, match with request header"",
+			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
+			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc:1234"",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Host route with port, wrong host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
@@ -114,6 +122,16 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:        ""Host route with pattern, match with request header"",
+			route:        new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc:1{v2:(?:23|4)}""),
+			request:      newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:123""),
+			vars:         map[string]string{""v1"": ""bbb"", ""v2"": ""23""},
+			host:         ""aaa.bbb.ccc:123"",
+			path:         """",
+			hostTemplate: `aaa.{v1:[a-z]{3}}.ccc:1{v2:(?:23|4)}`,
+			shouldMatch:  true,
+		},
 		{
 			title:        ""Host route with pattern, match"",
 			route:        new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=f3ff42f93a451d7ffb2ff11cb9485f3f88089c83,https://github.com/gorilla/mux/blob/f3ff42f93a451d7ffb2ff11cb9485f3f88089c83/mux_test.go
f3ff42f93a451d7ffb2ff11cb9485f3f88089c83,f2528867563326c9be9f8261e220e37a66f5eb03,regexp.go,,"Fri, 04 Jan 2019 15:08:45 GMT",modified,3,7,10,"@@ -312,17 +312,13 @@ func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 }
 
 // getHost tries its best to return the request host.
+// According to section 14.23 of RFC 2616 the Host header
+// can include the port number if the default value of 80 is not used.
 func getHost(r *http.Request) string {
 	if r.URL.IsAbs() {
 		return r.URL.Host
 	}
-	host := r.Host
-	// Slice off any port information.
-	if i := strings.Index(host, "":""); i != -1 {
-		host = host[:i]
-	}
-	return host
-
+	return r.Host
 }
 
 func extractVars(input string, matches []int, names []string, output map[string]string) {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=f3ff42f93a451d7ffb2ff11cb9485f3f88089c83,https://github.com/gorilla/mux/blob/f3ff42f93a451d7ffb2ff11cb9485f3f88089c83/regexp.go
ef912dd76ebe9d9848c6e0fd80eaebccc9a11631,b708be0991ac788493db0097f398a18f39805530,middleware_test.go,,"Fri, 28 Dec 2018 00:42:16 GMT",modified,60,0,60,"@@ -375,3 +375,63 @@ func TestCORSMethodMiddleware(t *testing.T) {
 		}
 	}
 }
+
+func TestMiddlewareOnMultiSubrouter(t *testing.T) {
+	first := ""first""
+	second := ""second""
+	notFound := ""404 not found""
+
+	router := NewRouter()
+	firstSubRouter := router.PathPrefix(""/"").Subrouter()
+	secondSubRouter := router.PathPrefix(""/"").Subrouter()
+
+	router.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+		rw.Write([]byte(notFound))
+	})
+
+	firstSubRouter.HandleFunc(""/first"", func(w http.ResponseWriter, r *http.Request) {
+
+	})
+
+	secondSubRouter.HandleFunc(""/second"", func(w http.ResponseWriter, r *http.Request) {
+
+	})
+
+	firstSubRouter.Use(func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			w.Write([]byte(first))
+			h.ServeHTTP(w, r)
+		})
+	})
+
+	secondSubRouter.Use(func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			w.Write([]byte(second))
+			h.ServeHTTP(w, r)
+		})
+	})
+
+	rw := NewRecorder()
+	req := newRequest(""GET"", ""/first"")
+
+	router.ServeHTTP(rw, req)
+	if rw.Body.String() != first {
+		t.Fatalf(""Middleware did not run: expected %s middleware to write a response (got %s)"", first, rw.Body.String())
+	}
+
+	rw = NewRecorder()
+	req = newRequest(""GET"", ""/second"")
+
+	router.ServeHTTP(rw, req)
+	if rw.Body.String() != second {
+		t.Fatalf(""Middleware did not run: expected %s middleware to write a response (got %s)"", second, rw.Body.String())
+	}
+
+	rw = NewRecorder()
+	req = newRequest(""GET"", ""/second/not-exist"")
+
+	router.ServeHTTP(rw, req)
+	if rw.Body.String() != notFound {
+		t.Fatalf(""Notfound handler did not run: expected %s for not-exist, (got %s)"", notFound, rw.Body.String())
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=ef912dd76ebe9d9848c6e0fd80eaebccc9a11631,https://github.com/gorilla/mux/blob/ef912dd76ebe9d9848c6e0fd80eaebccc9a11631/middleware_test.go
ef912dd76ebe9d9848c6e0fd80eaebccc9a11631,a1970966c914859844c028539847a4e8136ce5a1,route.go,,"Fri, 28 Dec 2018 00:42:16 GMT",modified,5,0,5,"@@ -43,6 +43,11 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 		return false
 	}
 
+	// Set MatchErr to nil to prevent
+	// subsequent matching subrouters from failing to run middleware.
+	// If not reset, the middleware would see a non-nil MatchErr and be skipped,
+	// even when there was a matching route.
+	match.MatchErr = nil
 	var matchErr error
 
 	// Match everything.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=ef912dd76ebe9d9848c6e0fd80eaebccc9a11631,https://github.com/gorilla/mux/blob/ef912dd76ebe9d9848c6e0fd80eaebccc9a11631/route.go
a31c1782bfb10b7b3799d5ec06b5ccbd98c4ec7e,9e99a2703c8930790f6871bfc48f2cd99c1c461e,README.md,,"Tue, 25 Dec 2018 16:41:17 GMT",modified,6,6,12,"@@ -88,7 +88,7 @@ r := mux.NewRouter()
 // Only matches if domain is ""www.example.com"".
 r.Host(""www.example.com"")
 // Matches a dynamic subdomain.
-r.Host(""{subdomain:[a-z]+}.domain.com"")
+r.Host(""{subdomain:[a-z]+}.example.com"")
 ```
 
 There are several other matchers that can be added. To match path prefixes:
@@ -238,13 +238,13 @@ This also works for host and query value variables:
 
 ```go
 r := mux.NewRouter()
-r.Host(""{subdomain}.domain.com"").
+r.Host(""{subdomain}.example.com"").
   Path(""/articles/{category}/{id:[0-9]+}"").
   Queries(""filter"", ""{filter}"").
   HandlerFunc(ArticleHandler).
   Name(""article"")
 
-// url.String() will be ""http://news.domain.com/articles/technology/42?filter=gorilla""
+// url.String() will be ""http://news.example.com/articles/technology/42?filter=gorilla""
 url, err := r.Get(""article"").URL(""subdomain"", ""news"",
                                  ""category"", ""technology"",
                                  ""id"", ""42"",
@@ -264,7 +264,7 @@ r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
 There's also a way to build only the URL host or path for a route: use the methods `URLHost()` or `URLPath()` instead. For the previous route, we would do:
 
 ```go
-// ""http://news.domain.com/""
+// ""http://news.example.com/""
 host, err := r.Get(""article"").URLHost(""subdomain"", ""news"")
 
 // ""/articles/technology/42""
@@ -275,12 +275,12 @@ And if you use subrouters, host and path defined separately can be built as well
 
 ```go
 r := mux.NewRouter()
-s := r.Host(""{subdomain}.domain.com"").Subrouter()
+s := r.Host(""{subdomain}.example.com"").Subrouter()
 s.Path(""/articles/{category}/{id:[0-9]+}"").
   HandlerFunc(ArticleHandler).
   Name(""article"")
 
-// ""http://news.domain.com/articles/technology/42""
+// ""http://news.example.com/articles/technology/42""
 url, err := r.Get(""article"").URL(""subdomain"", ""news"",
                                  ""category"", ""technology"",
                                  ""id"", ""42"")",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=a31c1782bfb10b7b3799d5ec06b5ccbd98c4ec7e,https://github.com/gorilla/mux/blob/a31c1782bfb10b7b3799d5ec06b5ccbd98c4ec7e/README.md
6137e193cdcba2725f16de84eaf0db2b769d9668,665940a2682ec86e06822ab1fba0db9a7eb77a61,context.go,,"Mon, 17 Dec 2018 14:42:43 GMT",modified,0,4,4,"@@ -16,7 +16,3 @@ func contextSet(r *http.Request, key, val interface{}) *http.Request {
 
 	return r.WithContext(context.WithValue(r.Context(), key, val))
 }
-
-func contextClear(r *http.Request) {
-	return
-}",https://api.github.com/repos/gorilla/mux/contents/context.go?ref=6137e193cdcba2725f16de84eaf0db2b769d9668,https://github.com/gorilla/mux/blob/6137e193cdcba2725f16de84eaf0db2b769d9668/context.go
6137e193cdcba2725f16de84eaf0db2b769d9668,8aca972d2f6187d95e4726eaee631384ffec240f,mux.go,,"Mon, 17 Dec 2018 14:42:43 GMT",modified,3,6,9,"@@ -22,7 +22,7 @@ var (
 
 // NewRouter returns a new router instance.
 func NewRouter() *Router {
-	return &Router{namedRoutes: make(map[string]*Route), KeepContext: false}
+	return &Router{namedRoutes: make(map[string]*Route)}
 }
 
 // Router registers routes to be matched and dispatches a handler.
@@ -57,7 +57,8 @@ type Router struct {
 	namedRoutes map[string]*Route
 
 	// If true, do not clear the request context after handling the request.
-	// This has no effect when go1.7+ is used, since the context is stored
+	//
+	// Deprecated: No effect when go1.7+ is used, since the context is stored
 	// on the request itself.
 	KeepContext bool
 
@@ -208,10 +209,6 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		handler = http.NotFoundHandler()
 	}
 
-	if !r.KeepContext {
-		defer contextClear(req)
-	}
-
 	handler.ServeHTTP(w, req)
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=6137e193cdcba2725f16de84eaf0db2b769d9668,https://github.com/gorilla/mux/blob/6137e193cdcba2725f16de84eaf0db2b769d9668/mux.go
d2b5d13b9260193b5a5649e9f47fda645bd2bd1d,de8a67804bf3b119c5d4926d2acddd958ae0b5cd,.github/stale.yml,.github/stale,"Sat, 08 Dec 2018 20:40:53 GMT",renamed,1,0,1,"@@ -4,6 +4,7 @@ daysUntilClose: 7
 exemptLabels:
   - v2
   - needs-review
+  - work-required
 staleLabel: stale
 markComment: >
   This issue has been automatically marked as stale because it hasn't seen",https://api.github.com/repos/gorilla/mux/contents/.github%2Fstale.yml?ref=d2b5d13b9260193b5a5649e9f47fda645bd2bd1d,https://github.com/gorilla/mux/blob/d2b5d13b9260193b5a5649e9f47fda645bd2bd1d/.github%2Fstale.yml
419fd9fe2a07c30b927f0183d6a99408d187b812,f5c1622a9bec02caa74a86700cc37798e5abd2f8,.github/stale,,"Fri, 07 Dec 2018 16:41:48 GMT",added,11,0,11,"@@ -0,0 +1,11 @@
+daysUntilStale: 60
+daysUntilClose: 7
+# Issues with these labels will never be considered stale
+exemptLabels:
+  - v2
+  - needs-review
+staleLabel: stale
+markComment: >
+  This issue has been automatically marked as stale because it hasn't seen
+  a recent update. It'll be automatically closed in a few days.
+closeComment: false",https://api.github.com/repos/gorilla/mux/contents/.github%2Fstale?ref=419fd9fe2a07c30b927f0183d6a99408d187b812,https://github.com/gorilla/mux/blob/419fd9fe2a07c30b927f0183d6a99408d187b812/.github%2Fstale
758eb64354aa27cda6c1b026822c788cc755f06f,50ac1184461d348d1518c2982b0ad7b373b39214,mux.go,,"Fri, 07 Dec 2018 15:48:26 GMT",modified,65,49,114,"@@ -50,24 +50,77 @@ type Router struct {
 	// Configurable Handler to be used when the request method does not match the route.
 	MethodNotAllowedHandler http.Handler
 
-	// Parent route, if this is a subrouter.
-	parent parentRoute
 	// Routes to be matched, in order.
 	routes []*Route
+
 	// Routes by name for URL building.
 	namedRoutes map[string]*Route
-	// See Router.StrictSlash(). This defines the flag for new routes.
-	strictSlash bool
-	// See Router.SkipClean(). This defines the flag for new routes.
-	skipClean bool
+
 	// If true, do not clear the request context after handling the request.
 	// This has no effect when go1.7+ is used, since the context is stored
 	// on the request itself.
 	KeepContext bool
-	// see Router.UseEncodedPath(). This defines a flag for all routes.
-	useEncodedPath bool
+
 	// Slice of middlewares to be called after a match is found
 	middlewares []middleware
+
+	// configuration shared with `Route`
+	routeConf
+}
+
+// common route configuration shared between `Router` and `Route`
+type routeConf struct {
+	// If true, ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to""
+	useEncodedPath bool
+
+	// If true, when the path pattern is ""/path/"", accessing ""/path"" will
+	// redirect to the former and vice versa.
+	strictSlash bool
+
+	// If true, when the path pattern is ""/path//to"", accessing ""/path//to""
+	// will not redirect
+	skipClean bool
+
+	// Manager for the variables from host and path.
+	regexp routeRegexpGroup
+
+	// List of matchers.
+	matchers []matcher
+
+	// The scheme used when building URLs.
+	buildScheme string
+
+	buildVarsFunc BuildVarsFunc
+}
+
+// returns an effective deep copy of `routeConf`
+func copyRouteConf(r routeConf) routeConf {
+	c := r
+
+	if r.regexp.path != nil {
+		c.regexp.path = copyRouteRegexp(r.regexp.path)
+	}
+
+	if r.regexp.host != nil {
+		c.regexp.host = copyRouteRegexp(r.regexp.host)
+	}
+
+	c.regexp.queries = make([]*routeRegexp, 0, len(r.regexp.queries))
+	for _, q := range r.regexp.queries {
+		c.regexp.queries = append(c.regexp.queries, copyRouteRegexp(q))
+	}
+
+	c.matchers = make([]matcher, 0, len(r.matchers))
+	for _, m := range r.matchers {
+		c.matchers = append(c.matchers, m)
+	}
+
+	return c
+}
+
+func copyRouteRegexp(r *routeRegexp) *routeRegexp {
+	c := *r
+	return &c
 }
 
 // Match attempts to match the given request against the router's registered routes.
@@ -164,13 +217,13 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 
 // Get returns a route registered with the given name.
 func (r *Router) Get(name string) *Route {
-	return r.getNamedRoutes()[name]
+	return r.namedRoutes[name]
 }
 
 // GetRoute returns a route registered with the given name. This method
 // was renamed to Get() and remains here for backwards compatibility.
 func (r *Router) GetRoute(name string) *Route {
-	return r.getNamedRoutes()[name]
+	return r.namedRoutes[name]
 }
 
 // StrictSlash defines the trailing slash behavior for new routes. The initial
@@ -221,51 +274,14 @@ func (r *Router) UseEncodedPath() *Router {
 	return r
 }
 
-// ----------------------------------------------------------------------------
-// parentRoute
-// ----------------------------------------------------------------------------
-
-func (r *Router) getBuildScheme() string {
-	if r.parent != nil {
-		return r.parent.getBuildScheme()
-	}
-	return """"
-}
-
-// getNamedRoutes returns the map where named routes are registered.
-func (r *Router) getNamedRoutes() map[string]*Route {
-	if r.namedRoutes == nil {
-		if r.parent != nil {
-			r.namedRoutes = r.parent.getNamedRoutes()
-		} else {
-			r.namedRoutes = make(map[string]*Route)
-		}
-	}
-	return r.namedRoutes
-}
-
-// getRegexpGroup returns regexp definitions from the parent route, if any.
-func (r *Router) getRegexpGroup() *routeRegexpGroup {
-	if r.parent != nil {
-		return r.parent.getRegexpGroup()
-	}
-	return nil
-}
-
-func (r *Router) buildVars(m map[string]string) map[string]string {
-	if r.parent != nil {
-		m = r.parent.buildVars(m)
-	}
-	return m
-}
-
 // ----------------------------------------------------------------------------
 // Route factories
 // ----------------------------------------------------------------------------
 
 // NewRoute registers an empty route.
 func (r *Router) NewRoute() *Route {
-	route := &Route{parent: r, strictSlash: r.strictSlash, skipClean: r.skipClean, useEncodedPath: r.useEncodedPath}
+	// initialize a route with a copy of the parent router's configuration
+	route := &Route{routeConf: copyRouteConf(r.routeConf), namedRoutes: r.namedRoutes}
 	r.routes = append(r.routes, route)
 	return route
 }",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=758eb64354aa27cda6c1b026822c788cc755f06f,https://github.com/gorilla/mux/blob/758eb64354aa27cda6c1b026822c788cc755f06f/mux.go
758eb64354aa27cda6c1b026822c788cc755f06f,519aa92ce856cd7e2c781e4a01e70ab88a46ed20,mux_test.go,,"Fri, 07 Dec 2018 15:48:26 GMT",modified,415,25,440,"@@ -48,15 +48,6 @@ type routeTest struct {
 }
 
 func TestHost(t *testing.T) {
-	// newRequestHost a new request with a method, url, and host header
-	newRequestHost := func(method, url, host string) *http.Request {
-		req, err := http.NewRequest(method, url, nil)
-		if err != nil {
-			panic(err)
-		}
-		req.Host = host
-		return req
-	}
 
 	tests := []routeTest{
 		{
@@ -1193,7 +1184,6 @@ func TestSubRouter(t *testing.T) {
 	subrouter3 := new(Route).PathPrefix(""/foo"").Subrouter()
 	subrouter4 := new(Route).PathPrefix(""/foo/bar"").Subrouter()
 	subrouter5 := new(Route).PathPrefix(""/{category}"").Subrouter()
-
 	tests := []routeTest{
 		{
 			route:        subrouter1.Path(""/{v2:[a-z]+}""),
@@ -1288,6 +1278,106 @@ func TestSubRouter(t *testing.T) {
 			pathTemplate: `/{category}`,
 			shouldMatch:  true,
 		},
+		{
+			title:        ""Mismatch method specified on parent route"",
+			route:        new(Route).Methods(""POST"").PathPrefix(""/foo"").Subrouter().Path(""/""),
+			request:      newRequest(""GET"", ""http://localhost/foo/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo/"",
+			pathTemplate: `/foo/`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Match method specified on parent route"",
+			route:        new(Route).Methods(""POST"").PathPrefix(""/foo"").Subrouter().Path(""/""),
+			request:      newRequest(""POST"", ""http://localhost/foo/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo/"",
+			pathTemplate: `/foo/`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Mismatch scheme specified on parent route"",
+			route:        new(Route).Schemes(""https"").Subrouter().PathPrefix(""/""),
+			request:      newRequest(""GET"", ""http://localhost/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Match scheme specified on parent route"",
+			route:        new(Route).Schemes(""http"").Subrouter().PathPrefix(""/""),
+			request:      newRequest(""GET"", ""http://localhost/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""No match header specified on parent route"",
+			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
+			request:      newRequest(""GET"", ""http://localhost/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Header mismatch value specified on parent route"",
+			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
+			request:      newRequestWithHeaders(""GET"", ""http://localhost/"", ""X-Forwarded-Proto"", ""http""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Header match value specified on parent route"",
+			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
+			request:      newRequestWithHeaders(""GET"", ""http://localhost/"", ""X-Forwarded-Proto"", ""https""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Query specified on parent route not present"",
+			route:        new(Route).Headers(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
+			request:      newRequest(""GET"", ""http://localhost/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Query mismatch value specified on parent route"",
+			route:        new(Route).Queries(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
+			request:      newRequest(""GET"", ""http://localhost/?key=notfoobar""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Query match value specified on subroute"",
+			route:        new(Route).Queries(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
+			request:      newRequest(""GET"", ""http://localhost/?key=foobar""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  true,
+		},
 		{
 			title:        ""Build with scheme on parent router"",
 			route:        new(Route).Schemes(""ftp"").Host(""google.com"").Subrouter().Path(""/""),
@@ -1512,25 +1602,29 @@ func TestWalkSingleDepth(t *testing.T) {
 func TestWalkNested(t *testing.T) {
 	router := NewRouter()
 
-	g := router.Path(""/g"").Subrouter()
-	o := g.PathPrefix(""/o"").Subrouter()
-	r := o.PathPrefix(""/r"").Subrouter()
-	i := r.PathPrefix(""/i"").Subrouter()
-	l1 := i.PathPrefix(""/l"").Subrouter()
-	l2 := l1.PathPrefix(""/l"").Subrouter()
+	routeSubrouter := func(r *Route) (*Route, *Router) {
+		return r, r.Subrouter()
+	}
+
+	gRoute, g := routeSubrouter(router.Path(""/g""))
+	oRoute, o := routeSubrouter(g.PathPrefix(""/o""))
+	rRoute, r := routeSubrouter(o.PathPrefix(""/r""))
+	iRoute, i := routeSubrouter(r.PathPrefix(""/i""))
+	l1Route, l1 := routeSubrouter(i.PathPrefix(""/l""))
+	l2Route, l2 := routeSubrouter(l1.PathPrefix(""/l""))
 	l2.Path(""/a"")
 
 	testCases := []struct {
 		path      string
 		ancestors []*Route
 	}{
 		{""/g"", []*Route{}},
-		{""/g/o"", []*Route{g.parent.(*Route)}},
-		{""/g/o/r"", []*Route{g.parent.(*Route), o.parent.(*Route)}},
-		{""/g/o/r/i"", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route)}},
-		{""/g/o/r/i/l"", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route)}},
-		{""/g/o/r/i/l/l"", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route), l1.parent.(*Route)}},
-		{""/g/o/r/i/l/l/a"", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route), l1.parent.(*Route), l2.parent.(*Route)}},
+		{""/g/o"", []*Route{gRoute}},
+		{""/g/o/r"", []*Route{gRoute, oRoute}},
+		{""/g/o/r/i"", []*Route{gRoute, oRoute, rRoute}},
+		{""/g/o/r/i/l"", []*Route{gRoute, oRoute, rRoute, iRoute}},
+		{""/g/o/r/i/l/l"", []*Route{gRoute, oRoute, rRoute, iRoute, l1Route}},
+		{""/g/o/r/i/l/l/a"", []*Route{gRoute, oRoute, rRoute, iRoute, l1Route, l2Route}},
 	}
 
 	idx := 0
@@ -1563,8 +1657,8 @@ func TestWalkSubrouters(t *testing.T) {
 	o.Methods(""GET"")
 	o.Methods(""PUT"")
 
-	// all 4 routes should be matched, but final 2 routes do not have path templates
-	paths := []string{""/g"", ""/g/o"", """", """"}
+	// all 4 routes should be matched
+	paths := []string{""/g"", ""/g/o"", ""/g/o"", ""/g/o""}
 	idx := 0
 	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
 		path := paths[idx]
@@ -1745,7 +1839,11 @@ func testRoute(t *testing.T, test routeTest) {
 			}
 		}
 		if query != """" {
-			u, _ := route.URL(mapToPairs(match.Vars)...)
+			u, err := route.URL(mapToPairs(match.Vars)...)
+			if err != nil {
+				t.Errorf(""(%v) erred while creating url: %v"", test.title, err)
+				return
+			}
 			if query != u.RawQuery {
 				t.Errorf(""(%v) URL query not equal: expected %v, got %v"", test.title, query, u.RawQuery)
 				return
@@ -2332,6 +2430,273 @@ func testMethodsSubrouter(t *testing.T, test methodsSubrouterTest) {
 	}
 }
 
+func TestSubrouterMatching(t *testing.T) {
+	const (
+		none, stdOnly, subOnly uint8 = 0, 1 << 0, 1 << 1
+		both                         = subOnly | stdOnly
+	)
+
+	type request struct {
+		Name    string
+		Request *http.Request
+		Flags   uint8
+	}
+
+	cases := []struct {
+		Name                string
+		Standard, Subrouter func(*Router)
+		Requests            []request
+	}{
+		{
+			""pathPrefix"",
+			func(r *Router) {
+				r.PathPrefix(""/before"").PathPrefix(""/after"")
+			},
+			func(r *Router) {
+				r.PathPrefix(""/before"").Subrouter().PathPrefix(""/after"")
+			},
+			[]request{
+				{""no match final path prefix"", newRequest(""GET"", ""/after""), none},
+				{""no match parent path prefix"", newRequest(""GET"", ""/before""), none},
+				{""matches append"", newRequest(""GET"", ""/before/after""), both},
+				{""matches as prefix"", newRequest(""GET"", ""/before/after/1234""), both},
+			},
+		},
+		{
+			""path"",
+			func(r *Router) {
+				r.Path(""/before"").Path(""/after"")
+			},
+			func(r *Router) {
+				r.Path(""/before"").Subrouter().Path(""/after"")
+			},
+			[]request{
+				{""no match subroute path"", newRequest(""GET"", ""/after""), none},
+				{""no match parent path"", newRequest(""GET"", ""/before""), none},
+				{""no match as prefix"", newRequest(""GET"", ""/before/after/1234""), none},
+				{""no match append"", newRequest(""GET"", ""/before/after""), none},
+			},
+		},
+		{
+			""host"",
+			func(r *Router) {
+				r.Host(""before.com"").Host(""after.com"")
+			},
+			func(r *Router) {
+				r.Host(""before.com"").Subrouter().Host(""after.com"")
+			},
+			[]request{
+				{""no match before"", newRequestHost(""GET"", ""/"", ""before.com""), none},
+				{""no match other"", newRequestHost(""GET"", ""/"", ""other.com""), none},
+				{""matches after"", newRequestHost(""GET"", ""/"", ""after.com""), none},
+			},
+		},
+		{
+			""queries variant keys"",
+			func(r *Router) {
+				r.Queries(""foo"", ""bar"").Queries(""cricket"", ""baseball"")
+			},
+			func(r *Router) {
+				r.Queries(""foo"", ""bar"").Subrouter().Queries(""cricket"", ""baseball"")
+			},
+			[]request{
+				{""matches with all"", newRequest(""GET"", ""/?foo=bar&cricket=baseball""), both},
+				{""matches with more"", newRequest(""GET"", ""/?foo=bar&cricket=baseball&something=else""), both},
+				{""no match with none"", newRequest(""GET"", ""/""), none},
+				{""no match with some"", newRequest(""GET"", ""/?cricket=baseball""), none},
+			},
+		},
+		{
+			""queries overlapping keys"",
+			func(r *Router) {
+				r.Queries(""foo"", ""bar"").Queries(""foo"", ""baz"")
+			},
+			func(r *Router) {
+				r.Queries(""foo"", ""bar"").Subrouter().Queries(""foo"", ""baz"")
+			},
+			[]request{
+				{""no match old value"", newRequest(""GET"", ""/?foo=bar""), none},
+				{""no match diff value"", newRequest(""GET"", ""/?foo=bak""), none},
+				{""no match with none"", newRequest(""GET"", ""/""), none},
+				{""matches override"", newRequest(""GET"", ""/?foo=baz""), none},
+			},
+		},
+		{
+			""header variant keys"",
+			func(r *Router) {
+				r.Headers(""foo"", ""bar"").Headers(""cricket"", ""baseball"")
+			},
+			func(r *Router) {
+				r.Headers(""foo"", ""bar"").Subrouter().Headers(""cricket"", ""baseball"")
+			},
+			[]request{
+				{
+					""matches with all"",
+					newRequestWithHeaders(""GET"", ""/"", ""foo"", ""bar"", ""cricket"", ""baseball""),
+					both,
+				},
+				{
+					""matches with more"",
+					newRequestWithHeaders(""GET"", ""/"", ""foo"", ""bar"", ""cricket"", ""baseball"", ""something"", ""else""),
+					both,
+				},
+				{""no match with none"", newRequest(""GET"", ""/""), none},
+				{""no match with some"", newRequestWithHeaders(""GET"", ""/"", ""cricket"", ""baseball""), none},
+			},
+		},
+		{
+			""header overlapping keys"",
+			func(r *Router) {
+				r.Headers(""foo"", ""bar"").Headers(""foo"", ""baz"")
+			},
+			func(r *Router) {
+				r.Headers(""foo"", ""bar"").Subrouter().Headers(""foo"", ""baz"")
+			},
+			[]request{
+				{""no match old value"", newRequestWithHeaders(""GET"", ""/"", ""foo"", ""bar""), none},
+				{""no match diff value"", newRequestWithHeaders(""GET"", ""/"", ""foo"", ""bak""), none},
+				{""no match with none"", newRequest(""GET"", ""/""), none},
+				{""matches override"", newRequestWithHeaders(""GET"", ""/"", ""foo"", ""baz""), none},
+			},
+		},
+		{
+			""method"",
+			func(r *Router) {
+				r.Methods(""POST"").Methods(""GET"")
+			},
+			func(r *Router) {
+				r.Methods(""POST"").Subrouter().Methods(""GET"")
+			},
+			[]request{
+				{""matches before"", newRequest(""POST"", ""/""), none},
+				{""no match other"", newRequest(""HEAD"", ""/""), none},
+				{""matches override"", newRequest(""GET"", ""/""), none},
+			},
+		},
+		{
+			""schemes"",
+			func(r *Router) {
+				r.Schemes(""http"").Schemes(""https"")
+			},
+			func(r *Router) {
+				r.Schemes(""http"").Subrouter().Schemes(""https"")
+			},
+			[]request{
+				{""matches overrides"", newRequest(""GET"", ""https://www.example.com/""), none},
+				{""matches original"", newRequest(""GET"", ""http://www.example.com/""), none},
+				{""no match other"", newRequest(""GET"", ""ftp://www.example.com/""), none},
+			},
+		},
+	}
+
+	// case -> request -> router
+	for _, c := range cases {
+		t.Run(c.Name, func(t *testing.T) {
+			for _, req := range c.Requests {
+				t.Run(req.Name, func(t *testing.T) {
+					for _, v := range []struct {
+						Name     string
+						Config   func(*Router)
+						Expected bool
+					}{
+						{""subrouter"", c.Subrouter, (req.Flags & subOnly) != 0},
+						{""standard"", c.Standard, (req.Flags & stdOnly) != 0},
+					} {
+						r := NewRouter()
+						v.Config(r)
+						if r.Match(req.Request, &RouteMatch{}) != v.Expected {
+							if v.Expected {
+								t.Errorf(""expected %v match"", v.Name)
+							} else {
+								t.Errorf(""expected %v no match"", v.Name)
+							}
+						}
+					}
+				})
+			}
+		})
+	}
+}
+
+// verify that copyRouteConf copies fields as expected.
+func Test_copyRouteConf(t *testing.T) {
+	var (
+		m MatcherFunc = func(*http.Request, *RouteMatch) bool {
+			return true
+		}
+		b BuildVarsFunc = func(i map[string]string) map[string]string {
+			return i
+		}
+		r, _ = newRouteRegexp(""hi"", regexpTypeHost, routeRegexpOptions{})
+	)
+
+	tests := []struct {
+		name string
+		args routeConf
+		want routeConf
+	}{
+		{
+			""empty"",
+			routeConf{},
+			routeConf{},
+		},
+		{
+			""full"",
+			routeConf{
+				useEncodedPath: true,
+				strictSlash:    true,
+				skipClean:      true,
+				regexp:         routeRegexpGroup{host: r, path: r, queries: []*routeRegexp{r}},
+				matchers:       []matcher{m},
+				buildScheme:    ""https"",
+				buildVarsFunc:  b,
+			},
+			routeConf{
+				useEncodedPath: true,
+				strictSlash:    true,
+				skipClean:      true,
+				regexp:         routeRegexpGroup{host: r, path: r, queries: []*routeRegexp{r}},
+				matchers:       []matcher{m},
+				buildScheme:    ""https"",
+				buildVarsFunc:  b,
+			},
+		},
+	}
+
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			// special case some incomparable fields of routeConf before delegating to reflect.DeepEqual
+			got := copyRouteConf(tt.args)
+
+			// funcs not comparable, just compare length of slices
+			if len(got.matchers) != len(tt.want.matchers) {
+				t.Errorf(""matchers different lengths: %v %v"", len(got.matchers), len(tt.want.matchers))
+			}
+			got.matchers, tt.want.matchers = nil, nil
+
+			// deep equal treats nil slice differently to empty slice so check for zero len first
+			{
+				bothZero := len(got.regexp.queries) == 0 && len(tt.want.regexp.queries) == 0
+				if !bothZero && !reflect.DeepEqual(got.regexp.queries, tt.want.regexp.queries) {
+					t.Errorf(""queries unequal: %v %v"", got.regexp.queries, tt.want.regexp.queries)
+				}
+				got.regexp.queries, tt.want.regexp.queries = nil, nil
+			}
+
+			// funcs not comparable, just compare nullity
+			if (got.buildVarsFunc == nil) != (tt.want.buildVarsFunc == nil) {
+				t.Errorf(""build vars funcs unequal: %v %v"", got.buildVarsFunc == nil, tt.want.buildVarsFunc == nil)
+			}
+			got.buildVarsFunc, tt.want.buildVarsFunc = nil, nil
+
+			// finish the deal
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf(""route confs unequal: %v %v"", got, tt.want)
+			}
+		})
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int
@@ -2406,3 +2771,28 @@ func newRequest(method, url string) *http.Request {
 	}
 	return req
 }
+
+// create a new request with the provided headers
+func newRequestWithHeaders(method, url string, headers ...string) *http.Request {
+	req := newRequest(method, url)
+
+	if len(headers)%2 != 0 {
+		panic(fmt.Sprintf(""Expected headers length divisible by 2 but got %v"", len(headers)))
+	}
+
+	for i := 0; i < len(headers); i += 2 {
+		req.Header.Set(headers[i], headers[i+1])
+	}
+
+	return req
+}
+
+// newRequestHost a new request with a method, url, and host header
+func newRequestHost(method, url, host string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
+	}
+	req.Host = host
+	return req
+}",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=758eb64354aa27cda6c1b026822c788cc755f06f,https://github.com/gorilla/mux/blob/758eb64354aa27cda6c1b026822c788cc755f06f/mux_test.go
758eb64354aa27cda6c1b026822c788cc755f06f,7c7405d1209ae54825dea2bfce6038064b4ac78f,regexp.go,,"Fri, 07 Dec 2018 15:48:26 GMT",modified,1,1,2,"@@ -267,7 +267,7 @@ type routeRegexpGroup struct {
 }
 
 // setMatch extracts the variables from the URL once a route matches.
-func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
+func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
 		host := getHost(req)",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=758eb64354aa27cda6c1b026822c788cc755f06f,https://github.com/gorilla/mux/blob/758eb64354aa27cda6c1b026822c788cc755f06f/regexp.go
758eb64354aa27cda6c1b026822c788cc755f06f,acef9195cbeacf39b76ecb454369cce858247bfa,route.go,,"Fri, 07 Dec 2018 15:48:26 GMT",modified,30,95,125,"@@ -15,32 +15,20 @@ import (
 
 // Route stores information to match a request and build URLs.
 type Route struct {
-	// Parent where the route was registered (a Router).
-	parent parentRoute
 	// Request handler for the route.
 	handler http.Handler
-	// List of matchers.
-	matchers []matcher
-	// Manager for the variables from host and path.
-	regexp *routeRegexpGroup
-	// If true, when the path pattern is ""/path/"", accessing ""/path"" will
-	// redirect to the former and vice versa.
-	strictSlash bool
-	// If true, when the path pattern is ""/path//to"", accessing ""/path//to""
-	// will not redirect
-	skipClean bool
-	// If true, ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to""
-	useEncodedPath bool
-	// The scheme used when building URLs.
-	buildScheme string
 	// If true, this route never matches: it is only used to build URLs.
 	buildOnly bool
 	// The name used to build URLs.
 	name string
 	// Error resulted from building a route.
 	err error
 
-	buildVarsFunc BuildVarsFunc
+	// ""global"" reference to all named routes
+	namedRoutes map[string]*Route
+
+	// config possibly passed in from `Router`
+	routeConf
 }
 
 // SkipClean reports whether path cleaning is enabled for this route via
@@ -93,9 +81,7 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	}
 
 	// Set variables.
-	if r.regexp != nil {
-		r.regexp.setMatch(req, match, r)
-	}
+	r.regexp.setMatch(req, match, r)
 	return true
 }
 
@@ -145,7 +131,7 @@ func (r *Route) Name(name string) *Route {
 	}
 	if r.err == nil {
 		r.name = name
-		r.getNamedRoutes()[name] = r
+		r.namedRoutes[name] = r
 	}
 	return r
 }
@@ -177,7 +163,6 @@ func (r *Route) addRegexpMatcher(tpl string, typ regexpType) error {
 	if r.err != nil {
 		return r.err
 	}
-	r.regexp = r.getRegexpGroup()
 	if typ == regexpTypePath || typ == regexpTypePrefix {
 		if len(tpl) > 0 && tpl[0] != '/' {
 			return fmt.Errorf(""mux: path must start with a slash, got %q"", tpl)
@@ -424,7 +409,7 @@ func (r *Route) Schemes(schemes ...string) *Route {
 	for k, v := range schemes {
 		schemes[k] = strings.ToLower(v)
 	}
-	if r.buildScheme == """" && len(schemes) > 0 {
+	if len(schemes) > 0 {
 		r.buildScheme = schemes[0]
 	}
 	return r.addMatcher(schemeMatcher(schemes))
@@ -439,7 +424,15 @@ type BuildVarsFunc func(map[string]string) map[string]string
 // BuildVarsFunc adds a custom function to be used to modify build variables
 // before a route's URL is built.
 func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
-	r.buildVarsFunc = f
+	if r.buildVarsFunc != nil {
+		// compose the old and new functions
+		old := r.buildVarsFunc
+		r.buildVarsFunc = func(m map[string]string) map[string]string {
+			return f(old(m))
+		}
+	} else {
+		r.buildVarsFunc = f
+	}
 	return r
 }
 
@@ -458,7 +451,8 @@ func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
 // Here, the routes registered in the subrouter won't be tested if the host
 // doesn't match.
 func (r *Route) Subrouter() *Router {
-	router := &Router{parent: r, strictSlash: r.strictSlash}
+	// initialize a subrouter with a copy of the parent route's configuration
+	router := &Router{routeConf: copyRouteConf(r.routeConf), namedRoutes: r.namedRoutes}
 	r.addMatcher(router)
 	return router
 }
@@ -502,9 +496,6 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 	if r.err != nil {
 		return nil, r.err
 	}
-	if r.regexp == nil {
-		return nil, errors.New(""mux: route doesn't have a host or path"")
-	}
 	values, err := r.prepareVars(pairs...)
 	if err != nil {
 		return nil, err
@@ -516,8 +507,8 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 			return nil, err
 		}
 		scheme = ""http""
-		if s := r.getBuildScheme(); s != """" {
-			scheme = s
+		if r.buildScheme != """" {
+			scheme = r.buildScheme
 		}
 	}
 	if r.regexp.path != nil {
@@ -547,7 +538,7 @@ func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
 	if r.err != nil {
 		return nil, r.err
 	}
-	if r.regexp == nil || r.regexp.host == nil {
+	if r.regexp.host == nil {
 		return nil, errors.New(""mux: route doesn't have a host"")
 	}
 	values, err := r.prepareVars(pairs...)
@@ -562,8 +553,8 @@ func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
 		Scheme: ""http"",
 		Host:   host,
 	}
-	if s := r.getBuildScheme(); s != """" {
-		u.Scheme = s
+	if r.buildScheme != """" {
+		u.Scheme = r.buildScheme
 	}
 	return u, nil
 }
@@ -575,7 +566,7 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	if r.err != nil {
 		return nil, r.err
 	}
-	if r.regexp == nil || r.regexp.path == nil {
+	if r.regexp.path == nil {
 		return nil, errors.New(""mux: route doesn't have a path"")
 	}
 	values, err := r.prepareVars(pairs...)
@@ -600,7 +591,7 @@ func (r *Route) GetPathTemplate() (string, error) {
 	if r.err != nil {
 		return """", r.err
 	}
-	if r.regexp == nil || r.regexp.path == nil {
+	if r.regexp.path == nil {
 		return """", errors.New(""mux: route doesn't have a path"")
 	}
 	return r.regexp.path.template, nil
@@ -614,7 +605,7 @@ func (r *Route) GetPathRegexp() (string, error) {
 	if r.err != nil {
 		return """", r.err
 	}
-	if r.regexp == nil || r.regexp.path == nil {
+	if r.regexp.path == nil {
 		return """", errors.New(""mux: route does not have a path"")
 	}
 	return r.regexp.path.regexp.String(), nil
@@ -629,7 +620,7 @@ func (r *Route) GetQueriesRegexp() ([]string, error) {
 	if r.err != nil {
 		return nil, r.err
 	}
-	if r.regexp == nil || r.regexp.queries == nil {
+	if r.regexp.queries == nil {
 		return nil, errors.New(""mux: route doesn't have queries"")
 	}
 	var queries []string
@@ -648,7 +639,7 @@ func (r *Route) GetQueriesTemplates() ([]string, error) {
 	if r.err != nil {
 		return nil, r.err
 	}
-	if r.regexp == nil || r.regexp.queries == nil {
+	if r.regexp.queries == nil {
 		return nil, errors.New(""mux: route doesn't have queries"")
 	}
 	var queries []string
@@ -683,7 +674,7 @@ func (r *Route) GetHostTemplate() (string, error) {
 	if r.err != nil {
 		return """", r.err
 	}
-	if r.regexp == nil || r.regexp.host == nil {
+	if r.regexp.host == nil {
 		return """", errors.New(""mux: route doesn't have a host"")
 	}
 	return r.regexp.host.template, nil
@@ -700,64 +691,8 @@ func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
 }
 
 func (r *Route) buildVars(m map[string]string) map[string]string {
-	if r.parent != nil {
-		m = r.parent.buildVars(m)
-	}
 	if r.buildVarsFunc != nil {
 		m = r.buildVarsFunc(m)
 	}
 	return m
 }
-
-// ----------------------------------------------------------------------------
-// parentRoute
-// ----------------------------------------------------------------------------
-
-// parentRoute allows routes to know about parent host and path definitions.
-type parentRoute interface {
-	getBuildScheme() string
-	getNamedRoutes() map[string]*Route
-	getRegexpGroup() *routeRegexpGroup
-	buildVars(map[string]string) map[string]string
-}
-
-func (r *Route) getBuildScheme() string {
-	if r.buildScheme != """" {
-		return r.buildScheme
-	}
-	if r.parent != nil {
-		return r.parent.getBuildScheme()
-	}
-	return """"
-}
-
-// getNamedRoutes returns the map where named routes are registered.
-func (r *Route) getNamedRoutes() map[string]*Route {
-	if r.parent == nil {
-		// During tests router is not always set.
-		r.parent = NewRouter()
-	}
-	return r.parent.getNamedRoutes()
-}
-
-// getRegexpGroup returns regexp definitions from this route.
-func (r *Route) getRegexpGroup() *routeRegexpGroup {
-	if r.regexp == nil {
-		if r.parent == nil {
-			// During tests router is not always set.
-			r.parent = NewRouter()
-		}
-		regexp := r.parent.getRegexpGroup()
-		if regexp == nil {
-			r.regexp = new(routeRegexpGroup)
-		} else {
-			// Copy.
-			r.regexp = &routeRegexpGroup{
-				host:    regexp.host,
-				path:    regexp.path,
-				queries: regexp.queries,
-			}
-		}
-	}
-	return r.regexp
-}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=758eb64354aa27cda6c1b026822c788cc755f06f,https://github.com/gorilla/mux/blob/758eb64354aa27cda6c1b026822c788cc755f06f/route.go
3d80bc801bb034e17cae38591335b3b1110f1c47,5d4027e44d62d8de3039f30304a6094de16a6c1d,mux_test.go,,"Tue, 30 Oct 2018 15:25:28 GMT",modified,76,41,117,"@@ -205,8 +205,10 @@ func TestHost(t *testing.T) {
 		},
 	}
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+		})
 	}
 }
 
@@ -437,10 +439,12 @@ func TestPath(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
-		testRegexp(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+			testUseEscapedRoute(t, test)
+			testRegexp(t, test)
+		})
 	}
 }
 
@@ -516,9 +520,11 @@ func TestPathPrefix(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+			testUseEscapedRoute(t, test)
+		})
 	}
 }
 
@@ -623,9 +629,11 @@ func TestSchemeHostPath(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+			testUseEscapedRoute(t, test)
+		})
 	}
 }
 
@@ -682,8 +690,10 @@ func TestHeaders(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+		})
 	}
 }
 
@@ -732,9 +742,11 @@ func TestMethods(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
-		testMethods(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+			testMethods(t, test)
+		})
 	}
 }
 
@@ -1039,11 +1051,12 @@ func TestQueries(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
-		testQueriesTemplates(t, test)
-		testUseEscapedRoute(t, test)
-		testQueriesRegexp(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testTemplate(t, test)
+			testQueriesTemplates(t, test)
+			testUseEscapedRoute(t, test)
+			testQueriesRegexp(t, test)
+		})
 	}
 }
 
@@ -1092,8 +1105,10 @@ func TestSchemes(t *testing.T) {
 		},
 	}
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+		})
 	}
 }
 
@@ -1127,8 +1142,10 @@ func TestMatcherFunc(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+		})
 	}
 }
 
@@ -1163,8 +1180,10 @@ func TestBuildVarsFunc(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+		})
 	}
 }
 
@@ -1294,9 +1313,11 @@ func TestSubRouter(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+			testUseEscapedRoute(t, test)
+		})
 	}
 }
 
@@ -1400,9 +1421,11 @@ func TestStrictSlash(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
-		testUseEscapedRoute(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+			testUseEscapedRoute(t, test)
+		})
 	}
 }
 
@@ -1434,8 +1457,10 @@ func TestUseEncodedPath(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testRoute(t, test)
-		testTemplate(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testRoute(t, test)
+			testTemplate(t, test)
+		})
 	}
 }
 
@@ -2040,7 +2065,9 @@ func TestMethodsSubrouterCatchall(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testMethodsSubrouter(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testMethodsSubrouter(t, test)
+		})
 	}
 }
 
@@ -2096,7 +2123,9 @@ func TestMethodsSubrouterStrictSlash(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testMethodsSubrouter(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testMethodsSubrouter(t, test)
+		})
 	}
 }
 
@@ -2143,7 +2172,9 @@ func TestMethodsSubrouterPathPrefix(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testMethodsSubrouter(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testMethodsSubrouter(t, test)
+		})
 	}
 }
 
@@ -2199,7 +2230,9 @@ func TestMethodsSubrouterSubrouter(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testMethodsSubrouter(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testMethodsSubrouter(t, test)
+		})
 	}
 }
 
@@ -2253,7 +2286,9 @@ func TestMethodsSubrouterPathVariable(t *testing.T) {
 	}
 
 	for _, test := range tests {
-		testMethodsSubrouter(t, test)
+		t.Run(test.title, func(t *testing.T) {
+			testMethodsSubrouter(t, test)
+		})
 	}
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=3d80bc801bb034e17cae38591335b3b1110f1c47,https://github.com/gorilla/mux/blob/3d80bc801bb034e17cae38591335b3b1110f1c47/mux_test.go
521ea7b17d02faf8d3afea6737573942ceac59c5,b92d59f208eff34a4835e899939e22acc255950e,regexp.go,,"Wed, 24 Oct 2018 02:08:00 GMT",modified,1,1,2,"@@ -296,7 +296,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 					} else {
 						u.Path += ""/""
 					}
-					m.Handler = http.RedirectHandler(u.String(), 301)
+					m.Handler = http.RedirectHandler(u.String(), http.StatusMovedPermanently)
 				}
 			}
 		}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=521ea7b17d02faf8d3afea6737573942ceac59c5,https://github.com/gorilla/mux/blob/521ea7b17d02faf8d3afea6737573942ceac59c5/regexp.go
deb579d6e030503f430978ee229008b9bc912d40,0425bb8018e7f1464a17e78576886bda636e342a,README.md,,"Fri, 12 Oct 2018 15:31:51 GMT",modified,1,1,2,"@@ -6,7 +6,7 @@
 
 ![Gorilla Logo](http://www.gorillatoolkit.org/static/images/gorilla-icon-64.png)
 
-http://www.gorillatoolkit.org/pkg/mux
+https://www.gorillatoolkit.org/pkg/mux
 
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=deb579d6e030503f430978ee229008b9bc912d40,https://github.com/gorilla/mux/blob/deb579d6e030503f430978ee229008b9bc912d40/README.md
9e1f5955c0d22b55d9e20d6faa28589f83b2faca,0e58a7297f03d5435cddb2835c52f459af55012b,.travis.yml,,"Mon, 03 Sep 2018 15:43:05 GMT",modified,3,1,4,"@@ -8,6 +8,8 @@ matrix:
     - go: 1.9.x
     - go: 1.10.x
     - go: 1.11.x
+    - go: 1.x
+      env: LATEST=true
     - go: tip
   allow_failures:
     - go: tip
@@ -18,5 +20,5 @@ install:
 script:
   - go get -t -v ./...
   - diff -u <(echo -n) <(gofmt -d .)
-  - go tool vet .
+  - if [[ ""$LATEST"" = true ]]; then go tool vet .; fi
   - go test -v -race ./...",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=9e1f5955c0d22b55d9e20d6faa28589f83b2faca,https://github.com/gorilla/mux/blob/9e1f5955c0d22b55d9e20d6faa28589f83b2faca/.travis.yml
cf6680bc62d81bcd52bbf1c991bfe8b7ec98e270,2db2e1397ec7b63ebe94d7536548cba72f20e7bd,.github/release-drafter.yml,,"Sun, 02 Sep 2018 22:36:45 GMT",added,8,0,8,"@@ -0,0 +1,8 @@
+# Config for https://github.com/apps/release-drafter
+template: |
+  
+  <summary of changes here>
+  
+  ## CHANGELOG
+
+  $CHANGES",https://api.github.com/repos/gorilla/mux/contents/.github%2Frelease-drafter.yml?ref=cf6680bc62d81bcd52bbf1c991bfe8b7ec98e270,https://github.com/gorilla/mux/blob/cf6680bc62d81bcd52bbf1c991bfe8b7ec98e270/.github%2Frelease-drafter.yml
8771f97498c6be5fe95d2eb5fb882c18bbf7f361,1922f6bbd9351157de45f6b758f2402559088ce4,.travis.yml,,"Sun, 02 Sep 2018 22:22:40 GMT",modified,0,2,2,"@@ -3,8 +3,6 @@ sudo: false
 
 matrix:
   include:
-    - go: 1.5.x
-    - go: 1.6.x
     - go: 1.7.x
     - go: 1.8.x
     - go: 1.9.x",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=8771f97498c6be5fe95d2eb5fb882c18bbf7f361,https://github.com/gorilla/mux/blob/8771f97498c6be5fe95d2eb5fb882c18bbf7f361/.travis.yml
8771f97498c6be5fe95d2eb5fb882c18bbf7f361,13a4601ae7c876e7401ac24f37948774f8aceb6d,context.go,context_native.go,"Sun, 02 Sep 2018 22:22:40 GMT",renamed,0,2,2,"@@ -1,5 +1,3 @@
-// +build go1.7
-
 package mux
 
 import (",https://api.github.com/repos/gorilla/mux/contents/context.go?ref=8771f97498c6be5fe95d2eb5fb882c18bbf7f361,https://github.com/gorilla/mux/blob/8771f97498c6be5fe95d2eb5fb882c18bbf7f361/context.go
8771f97498c6be5fe95d2eb5fb882c18bbf7f361,d7adaa8fad4fa8ce62d18a7058d10723ff2288af,context_gorilla.go,,"Sun, 02 Sep 2018 22:22:40 GMT",removed,0,26,26,"@@ -1,26 +0,0 @@
-// +build !go1.7
-
-package mux
-
-import (
-	""net/http""
-
-	""github.com/gorilla/context""
-)
-
-func contextGet(r *http.Request, key interface{}) interface{} {
-	return context.Get(r, key)
-}
-
-func contextSet(r *http.Request, key, val interface{}) *http.Request {
-	if val == nil {
-		return r
-	}
-
-	context.Set(r, key, val)
-	return r
-}
-
-func contextClear(r *http.Request) {
-	context.Clear(r)
-}",https://api.github.com/repos/gorilla/mux/contents/context_gorilla.go?ref=962c5bed0721b50f2ba42684e9600dfde174770f,https://github.com/gorilla/mux/blob/962c5bed0721b50f2ba42684e9600dfde174770f/context_gorilla.go
8771f97498c6be5fe95d2eb5fb882c18bbf7f361,ffaf384c0441a6f86d8e927f060c2255301242ce,context_gorilla_test.go,,"Sun, 02 Sep 2018 22:22:40 GMT",removed,0,40,40,"@@ -1,40 +0,0 @@
-// +build !go1.7
-
-package mux
-
-import (
-	""net/http""
-	""testing""
-
-	""github.com/gorilla/context""
-)
-
-// Tests that the context is cleared or not cleared properly depending on
-// the configuration of the router
-func TestKeepContext(t *testing.T) {
-	func1 := func(w http.ResponseWriter, r *http.Request) {}
-
-	r := NewRouter()
-	r.HandleFunc(""/"", func1).Name(""func1"")
-
-	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
-	context.Set(req, ""t"", 1)
-
-	res := new(http.ResponseWriter)
-	r.ServeHTTP(*res, req)
-
-	if _, ok := context.GetOk(req, ""t""); ok {
-		t.Error(""Context should have been cleared at end of request"")
-	}
-
-	r.KeepContext = true
-
-	req, _ = http.NewRequest(""GET"", ""http://localhost/"", nil)
-	context.Set(req, ""t"", 1)
-
-	r.ServeHTTP(*res, req)
-	if _, ok := context.GetOk(req, ""t""); !ok {
-		t.Error(""Context should NOT have been cleared at end of request"")
-	}
-
-}",https://api.github.com/repos/gorilla/mux/contents/context_gorilla_test.go?ref=962c5bed0721b50f2ba42684e9600dfde174770f,https://github.com/gorilla/mux/blob/962c5bed0721b50f2ba42684e9600dfde174770f/context_gorilla_test.go
8771f97498c6be5fe95d2eb5fb882c18bbf7f361,d8a56b422f9128eb49fe92931531d7f9322ceaba,context_test.go,context_native_test.go,"Sun, 02 Sep 2018 22:22:40 GMT",renamed,0,2,2,"@@ -1,5 +1,3 @@
-// +build go1.7
-
 package mux
 
 import (",https://api.github.com/repos/gorilla/mux/contents/context_test.go?ref=8771f97498c6be5fe95d2eb5fb882c18bbf7f361,https://github.com/gorilla/mux/blob/8771f97498c6be5fe95d2eb5fb882c18bbf7f361/context_test.go
962c5bed0721b50f2ba42684e9600dfde174770f,5da7addc333b3a609706fd858d03e89c7fe7f848,.travis.yml,,"Thu, 30 Aug 2018 14:23:24 GMT",modified,1,0,1,"@@ -9,6 +9,7 @@ matrix:
     - go: 1.8.x
     - go: 1.9.x
     - go: 1.10.x
+    - go: 1.11.x
     - go: tip
   allow_failures:
     - go: tip",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=962c5bed0721b50f2ba42684e9600dfde174770f,https://github.com/gorilla/mux/blob/962c5bed0721b50f2ba42684e9600dfde174770f/.travis.yml
e48e440e4c92e3251d812f8ce7858944dfa3331c,31c7d51deece5a5d602617b051a9d3291357cef9,mux_test.go,,"Tue, 07 Aug 2018 07:52:56 GMT",modified,9,0,9,"@@ -1323,6 +1323,15 @@ func TestNamedRoutes(t *testing.T) {
 	}
 }
 
+func TestNameMultipleCalls(t *testing.T) {
+	r1 := NewRouter()
+	rt := r1.NewRoute().Name(""foo"").Name(""bar"")
+	err := rt.GetError()
+	if err == nil {
+		t.Errorf(""Expected an error"")
+	}
+}
+
 func TestStrictSlash(t *testing.T) {
 	r := NewRouter()
 	r.StrictSlash(true)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e48e440e4c92e3251d812f8ce7858944dfa3331c,https://github.com/gorilla/mux/blob/e48e440e4c92e3251d812f8ce7858944dfa3331c/mux_test.go
815b8c6a2641cd336000b3fb159b5741d0dc0113,c8bb5c7e3a0d6331871879ed2c46ca952e34fb14,route.go,,"Tue, 07 Aug 2018 07:50:18 GMT",modified,1,1,2,"@@ -137,7 +137,7 @@ func (r *Route) GetHandler() http.Handler {
 // Name -----------------------------------------------------------------------
 
 // Name sets the name for the route, used to build URLs.
-// If the name was registered already it will be overwritten.
+// It is an error to call Name more than once on a route.
 func (r *Route) Name(name string) *Route {
 	if r.name != """" {
 		r.err = fmt.Errorf(""mux: route already has name %q, can't set %q"",",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=815b8c6a2641cd336000b3fb159b5741d0dc0113,https://github.com/gorilla/mux/blob/815b8c6a2641cd336000b3fb159b5741d0dc0113/route.go
cb4698366aa625048f3b815af6a0dea8aef9280a,b722392ee59266773c107a8e871d6b2a3085cb7c,AUTHORS,,"Tue, 05 Jun 2018 21:15:56 GMT",added,8,0,8,"@@ -0,0 +1,8 @@
+# This is the official list of gorilla/mux authors for copyright purposes.
+#
+# Please keep the list sorted.
+
+Google LLC (https://opensource.google.com/)
+Kamil Kisielk <kamil@kamilkisiel.net>
+Matt Silverlock <matt@eatsleeprepeat.net>
+Rodrigo Moraes (https://github.com/moraes)",https://api.github.com/repos/gorilla/mux/contents/AUTHORS?ref=cb4698366aa625048f3b815af6a0dea8aef9280a,https://github.com/gorilla/mux/blob/cb4698366aa625048f3b815af6a0dea8aef9280a/AUTHORS
cb4698366aa625048f3b815af6a0dea8aef9280a,6903df6386e98928a3236b87c84b71260c2541a6,LICENSE,,"Tue, 05 Jun 2018 21:15:56 GMT",modified,1,1,2,"@@ -1,4 +1,4 @@
-Copyright (c) 2012 Rodrigo Moraes. All rights reserved.
+Copyright (c) 2012-2018 The Gorilla Authors. All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are",https://api.github.com/repos/gorilla/mux/contents/LICENSE?ref=cb4698366aa625048f3b815af6a0dea8aef9280a,https://github.com/gorilla/mux/blob/cb4698366aa625048f3b815af6a0dea8aef9280a/LICENSE
e0b5abaaae35242fa74372f26c24107711702a4e,6f2ea86ca7089cdea23abc39297942e123710309,example_authentication_middleware_test.go,,"Sat, 26 May 2018 22:17:21 GMT",modified,1,1,2,"@@ -40,7 +40,7 @@ func Example_authenticationMiddleware() {
 	r.HandleFunc(""/"", func(w http.ResponseWriter, r *http.Request) {
 		// Do something here
 	})
-	amw := authenticationMiddleware{}
+	amw := authenticationMiddleware{make(map[string]string)}
 	amw.Populate()
 	r.Use(amw.Middleware)
 }",https://api.github.com/repos/gorilla/mux/contents/example_authentication_middleware_test.go?ref=e0b5abaaae35242fa74372f26c24107711702a4e,https://github.com/gorilla/mux/blob/e0b5abaaae35242fa74372f26c24107711702a4e/example_authentication_middleware_test.go
c85619274f5d55a67491010f883a91f568b3a9b0,cfc8ede5818b9b09b510b5a34729054060b28656,go.mod,,"Thu, 17 May 2018 17:36:23 GMT",added,1,0,1,"@@ -0,0 +1 @@
+module github.com/gorilla/mux",https://api.github.com/repos/gorilla/mux/contents/go.mod?ref=c85619274f5d55a67491010f883a91f568b3a9b0,https://github.com/gorilla/mux/blob/c85619274f5d55a67491010f883a91f568b3a9b0/go.mod
e3702bed27f0d39777b0b37b664b6280e8ef8fbf,ceb812cee284493bde4d614b933a49d3f5cd425f,middleware.go,,"Sun, 13 May 2018 03:22:33 GMT",modified,1,1,2,"@@ -15,7 +15,7 @@ type middleware interface {
 	Middleware(handler http.Handler) http.Handler
 }
 
-// Middleware also implements the middleware interface.
+// Middleware allows MiddlewareFunc to implement the middleware interface.
 func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler {
 	return mw(handler)
 }",https://api.github.com/repos/gorilla/mux/contents/middleware.go?ref=e3702bed27f0d39777b0b37b664b6280e8ef8fbf,https://github.com/gorilla/mux/blob/e3702bed27f0d39777b0b37b664b6280e8ef8fbf/middleware.go
e3702bed27f0d39777b0b37b664b6280e8ef8fbf,4bbafa51da301690f53a011964769d4eac6d7c84,mux.go,,"Sun, 13 May 2018 03:22:33 GMT",modified,1,1,2,"@@ -13,7 +13,7 @@ import (
 )
 
 var (
-	// ErrMethodMismatch is returned when the error in the request does not match
+	// ErrMethodMismatch is returned when the method in the request does not match
 	// the method defined against the route.
 	ErrMethodMismatch = errors.New(""method is not allowed"")
 	// ErrNotFound is returned when no route match is found.",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=e3702bed27f0d39777b0b37b664b6280e8ef8fbf,https://github.com/gorilla/mux/blob/e3702bed27f0d39777b0b37b664b6280e8ef8fbf/mux.go
e3702bed27f0d39777b0b37b664b6280e8ef8fbf,a591d7354500f7a8bce59f8a544ccbe90e40bb8b,route.go,,"Sun, 13 May 2018 03:22:33 GMT",modified,2,2,4,"@@ -43,8 +43,8 @@ type Route struct {
 	buildVarsFunc BuildVarsFunc
 }
 
-// SkipClean bypasses cleaning the path, which includes removing duplicate
-// slashes and URL encoding.
+// SkipClean reports whether path cleaning is enabled for this route via
+// Router.SkipClean.
 func (r *Route) SkipClean() bool {
 	return r.skipClean
 }",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=e3702bed27f0d39777b0b37b664b6280e8ef8fbf,https://github.com/gorilla/mux/blob/e3702bed27f0d39777b0b37b664b6280e8ef8fbf/route.go
fdeb7bc314fecece4e261b048f5fee1cb80208fe,e424397ac4d01bf3583d11bccd5baa08be1eba31,README.md,,"Sun, 13 May 2018 03:09:30 GMT",modified,5,2,7,"@@ -601,8 +601,11 @@ func TestMetricsHandler(t *testing.T) {
         }
 
         rr := httptest.NewRecorder()
-        handler := http.HandlerFunc(MetricsHandler)
-        handler.ServeHTTP(rr, req)
+	
+	// Need to create a router that we can pass the request through so that the vars will be added to the context
+	router := mux.NewRouter()
+        router.HandleFunc(""/metrics/{type}"", MetricsHandler)
+        router.ServeHTTP(rr, req)
 
         // In this case, our MetricsHandler returns a non-200 response
         // for a route variable it doesn't know about.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=fdeb7bc314fecece4e261b048f5fee1cb80208fe,https://github.com/gorilla/mux/blob/fdeb7bc314fecece4e261b048f5fee1cb80208fe/README.md
5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8,fab9ae3523619cf0675766f3c2ff890dd37244e6,middleware.go,,"Sat, 12 May 2018 01:30:14 GMT",modified,43,1,44,"@@ -1,6 +1,9 @@
 package mux
 
-import ""net/http""
+import (
+	""net/http""
+	""strings""
+)
 
 // MiddlewareFunc is a function which receives an http.Handler and returns another http.Handler.
 // Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed
@@ -28,3 +31,42 @@ func (r *Router) Use(mwf ...MiddlewareFunc) {
 func (r *Router) useInterface(mw middleware) {
 	r.middlewares = append(r.middlewares, mw)
 }
+
+// CORSMethodMiddleware sets the Access-Control-Allow-Methods response header
+// on a request, by matching routes based only on paths. It also handles
+// OPTIONS requests, by settings Access-Control-Allow-Methods, and then
+// returning without calling the next http handler.
+func CORSMethodMiddleware(r *Router) MiddlewareFunc {
+	return func(next http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
+			var allMethods []string
+
+			err := r.Walk(func(route *Route, _ *Router, _ []*Route) error {
+				for _, m := range route.matchers {
+					if _, ok := m.(*routeRegexp); ok {
+						if m.Match(req, &RouteMatch{}) {
+							methods, err := route.GetMethods()
+							if err != nil {
+								return err
+							}
+
+							allMethods = append(allMethods, methods...)
+						}
+						break
+					}
+				}
+				return nil
+			})
+
+			if err == nil {
+				w.Header().Set(""Access-Control-Allow-Methods"", strings.Join(append(allMethods, ""OPTIONS""), "",""))
+
+				if req.Method == ""OPTIONS"" {
+					return
+				}
+			}
+
+			next.ServeHTTP(w, req)
+		})
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/middleware.go?ref=5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8,https://github.com/gorilla/mux/blob/5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8/middleware.go
5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8,acf4e160b90f862c3611488a0a179df68af749f9,middleware_test.go,,"Sat, 12 May 2018 01:30:14 GMT",modified,41,0,41,"@@ -3,6 +3,7 @@ package mux
 import (
 	""bytes""
 	""net/http""
+	""net/http/httptest""
 	""testing""
 )
 
@@ -334,3 +335,43 @@ func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
 		t.Fatal(""Middleware was called for a method mismatch"")
 	}
 }
+
+func TestCORSMethodMiddleware(t *testing.T) {
+	router := NewRouter()
+
+	cases := []struct {
+		path                   string
+		response               string
+		method                 string
+		testURL                string
+		expectedAllowedMethods string
+	}{
+		{""/g/{o}"", ""a"", ""POST"", ""/g/asdf"", ""POST,PUT,GET,OPTIONS""},
+		{""/g/{o}"", ""b"", ""PUT"", ""/g/bla"", ""POST,PUT,GET,OPTIONS""},
+		{""/g/{o}"", ""c"", ""GET"", ""/g/orilla"", ""POST,PUT,GET,OPTIONS""},
+		{""/g"", ""d"", ""POST"", ""/g"", ""POST,OPTIONS""},
+	}
+
+	for _, tt := range cases {
+		router.HandleFunc(tt.path, stringHandler(tt.response)).Methods(tt.method)
+	}
+
+	router.Use(CORSMethodMiddleware(router))
+
+	for _, tt := range cases {
+		rr := httptest.NewRecorder()
+		req := newRequest(tt.method, tt.testURL)
+
+		router.ServeHTTP(rr, req)
+
+		if rr.Body.String() != tt.response {
+			t.Errorf(""Expected body '%s', found '%s'"", tt.response, rr.Body.String())
+		}
+
+		allowedMethods := rr.HeaderMap.Get(""Access-Control-Allow-Methods"")
+
+		if allowedMethods != tt.expectedAllowedMethods {
+			t.Errorf(""Expected Access-Control-Allow-Methods '%s', found '%s'"", tt.expectedAllowedMethods, allowedMethods)
+		}
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8,https://github.com/gorilla/mux/blob/5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8/middleware_test.go
5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8,af21329f20301c6c1c196db9701e34cc17b51704,mux_test.go,,"Sat, 12 May 2018 01:30:14 GMT",modified,8,0,8,"@@ -2315,6 +2315,14 @@ func stringMapEqual(m1, m2 map[string]string) bool {
 	return true
 }
 
+// stringHandler returns a handler func that writes a message 's' to the
+// http.ResponseWriter.
+func stringHandler(s string) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte(s))
+	}
+}
+
 // newRequest is a helper function to create a new request with a method and url.
 // The request returned is a 'server' request as opposed to a 'client' one through
 // simulated write onto the wire and read off of the wire.",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8,https://github.com/gorilla/mux/blob/5e55a4adb89fb64e8b13bbd302eeedac7a4ba5d8/mux_test.go
ded0c29b24f96f46cf349e6701b099db601cf8ec,cf6cfc33fc3be1dd412a26406f3c62cda867ba86,middleware.go,,"Tue, 01 May 2018 03:11:36 GMT",modified,1,1,2,"@@ -12,7 +12,7 @@ type middleware interface {
 	Middleware(handler http.Handler) http.Handler
 }
 
-// MiddlewareFunc also implements the middleware interface.
+// Middleware also implements the middleware interface.
 func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler {
 	return mw(handler)
 }",https://api.github.com/repos/gorilla/mux/contents/middleware.go?ref=ded0c29b24f96f46cf349e6701b099db601cf8ec,https://github.com/gorilla/mux/blob/ded0c29b24f96f46cf349e6701b099db601cf8ec/middleware.go
ded0c29b24f96f46cf349e6701b099db601cf8ec,5b39694ed98f4322ca2ad9b19eb97bb4c23b528c,mux.go,,"Tue, 01 May 2018 03:11:36 GMT",modified,6,3,9,"@@ -13,8 +13,11 @@ import (
 )
 
 var (
+	// ErrMethodMismatch is returned when the error in the request does not match
+	// the method defined against the route.
 	ErrMethodMismatch = errors.New(""method is not allowed"")
-	ErrNotFound       = errors.New(""no matching route was found"")
+	// ErrNotFound is returned when no route match is found.
+	ErrNotFound = errors.New(""no matching route was found"")
 )
 
 // NewRouter returns a new router instance.
@@ -95,9 +98,9 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 		if r.MethodNotAllowedHandler != nil {
 			match.Handler = r.MethodNotAllowedHandler
 			return true
-		} else {
-			return false
 		}
+
+		return false
 	}
 
 	// Closest match for a router (includes sub-routers)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=ded0c29b24f96f46cf349e6701b099db601cf8ec,https://github.com/gorilla/mux/blob/ded0c29b24f96f46cf349e6701b099db601cf8ec/mux.go
ded0c29b24f96f46cf349e6701b099db601cf8ec,cc37ad6c3372a04a05f7600bab511c45ddcd6a25,route.go,,"Tue, 01 May 2018 03:11:36 GMT",modified,2,0,2,"@@ -43,6 +43,8 @@ type Route struct {
 	buildVarsFunc BuildVarsFunc
 }
 
+// SkipClean bypasses cleaning the path, which includes removing duplicate
+// slashes and URL encoding.
 func (r *Route) SkipClean() bool {
 	return r.skipClean
 }",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=ded0c29b24f96f46cf349e6701b099db601cf8ec,https://github.com/gorilla/mux/blob/ded0c29b24f96f46cf349e6701b099db601cf8ec/route.go
b57cb1605fd11ba2ecfa7f68992b4b9cc791934d,ad0935dbd3764febee766b9fd61bd5dc1cfde0cb,.travis.yml,,"Mon, 16 Apr 2018 20:45:19 GMT",modified,6,5,11,"@@ -3,11 +3,12 @@ sudo: false
 
 matrix:
   include:
-    - go: 1.5
-    - go: 1.6
-    - go: 1.7
-    - go: 1.8
-    - go: 1.9
+    - go: 1.5.x
+    - go: 1.6.x
+    - go: 1.7.x
+    - go: 1.8.x
+    - go: 1.9.x
+    - go: 1.10.x
     - go: tip
   allow_failures:
     - go: tip",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=b57cb1605fd11ba2ecfa7f68992b4b9cc791934d,https://github.com/gorilla/mux/blob/b57cb1605fd11ba2ecfa7f68992b4b9cc791934d/.travis.yml
94231ffd98496cbcb1c15b7bf2a9edfd5f852cd4,8f55ddcdc933c4476c1961eeca7e8aee4426feca,README.md,,"Tue, 03 Apr 2018 18:23:30 GMT",modified,4,4,8,"@@ -593,8 +593,8 @@ func TestMetricsHandler(t *testing.T) {
         {""adhadaeqm3k"", false},
     }
 
-    for _, t := tt {
-        path := fmt.Sprintf(""/metrics/%s"", t.routeVariable)
+    for _, tc := range tt {
+        path := fmt.Sprintf(""/metrics/%s"", tc.routeVariable)
         req, err := http.NewRequest(""GET"", path, nil)
         if err != nil {
             t.Fatal(err)
@@ -606,9 +606,9 @@ func TestMetricsHandler(t *testing.T) {
 
         // In this case, our MetricsHandler returns a non-200 response
         // for a route variable it doesn't know about.
-        if rr.Code == http.StatusOK && !t.shouldPass {
+        if rr.Code == http.StatusOK && !tc.shouldPass {
             t.Errorf(""handler should have failed on routeVariable %s: got %v want %v"",
-                t.routeVariable, rr.Code, http.StatusOK)
+                tc.routeVariable, rr.Code, http.StatusOK)
         }
     }
 }",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=94231ffd98496cbcb1c15b7bf2a9edfd5f852cd4,https://github.com/gorilla/mux/blob/94231ffd98496cbcb1c15b7bf2a9edfd5f852cd4/README.md
4dbd923b0c9e99ff63ad54b0e9705ff92d3cdb06,ec79e5d7c72483e29c87538bf10d81c129256978,middleware.go,,"Wed, 14 Mar 2018 16:31:26 GMT",modified,4,2,6,"@@ -18,8 +18,10 @@ func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler {
 }
 
 // Use appends a MiddlewareFunc to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.
-func (r *Router) Use(mwf MiddlewareFunc) {
-	r.middlewares = append(r.middlewares, mwf)
+func (r *Router) Use(mwf ...MiddlewareFunc) {
+	for _, fn := range mwf {
+		r.middlewares = append(r.middlewares, fn)
+	}
 }
 
 // useInterface appends a middleware to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.",https://api.github.com/repos/gorilla/mux/contents/middleware.go?ref=4dbd923b0c9e99ff63ad54b0e9705ff92d3cdb06,https://github.com/gorilla/mux/blob/4dbd923b0c9e99ff63ad54b0e9705ff92d3cdb06/middleware.go
07ba1fd60e210dc5cc6f86ec25dc9ecc7c95c295,ad2424940273ff6c423432712c087149e13e5a15,README.md,,"Mon, 26 Feb 2018 05:11:51 GMT",modified,1,1,2,"@@ -473,7 +473,7 @@ func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler
         	next.ServeHTTP(w, r)
         } else {
         	// Write an error and stop the handler chain
-        	http.Error(w, ""Forbidden"", 403)
+        	http.Error(w, ""Forbidden"", http.StatusForbidden)
         }
     })
 }",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=07ba1fd60e210dc5cc6f86ec25dc9ecc7c95c295,https://github.com/gorilla/mux/blob/07ba1fd60e210dc5cc6f86ec25dc9ecc7c95c295/README.md
d284fd84214eaf533d13ee880d2ab978ef81d7a2,38957deead3d73b4cbf24fca337bbf8a6dfa03cc,doc.go,,"Sun, 25 Feb 2018 16:08:54 GMT",modified,1,1,2,"@@ -287,7 +287,7 @@ A more complex authentication middleware, which maps session token to users, cou
 				log.Printf(""Authenticated user %s\n"", user)
 				next.ServeHTTP(w, r)
 			} else {
-				http.Error(w, ""Forbidden"", 403)
+				http.Error(w, ""Forbidden"", http.StatusForbidden)
 			}
 		})
 	}",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=d284fd84214eaf533d13ee880d2ab978ef81d7a2,https://github.com/gorilla/mux/blob/d284fd84214eaf533d13ee880d2ab978ef81d7a2/doc.go
d284fd84214eaf533d13ee880d2ab978ef81d7a2,67df321839f2918171d5be8ba6f5336812cfabcf,example_authentication_middleware_test.go,,"Sun, 25 Feb 2018 16:08:54 GMT",modified,1,1,2,"@@ -30,7 +30,7 @@ func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler
 			log.Printf(""Authenticated user %s\n"", user)
 			next.ServeHTTP(w, r)
 		} else {
-			http.Error(w, ""Forbidden"", 403)
+			http.Error(w, ""Forbidden"", http.StatusForbidden)
 		}
 	})
 }",https://api.github.com/repos/gorilla/mux/contents/example_authentication_middleware_test.go?ref=d284fd84214eaf533d13ee880d2ab978ef81d7a2,https://github.com/gorilla/mux/blob/d284fd84214eaf533d13ee880d2ab978ef81d7a2/example_authentication_middleware_test.go
c0091a029979286890368b4c7b301261e448e242,bc468d4417465fa20296d7240d44015ee190f2ff,example_authentication_middleware_test.go,,"Sat, 20 Jan 2018 07:58:19 GMT",added,46,0,46,"@@ -0,0 +1,46 @@
+package mux_test
+
+import (
+	""log""
+	""net/http""
+
+	""github.com/gorilla/mux""
+)
+
+// Define our struct
+type authenticationMiddleware struct {
+	tokenUsers map[string]string
+}
+
+// Initialize it somewhere
+func (amw *authenticationMiddleware) Populate() {
+	amw.tokenUsers[""00000000""] = ""user0""
+	amw.tokenUsers[""aaaaaaaa""] = ""userA""
+	amw.tokenUsers[""05f717e5""] = ""randomUser""
+	amw.tokenUsers[""deadbeef""] = ""user0""
+}
+
+// Middleware function, which will be called for each request
+func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {
+	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		token := r.Header.Get(""X-Session-Token"")
+
+		if user, found := amw.tokenUsers[token]; found {
+			// We found the token in our map
+			log.Printf(""Authenticated user %s\n"", user)
+			next.ServeHTTP(w, r)
+		} else {
+			http.Error(w, ""Forbidden"", 403)
+		}
+	})
+}
+
+func Example_authenticationMiddleware() {
+	r := mux.NewRouter()
+	r.HandleFunc(""/"", func(w http.ResponseWriter, r *http.Request) {
+		// Do something here
+	})
+	amw := authenticationMiddleware{}
+	amw.Populate()
+	r.Use(amw.Middleware)
+}",https://api.github.com/repos/gorilla/mux/contents/example_authentication_middleware_test.go?ref=c0091a029979286890368b4c7b301261e448e242,https://github.com/gorilla/mux/blob/c0091a029979286890368b4c7b301261e448e242/example_authentication_middleware_test.go
0fdf828bb28a79b519024e2e29915e851b73e580,4591344e36fd93fa0c07e258147ce617dc293351,mux_test.go,,"Sat, 20 Jan 2018 06:28:49 GMT",modified,9,0,9,"@@ -2248,6 +2248,15 @@ func TestMethodsSubrouterPathVariable(t *testing.T) {
 	}
 }
 
+func ExampleSetURLVars() {
+	req, _ := http.NewRequest(""GET"", ""/foo"", nil)
+	req = SetURLVars(req, map[string]string{""foo"": ""bar""})
+
+	fmt.Println(Vars(req)[""foo""])
+
+	// Output: bar
+}
+
 // testMethodsSubrouter runs an individual methodsSubrouterTest.
 func testMethodsSubrouter(t *testing.T, test methodsSubrouterTest) {
 	// Execute request",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=0fdf828bb28a79b519024e2e29915e851b73e580,https://github.com/gorilla/mux/blob/0fdf828bb28a79b519024e2e29915e851b73e580/mux_test.go
0fdf828bb28a79b519024e2e29915e851b73e580,32ecffde489f43aa0a73ff86e151cca3373daae6,test_helpers.go,,"Sat, 20 Jan 2018 06:28:49 GMT",modified,2,1,3,"@@ -7,7 +7,8 @@ package mux
 import ""net/http""
 
 // SetURLVars sets the URL variables for the given request, to be accessed via
-// mux.Vars for testing route behaviour.
+// mux.Vars for testing route behaviour. Arguments are not modified, a shallow
+// copy is returned.
 //
 // This API should only be used for testing purposes; it provides a way to
 // inject variables into the request context. Alternatively, URL variables",https://api.github.com/repos/gorilla/mux/contents/test_helpers.go?ref=0fdf828bb28a79b519024e2e29915e851b73e580,https://github.com/gorilla/mux/blob/0fdf828bb28a79b519024e2e29915e851b73e580/test_helpers.go
077b44c2cf82958550c79f5885ee64900cdcee22,9f261438a9e6e69577470fb31092152e6783a444,route.go,,"Sat, 20 Jan 2018 04:51:41 GMT",modified,4,4,8,"@@ -622,7 +622,7 @@ func (r *Route) GetPathRegexp() (string, error) {
 // route queries.
 // This is useful for building simple REST API documentation and for instrumentation
 // against third-party services.
-// An empty list will be returned if the route does not have queries.
+// An error will be returned if the route does not have queries.
 func (r *Route) GetQueriesRegexp() ([]string, error) {
 	if r.err != nil {
 		return nil, r.err
@@ -641,7 +641,7 @@ func (r *Route) GetQueriesRegexp() ([]string, error) {
 // query matching.
 // This is useful for building simple REST API documentation and for instrumentation
 // against third-party services.
-// An empty list will be returned if the route does not define queries.
+// An error will be returned if the route does not define queries.
 func (r *Route) GetQueriesTemplates() ([]string, error) {
 	if r.err != nil {
 		return nil, r.err
@@ -659,7 +659,7 @@ func (r *Route) GetQueriesTemplates() ([]string, error) {
 // GetMethods returns the methods the route matches against
 // This is useful for building simple REST API documentation and for instrumentation
 // against third-party services.
-// An empty list will be returned if route does not have methods.
+// An error will be returned if route does not have methods.
 func (r *Route) GetMethods() ([]string, error) {
 	if r.err != nil {
 		return nil, r.err
@@ -669,7 +669,7 @@ func (r *Route) GetMethods() ([]string, error) {
 			return []string(methods), nil
 		}
 	}
-	return nil, nil
+	return nil, errors.New(""mux: route doesn't have methods"")
 }
 
 // GetHostTemplate returns the template used to build the",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=077b44c2cf82958550c79f5885ee64900cdcee22,https://github.com/gorilla/mux/blob/077b44c2cf82958550c79f5885ee64900cdcee22/route.go
dc835075986d1932ee5495f32e3631770715fd6c,e56cdb3e98899a9b2a8fd287886af9119af78a24,README.md,,"Sat, 20 Jan 2018 04:47:48 GMT",modified,52,93,145,"@@ -180,64 +180,6 @@ s.HandleFunc(""/{key}/"", ProductHandler)
 s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 ```
 
-### Listing Routes
-
-Routes on a mux can be listed using the Router.Walk method—useful for generating documentation:
-
-```go
-package main
-
-import (
-    ""fmt""
-    ""net/http""
-    ""strings""
-
-    ""github.com/gorilla/mux""
-)
-
-func handler(w http.ResponseWriter, r *http.Request) {
-    return
-}
-
-func main() {
-    r := mux.NewRouter()
-    r.HandleFunc(""/"", handler)
-    r.HandleFunc(""/products"", handler).Methods(""POST"")
-    r.HandleFunc(""/articles"", handler).Methods(""GET"")
-    r.HandleFunc(""/articles/{id}"", handler).Methods(""GET"", ""PUT"")
-    r.HandleFunc(""/authors"", handler).Queries(""surname"", ""{surname}"")
-    r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
-        t, err := route.GetPathTemplate()
-        if err != nil {
-            return err
-        }
-        qt, err := route.GetQueriesTemplates()
-        if err != nil {
-            return err
-        }
-        // p will contain regular expression is compatible with regular expression in Perl, Python, and other languages.
-        // for instance the regular expression for path '/articles/{id}' will be '^/articles/(?P<v0>[^/]+)$'
-        p, err := route.GetPathRegexp()
-        if err != nil {
-            return err
-        }
-        // qr will contain a list of regular expressions with the same semantics as GetPathRegexp,
-        // just applied to the Queries pairs instead, e.g., 'Queries(""surname"", ""{surname}"") will return
-        // {""^surname=(?P<v0>.*)$}. Where each combined query pair will have an entry in the list.
-        qr, err := route.GetQueriesRegexp()
-        if err != nil {
-            return err
-        }
-        m, err := route.GetMethods()
-        if err != nil {
-            return err
-        }
-        fmt.Println(strings.Join(m, "",""), strings.Join(qt, "",""), strings.Join(qr, "",""), t, p)
-        return nil
-    })
-    http.Handle(""/"", r)
-}
-```
 
 ### Static Files
 
@@ -350,41 +292,58 @@ The `Walk` function on `mux.Router` can be used to visit all of the routes that
 the following prints all of the registered routes:
 
 ```go
-r := mux.NewRouter()
-r.HandleFunc(""/"", handler)
-r.HandleFunc(""/products"", handler).Methods(""POST"")
-r.HandleFunc(""/articles"", handler).Methods(""GET"")
-r.HandleFunc(""/articles/{id}"", handler).Methods(""GET"", ""PUT"")
-r.HandleFunc(""/authors"", handler).Queries(""surname"", ""{surname}"")
-r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
-    t, err := route.GetPathTemplate()
-    if err != nil {
-        return err
-    }
-    qt, err := route.GetQueriesTemplates()
-    if err != nil {
-        return err
-    }
-    // p will contain a regular expression that is compatible with regular expressions in Perl, Python, and other languages.
-    // For example, the regular expression for path '/articles/{id}' will be '^/articles/(?P<v0>[^/]+)$'.
-    p, err := route.GetPathRegexp()
-    if err != nil {
-        return err
-    }
-    // qr will contain a list of regular expressions with the same semantics as GetPathRegexp,
-    // just applied to the Queries pairs instead, e.g., 'Queries(""surname"", ""{surname}"") will return
-    // {""^surname=(?P<v0>.*)$}. Where each combined query pair will have an entry in the list.
-    qr, err := route.GetQueriesRegexp()
-    if err != nil {
-        return err
-    }
-    m, err := route.GetMethods()
-    if err != nil {
-        return err
-    }
-    fmt.Println(strings.Join(m, "",""), strings.Join(qt, "",""), strings.Join(qr, "",""), t, p)
-    return nil
-})
+package main
+
+import (
+	""fmt""
+	""net/http""
+	""strings""
+
+	""github.com/gorilla/mux""
+)
+
+func handler(w http.ResponseWriter, r *http.Request) {
+	return
+}
+
+func main() {
+	r := mux.NewRouter()
+	r.HandleFunc(""/"", handler)
+	r.HandleFunc(""/products"", handler).Methods(""POST"")
+	r.HandleFunc(""/articles"", handler).Methods(""GET"")
+	r.HandleFunc(""/articles/{id}"", handler).Methods(""GET"", ""PUT"")
+	r.HandleFunc(""/authors"", handler).Queries(""surname"", ""{surname}"")
+	err := r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
+		pathTemplate, err := route.GetPathTemplate()
+		if err == nil {
+			fmt.Println(""ROUTE:"", pathTemplate)
+		}
+		pathRegexp, err := route.GetPathRegexp()
+		if err == nil {
+			fmt.Println(""Path regexp:"", pathRegexp)
+		}
+		queriesTemplates, err := route.GetQueriesTemplates()
+		if err == nil {
+			fmt.Println(""Queries templates:"", strings.Join(queriesTemplates, "",""))
+		}
+		queriesRegexps, err := route.GetQueriesRegexp()
+		if err == nil {
+			fmt.Println(""Queries regexps:"", strings.Join(queriesRegexps, "",""))
+		}
+		methods, err := route.GetMethods()
+		if err == nil {
+			fmt.Println(""Methods:"", strings.Join(methods, "",""))
+		}
+		fmt.Println()
+		return nil
+	})
+
+	if err != nil {
+		fmt.Println(err)
+	}
+
+	http.Handle(""/"", r)
+}
 ```
 
 ### Graceful Shutdown",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=dc835075986d1932ee5495f32e3631770715fd6c,https://github.com/gorilla/mux/blob/dc835075986d1932ee5495f32e3631770715fd6c/README.md
3dbb9ed96e4b25ec143f9d484ad5695179f10d47,5028112a04a4c4ddc1b45050a94c79744fca6e7d,README.md,,"Sat, 20 Jan 2018 04:20:16 GMT",modified,1,0,1,"@@ -401,6 +401,7 @@ import (
     ""net/http""
     ""os""
     ""os/signal""
+    ""time""
 
     ""github.com/gorilla/mux""
 )",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=3dbb9ed96e4b25ec143f9d484ad5695179f10d47,https://github.com/gorilla/mux/blob/3dbb9ed96e4b25ec143f9d484ad5695179f10d47/README.md
ad8790881febb89da2b487073a57e079fa4aaa6f,b6dd1ffb4f247ea2333c52ca11040a8d5a932560,doc.go,,"Thu, 18 Jan 2018 17:53:57 GMT",modified,1,2,3,"@@ -239,8 +239,7 @@ as well:
 	                                 ""category"", ""technology"",
 	                                 ""id"", ""42"")
 
-Since **vX.Y.Z**, mux supports the addition of middlewares to a [Router](https://godoc.org/github.com/gorilla/mux#Router), which are executed if a
-match is found (including subrouters). Middlewares are defined using the de facto standard type:
+Mux supports the addition of middlewares to a Router, which are executed in the order they are added if a match is found, including its subrouters. Middlewares are (typically) small pieces of code which take one request, do something with it, and pass it down to another middleware or the final handler. Some common use cases for middleware are request logging, header manipulation, or ResponseWriter hijacking.
 
 	type MiddlewareFunc func(http.Handler) http.Handler
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=ad8790881febb89da2b487073a57e079fa4aaa6f,https://github.com/gorilla/mux/blob/ad8790881febb89da2b487073a57e079fa4aaa6f/doc.go
69dae3b874ba34bcaa563d5e5b1680334bfd9b73,dc9e254e1ba91c83a386851931355e63dfc3d89e,README.md,,"Wed, 17 Jan 2018 07:16:36 GMT",modified,129,4,133,"@@ -1,5 +1,5 @@
-gorilla/mux
-===
+# gorilla/mux
+
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
 [![Sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
@@ -29,6 +29,7 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 * [Walking Routes](#walking-routes)
 * [Graceful Shutdown](#graceful-shutdown)
 * [Middleware](#middleware)
+* [Testing Handlers](#testing-handlers)
 * [Full Example](#full-example)
 
 ---
@@ -178,6 +179,7 @@ s.HandleFunc(""/{key}/"", ProductHandler)
 // ""/products/{key}/details""
 s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 ```
+
 ### Listing Routes
 
 Routes on a mux can be listed using the Router.Walk method—useful for generating documentation:
@@ -241,7 +243,7 @@ func main() {
 
 Note that the path provided to `PathPrefix()` represents a ""wildcard"": calling
 `PathPrefix(""/static/"").Handler(...)` means that the handler will be passed any
-request that matches ""/static/*"". This makes it easy to serve static files with mux:
+request that matches ""/static/\*"". This makes it easy to serve static files with mux:
 
 ```go
 func main() {
@@ -527,7 +529,130 @@ amw.Populate()
 r.Use(amw.Middleware)
 ```
 
-Note: The handler chain will be stopped if your middleware doesn't call `next.ServeHTTP()` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to. Middlewares *should* write to `ResponseWriter` if they *are* going to terminate the request, and they *should not* write to `ResponseWriter` if they *are not* going to terminate it.
+Note: The handler chain will be stopped if your middleware doesn't call `next.ServeHTTP()` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to. Middlewares _should_ write to `ResponseWriter` if they _are_ going to terminate the request, and they _should not_ write to `ResponseWriter` if they _are not_ going to terminate it.
+
+### Testing Handlers
+
+Testing handlers in a Go web application is straightforward, and _mux_ doesn't complicate this any further. Given two files: `endpoints.go` and `endpoints_test.go`, here's how we'd test an application using _mux_.
+
+First, our simple HTTP handler:
+
+```go
+// endpoints.go
+package main
+
+func HealthCheckHandler(w http.ResponseWriter, r *http.Request) {
+    // A very simple health check.
+    w.WriteHeader(http.StatusOK)
+    w.Header().Set(""Content-Type"", ""application/json"")
+
+    // In the future we could report back on the status of our DB, or our cache
+    // (e.g. Redis) by performing a simple PING, and include them in the response.
+    io.WriteString(w, `{""alive"": true}`)
+}
+
+func main() {
+    r := mux.NewRouter()
+    r.HandleFunc(""/health"", HealthCheckHandler)
+
+    log.Fatal(http.ListenAndServe(""localhost:8080"", r))
+}
+```
+
+Our test code:
+
+```go
+// endpoints_test.go
+package main
+
+import (
+    ""net/http""
+    ""net/http/httptest""
+    ""testing""
+)
+
+func TestHealthCheckHandler(t *testing.T) {
+    // Create a request to pass to our handler. We don't have any query parameters for now, so we'll
+    // pass 'nil' as the third parameter.
+    req, err := http.NewRequest(""GET"", ""/health"", nil)
+    if err != nil {
+        t.Fatal(err)
+    }
+
+    // We create a ResponseRecorder (which satisfies http.ResponseWriter) to record the response.
+    rr := httptest.NewRecorder()
+    handler := http.HandlerFunc(HealthCheckHandler)
+
+    // Our handlers satisfy http.Handler, so we can call their ServeHTTP method
+    // directly and pass in our Request and ResponseRecorder.
+    handler.ServeHTTP(rr, req)
+
+    // Check the status code is what we expect.
+    if status := rr.Code; status != http.StatusOK {
+        t.Errorf(""handler returned wrong status code: got %v want %v"",
+            status, http.StatusOK)
+    }
+
+    // Check the response body is what we expect.
+    expected := `{""alive"": true}`
+    if rr.Body.String() != expected {
+        t.Errorf(""handler returned unexpected body: got %v want %v"",
+            rr.Body.String(), expected)
+    }
+}
+```
+
+In the case that our routes have [variables](#examples), we can pass those in the request. We could write
+[table-driven tests](https://dave.cheney.net/2013/06/09/writing-table-driven-tests-in-go) to test multiple
+possible route variables as needed.
+
+```go
+// endpoints.go
+func main() {
+    r := mux.NewRouter()
+    // A route with a route variable:
+    r.HandleFunc(""/metrics/{type}"", MetricsHandler)
+
+    log.Fatal(http.ListenAndServe(""localhost:8080"", r))
+}
+```
+
+Our test file, with a table-driven test of `routeVariables`:
+
+```go
+// endpoints_test.go
+func TestMetricsHandler(t *testing.T) {
+    tt := []struct{
+        routeVariable string
+        shouldPass bool
+    }{
+        {""goroutines"", true},
+        {""heap"", true},
+        {""counters"", true},
+        {""queries"", true},
+        {""adhadaeqm3k"", false},
+    }
+
+    for _, t := tt {
+        path := fmt.Sprintf(""/metrics/%s"", t.routeVariable)
+        req, err := http.NewRequest(""GET"", path, nil)
+        if err != nil {
+            t.Fatal(err)
+        }
+
+        rr := httptest.NewRecorder()
+        handler := http.HandlerFunc(MetricsHandler)
+        handler.ServeHTTP(rr, req)
+
+        // In this case, our MetricsHandler returns a non-200 response
+        // for a route variable it doesn't know about.
+        if rr.Code == http.StatusOK && !t.shouldPass {
+            t.Errorf(""handler should have failed on routeVariable %s: got %v want %v"",
+                t.routeVariable, rr.Code, http.StatusOK)
+        }
+    }
+}
+```
 
 ## Full Example
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=69dae3b874ba34bcaa563d5e5b1680334bfd9b73,https://github.com/gorilla/mux/blob/69dae3b874ba34bcaa563d5e5b1680334bfd9b73/README.md
63c5c2f1f01d8151addc1b09edc9f39a8a217993,6fe65961ce27cc563a95ab178fd8559af87d271c,README.md,,"Wed, 17 Jan 2018 07:16:06 GMT",modified,4,4,8,"@@ -465,7 +465,7 @@ Typically, the returned handler is a closure which does something with the http.
 A very basic middleware which logs the URI of the request being handled could be written as:
 
 ```go
-func simpleMw(next http.Handler) http.Handler {
+func loggingMiddleware(next http.Handler) http.Handler {
     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
         // Do stuff here
         log.Println(r.RequestURI)
@@ -475,12 +475,12 @@ func simpleMw(next http.Handler) http.Handler {
 }
 ```
 
-Middlewares can be added to a router using `Router.AddMiddlewareFunc()`:
+Middlewares can be added to a router using `Router.Use()`:
 
 ```go
 r := mux.NewRouter()
 r.HandleFunc(""/"", handler)
-r.AddMiddleware(simpleMw)
+r.Use(loggingMiddleware)
 ```
 
 A more complex authentication middleware, which maps session token to users, could be written as:
@@ -524,7 +524,7 @@ r.HandleFunc(""/"", handler)
 amw := authenticationMiddleware{}
 amw.Populate()
 
-r.AddMiddlewareFunc(amw.Middleware)
+r.Use(amw.Middleware)
 ```
 
 Note: The handler chain will be stopped if your middleware doesn't call `next.ServeHTTP()` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to. Middlewares *should* write to `ResponseWriter` if they *are* going to terminate the request, and they *should not* write to `ResponseWriter` if they *are not* going to terminate it.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=63c5c2f1f01d8151addc1b09edc9f39a8a217993,https://github.com/gorilla/mux/blob/63c5c2f1f01d8151addc1b09edc9f39a8a217993/README.md
85e6bfff1ae85ae9c2db46ea91ce093c0abca066,7f12986e3cc742f4c93981dc4801e0ada6020465,doc.go,,"Wed, 17 Jan 2018 01:18:53 GMT",modified,1,1,2,"@@ -261,7 +261,7 @@ Middlewares can be added to a router using `Router.Use()`:
 
 	r := mux.NewRouter()
 	r.HandleFunc(""/"", handler)
-	r.AddMiddleware(simpleMw)
+	r.Use(simpleMw)
 
 A more complex authentication middleware, which maps session token to users, could be written as:
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=85e6bfff1ae85ae9c2db46ea91ce093c0abca066,https://github.com/gorilla/mux/blob/85e6bfff1ae85ae9c2db46ea91ce093c0abca066/doc.go
0b74e3d0fe68bbe7c66e693df167074f7f527e86,fc1555a5398ebbb99d4017ce1c4018bc68835f3f,README.md,,"Tue, 16 Jan 2018 22:43:47 GMT",modified,5,4,9,"@@ -410,7 +410,7 @@ func main() {
 
     r := mux.NewRouter()
     // Add your routes as needed
-    
+
     srv := &http.Server{
         Addr:         ""0.0.0.0:8080"",
         // Good practice to set timeouts to avoid Slowloris attacks.
@@ -426,7 +426,7 @@ func main() {
             log.Println(err)
         }
     }()
-    
+
     c := make(chan os.Signal, 1)
     // We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
     // SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.
@@ -436,7 +436,8 @@ func main() {
     <-c
 
     // Create a deadline to wait for.
-    ctx, cancel := context.WithTimeout(ctx, wait)
+    ctx, cancel := context.WithTimeout(context.Background(), wait)
+    defer cancel()
     // Doesn't block if no connections, but will otherwise wait
     // until the timeout deadline.
     srv.Shutdown(ctx)
@@ -502,7 +503,7 @@ func (amw *authenticationMiddleware) Populate() {
 func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {
     return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
         token := r.Header.Get(""X-Session-Token"")
-        
+
         if user, found := amw.tokenUsers[token]; found {
         	// We found the token in our map
         	log.Printf(""Authenticated user %s\n"", user)",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=0b74e3d0fe68bbe7c66e693df167074f7f527e86,https://github.com/gorilla/mux/blob/0b74e3d0fe68bbe7c66e693df167074f7f527e86/README.md
53c1911da2b537f792e7cafcb446b05ffe33b996,f9b3103f06843e67c974daf556c4769595d1d74f,README.md,,"Tue, 16 Jan 2018 17:23:47 GMT",modified,81,0,81,"@@ -28,6 +28,7 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 * [Registered URLs](#registered-urls)
 * [Walking Routes](#walking-routes)
 * [Graceful Shutdown](#graceful-shutdown)
+* [Middleware](#middleware)
 * [Full Example](#full-example)
 
 ---
@@ -447,6 +448,86 @@ func main() {
 }
 ```
 
+### Middleware
+
+Mux supports the addition of middlewares to a [Router](https://godoc.org/github.com/gorilla/mux#Router), which are executed in the order they are added if a match is found, including its subrouters.
+Middlewares are (typically) small pieces of code which take one request, do something with it, and pass it down to another middleware or the final handler. Some common use cases for middleware are request logging, header manipulation, or `ResponseWriter` hijacking.
+
+Mux middlewares are defined using the de facto standard type:
+
+```go
+type MiddlewareFunc func(http.Handler) http.Handler
+```
+
+Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed to it, and then calls the handler passed as parameter to the MiddlewareFunc. This takes advantage of closures being able access variables from the context where they are created, while retaining the signature enforced by the receivers.
+
+A very basic middleware which logs the URI of the request being handled could be written as:
+
+```go
+func simpleMw(next http.Handler) http.Handler {
+    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+        // Do stuff here
+        log.Println(r.RequestURI)
+        // Call the next handler, which can be another middleware in the chain, or the final handler.
+        next.ServeHTTP(w, r)
+    })
+}
+```
+
+Middlewares can be added to a router using `Router.AddMiddlewareFunc()`:
+
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/"", handler)
+r.AddMiddleware(simpleMw)
+```
+
+A more complex authentication middleware, which maps session token to users, could be written as:
+
+```go
+// Define our struct
+type authenticationMiddleware struct {
+	tokenUsers map[string]string
+}
+
+// Initialize it somewhere
+func (amw *authenticationMiddleware) Populate() {
+	amw.tokenUsers[""00000000""] = ""user0""
+	amw.tokenUsers[""aaaaaaaa""] = ""userA""
+	amw.tokenUsers[""05f717e5""] = ""randomUser""
+	amw.tokenUsers[""deadbeef""] = ""user0""
+}
+
+// Middleware function, which will be called for each request
+func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {
+    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+        token := r.Header.Get(""X-Session-Token"")
+        
+        if user, found := amw.tokenUsers[token]; found {
+        	// We found the token in our map
+        	log.Printf(""Authenticated user %s\n"", user)
+        	// Pass down the request to the next middleware (or final handler)
+        	next.ServeHTTP(w, r)
+        } else {
+        	// Write an error and stop the handler chain
+        	http.Error(w, ""Forbidden"", 403)
+        }
+    })
+}
+```
+
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/"", handler)
+
+amw := authenticationMiddleware{}
+amw.Populate()
+
+r.AddMiddlewareFunc(amw.Middleware)
+```
+
+Note: The handler chain will be stopped if your middleware doesn't call `next.ServeHTTP()` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to. Middlewares *should* write to `ResponseWriter` if they *are* going to terminate the request, and they *should not* write to `ResponseWriter` if they *are not* going to terminate it.
+
 ## Full Example
 
 Here's a complete, runnable example of a small `mux` based server:",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=53c1911da2b537f792e7cafcb446b05ffe33b996,https://github.com/gorilla/mux/blob/53c1911da2b537f792e7cafcb446b05ffe33b996/README.md
53c1911da2b537f792e7cafcb446b05ffe33b996,013f088985b07fbeffb7604ef2f1938a5e4cac88,doc.go,,"Tue, 16 Jan 2018 17:23:47 GMT",modified,65,0,65,"@@ -238,5 +238,70 @@ as well:
 	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
 	                                 ""category"", ""technology"",
 	                                 ""id"", ""42"")
+
+Since **vX.Y.Z**, mux supports the addition of middlewares to a [Router](https://godoc.org/github.com/gorilla/mux#Router), which are executed if a
+match is found (including subrouters). Middlewares are defined using the de facto standard type:
+
+	type MiddlewareFunc func(http.Handler) http.Handler
+
+Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed to it, and then calls the handler passed as parameter to the MiddlewareFunc (closures can access variables from the context where they are created).
+
+A very basic middleware which logs the URI of the request being handled could be written as:
+
+	func simpleMw(next http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			// Do stuff here
+			log.Println(r.RequestURI)
+			// Call the next handler, which can be another middleware in the chain, or the final handler.
+			next.ServeHTTP(w, r)
+		})
+	}
+
+Middlewares can be added to a router using `Router.Use()`:
+
+	r := mux.NewRouter()
+	r.HandleFunc(""/"", handler)
+	r.AddMiddleware(simpleMw)
+
+A more complex authentication middleware, which maps session token to users, could be written as:
+
+	// Define our struct
+	type authenticationMiddleware struct {
+		tokenUsers map[string]string
+	}
+
+	// Initialize it somewhere
+	func (amw *authenticationMiddleware) Populate() {
+		amw.tokenUsers[""00000000""] = ""user0""
+		amw.tokenUsers[""aaaaaaaa""] = ""userA""
+		amw.tokenUsers[""05f717e5""] = ""randomUser""
+		amw.tokenUsers[""deadbeef""] = ""user0""
+	}
+
+	// Middleware function, which will be called for each request
+	func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			token := r.Header.Get(""X-Session-Token"")
+
+			if user, found := amw.tokenUsers[token]; found {
+				// We found the token in our map
+				log.Printf(""Authenticated user %s\n"", user)
+				next.ServeHTTP(w, r)
+			} else {
+				http.Error(w, ""Forbidden"", 403)
+			}
+		})
+	}
+
+	r := mux.NewRouter()
+	r.HandleFunc(""/"", handler)
+
+	amw := authenticationMiddleware{}
+	amw.Populate()
+
+	r.Use(amw.Middleware)
+
+Note: The handler chain will be stopped if your middleware doesn't call `next.ServeHTTP()` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to.
+
 */
 package mux",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=53c1911da2b537f792e7cafcb446b05ffe33b996,https://github.com/gorilla/mux/blob/53c1911da2b537f792e7cafcb446b05ffe33b996/doc.go
53c1911da2b537f792e7cafcb446b05ffe33b996,8f898675ea7465425f5ea70208080ae0b4cc7b68,middleware.go,,"Tue, 16 Jan 2018 17:23:47 GMT",added,28,0,28,"@@ -0,0 +1,28 @@
+package mux
+
+import ""net/http""
+
+// MiddlewareFunc is a function which receives an http.Handler and returns another http.Handler.
+// Typically, the returned handler is a closure which does something with the http.ResponseWriter and http.Request passed
+// to it, and then calls the handler passed as parameter to the MiddlewareFunc.
+type MiddlewareFunc func(http.Handler) http.Handler
+
+// middleware interface is anything which implements a MiddlewareFunc named Middleware.
+type middleware interface {
+	Middleware(handler http.Handler) http.Handler
+}
+
+// MiddlewareFunc also implements the middleware interface.
+func (mw MiddlewareFunc) Middleware(handler http.Handler) http.Handler {
+	return mw(handler)
+}
+
+// Use appends a MiddlewareFunc to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.
+func (r *Router) Use(mwf MiddlewareFunc) {
+	r.middlewares = append(r.middlewares, mwf)
+}
+
+// useInterface appends a middleware to the chain. Middleware can be used to intercept or otherwise modify requests and/or responses, and are executed in the order that they are applied to the Router.
+func (r *Router) useInterface(mw middleware) {
+	r.middlewares = append(r.middlewares, mw)
+}",https://api.github.com/repos/gorilla/mux/contents/middleware.go?ref=53c1911da2b537f792e7cafcb446b05ffe33b996,https://github.com/gorilla/mux/blob/53c1911da2b537f792e7cafcb446b05ffe33b996/middleware.go
53c1911da2b537f792e7cafcb446b05ffe33b996,93947e8cb3d99278ce8a2941a6c2ea796437572b,middleware_test.go,,"Tue, 16 Jan 2018 17:23:47 GMT",added,336,0,336,"@@ -0,0 +1,336 @@
+package mux
+
+import (
+	""bytes""
+	""net/http""
+	""testing""
+)
+
+type testMiddleware struct {
+	timesCalled uint
+}
+
+func (tm *testMiddleware) Middleware(h http.Handler) http.Handler {
+	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		tm.timesCalled++
+		h.ServeHTTP(w, r)
+	})
+}
+
+func dummyHandler(w http.ResponseWriter, r *http.Request) {}
+
+func TestMiddlewareAdd(t *testing.T) {
+	router := NewRouter()
+	router.HandleFunc(""/"", dummyHandler).Methods(""GET"")
+
+	mw := &testMiddleware{}
+
+	router.useInterface(mw)
+	if len(router.middlewares) != 1 || router.middlewares[0] != mw {
+		t.Fatal(""Middleware was not added correctly"")
+	}
+
+	router.Use(mw.Middleware)
+	if len(router.middlewares) != 2 {
+		t.Fatal(""MiddlewareFunc method was not added correctly"")
+	}
+
+	banalMw := func(handler http.Handler) http.Handler {
+		return handler
+	}
+	router.Use(banalMw)
+	if len(router.middlewares) != 3 {
+		t.Fatal(""MiddlewareFunc method was not added correctly"")
+	}
+}
+
+func TestMiddleware(t *testing.T) {
+	router := NewRouter()
+	router.HandleFunc(""/"", dummyHandler).Methods(""GET"")
+
+	mw := &testMiddleware{}
+	router.useInterface(mw)
+
+	rw := NewRecorder()
+	req := newRequest(""GET"", ""/"")
+
+	// Test regular middleware call
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 1 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+	}
+
+	// Middleware should not be called for 404
+	req = newRequest(""GET"", ""/not/found"")
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 1 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+	}
+
+	// Middleware should not be called if there is a method mismatch
+	req = newRequest(""POST"", ""/"")
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 1 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+	}
+
+	// Add the middleware again as function
+	router.Use(mw.Middleware)
+	req = newRequest(""GET"", ""/"")
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 3 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 3, mw.timesCalled)
+	}
+
+}
+
+func TestMiddlewareSubrouter(t *testing.T) {
+	router := NewRouter()
+	router.HandleFunc(""/"", dummyHandler).Methods(""GET"")
+
+	subrouter := router.PathPrefix(""/sub"").Subrouter()
+	subrouter.HandleFunc(""/x"", dummyHandler).Methods(""GET"")
+
+	mw := &testMiddleware{}
+	subrouter.useInterface(mw)
+
+	rw := NewRecorder()
+	req := newRequest(""GET"", ""/"")
+
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 0 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 0, mw.timesCalled)
+	}
+
+	req = newRequest(""GET"", ""/sub/"")
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 0 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 0, mw.timesCalled)
+	}
+
+	req = newRequest(""GET"", ""/sub/x"")
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 1 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+	}
+
+	req = newRequest(""GET"", ""/sub/not/found"")
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 1 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 1, mw.timesCalled)
+	}
+
+	router.useInterface(mw)
+
+	req = newRequest(""GET"", ""/"")
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 2 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 2, mw.timesCalled)
+	}
+
+	req = newRequest(""GET"", ""/sub/x"")
+	router.ServeHTTP(rw, req)
+	if mw.timesCalled != 4 {
+		t.Fatalf(""Expected %d calls, but got only %d"", 4, mw.timesCalled)
+	}
+}
+
+func TestMiddlewareExecution(t *testing.T) {
+	mwStr := []byte(""Middleware\n"")
+	handlerStr := []byte(""Logic\n"")
+
+	router := NewRouter()
+	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
+		w.Write(handlerStr)
+	})
+
+	rw := NewRecorder()
+	req := newRequest(""GET"", ""/"")
+
+	// Test handler-only call
+	router.ServeHTTP(rw, req)
+
+	if bytes.Compare(rw.Body.Bytes(), handlerStr) != 0 {
+		t.Fatal(""Handler response is not what it should be"")
+	}
+
+	// Test middleware call
+	rw = NewRecorder()
+
+	router.Use(func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			w.Write(mwStr)
+			h.ServeHTTP(w, r)
+		})
+	})
+
+	router.ServeHTTP(rw, req)
+	if bytes.Compare(rw.Body.Bytes(), append(mwStr, handlerStr...)) != 0 {
+		t.Fatal(""Middleware + handler response is not what it should be"")
+	}
+}
+
+func TestMiddlewareNotFound(t *testing.T) {
+	mwStr := []byte(""Middleware\n"")
+	handlerStr := []byte(""Logic\n"")
+
+	router := NewRouter()
+	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
+		w.Write(handlerStr)
+	})
+	router.Use(func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			w.Write(mwStr)
+			h.ServeHTTP(w, r)
+		})
+	})
+
+	// Test not found call with default handler
+	rw := NewRecorder()
+	req := newRequest(""GET"", ""/notfound"")
+
+	router.ServeHTTP(rw, req)
+	if bytes.Contains(rw.Body.Bytes(), mwStr) {
+		t.Fatal(""Middleware was called for a 404"")
+	}
+
+	// Test not found call with custom handler
+	rw = NewRecorder()
+	req = newRequest(""GET"", ""/notfound"")
+
+	router.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+		rw.Write([]byte(""Custom 404 handler""))
+	})
+	router.ServeHTTP(rw, req)
+
+	if bytes.Contains(rw.Body.Bytes(), mwStr) {
+		t.Fatal(""Middleware was called for a custom 404"")
+	}
+}
+
+func TestMiddlewareMethodMismatch(t *testing.T) {
+	mwStr := []byte(""Middleware\n"")
+	handlerStr := []byte(""Logic\n"")
+
+	router := NewRouter()
+	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
+		w.Write(handlerStr)
+	}).Methods(""GET"")
+
+	router.Use(func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			w.Write(mwStr)
+			h.ServeHTTP(w, r)
+		})
+	})
+
+	// Test method mismatch
+	rw := NewRecorder()
+	req := newRequest(""POST"", ""/"")
+
+	router.ServeHTTP(rw, req)
+	if bytes.Contains(rw.Body.Bytes(), mwStr) {
+		t.Fatal(""Middleware was called for a method mismatch"")
+	}
+
+	// Test not found call
+	rw = NewRecorder()
+	req = newRequest(""POST"", ""/"")
+
+	router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+		rw.Write([]byte(""Method not allowed""))
+	})
+	router.ServeHTTP(rw, req)
+
+	if bytes.Contains(rw.Body.Bytes(), mwStr) {
+		t.Fatal(""Middleware was called for a method mismatch"")
+	}
+}
+
+func TestMiddlewareNotFoundSubrouter(t *testing.T) {
+	mwStr := []byte(""Middleware\n"")
+	handlerStr := []byte(""Logic\n"")
+
+	router := NewRouter()
+	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
+		w.Write(handlerStr)
+	})
+
+	subrouter := router.PathPrefix(""/sub/"").Subrouter()
+	subrouter.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
+		w.Write(handlerStr)
+	})
+
+	router.Use(func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			w.Write(mwStr)
+			h.ServeHTTP(w, r)
+		})
+	})
+
+	// Test not found call for default handler
+	rw := NewRecorder()
+	req := newRequest(""GET"", ""/sub/notfound"")
+
+	router.ServeHTTP(rw, req)
+	if bytes.Contains(rw.Body.Bytes(), mwStr) {
+		t.Fatal(""Middleware was called for a 404"")
+	}
+
+	// Test not found call with custom handler
+	rw = NewRecorder()
+	req = newRequest(""GET"", ""/sub/notfound"")
+
+	subrouter.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+		rw.Write([]byte(""Custom 404 handler""))
+	})
+	router.ServeHTTP(rw, req)
+
+	if bytes.Contains(rw.Body.Bytes(), mwStr) {
+		t.Fatal(""Middleware was called for a custom 404"")
+	}
+}
+
+func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
+	mwStr := []byte(""Middleware\n"")
+	handlerStr := []byte(""Logic\n"")
+
+	router := NewRouter()
+	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
+		w.Write(handlerStr)
+	})
+
+	subrouter := router.PathPrefix(""/sub/"").Subrouter()
+	subrouter.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
+		w.Write(handlerStr)
+	}).Methods(""GET"")
+
+	router.Use(func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			w.Write(mwStr)
+			h.ServeHTTP(w, r)
+		})
+	})
+
+	// Test method mismatch without custom handler
+	rw := NewRecorder()
+	req := newRequest(""POST"", ""/sub/"")
+
+	router.ServeHTTP(rw, req)
+	if bytes.Contains(rw.Body.Bytes(), mwStr) {
+		t.Fatal(""Middleware was called for a method mismatch"")
+	}
+
+	// Test method mismatch with custom handler
+	rw = NewRecorder()
+	req = newRequest(""POST"", ""/sub/"")
+
+	router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
+		rw.Write([]byte(""Method not allowed""))
+	})
+	router.ServeHTTP(rw, req)
+
+	if bytes.Contains(rw.Body.Bytes(), mwStr) {
+		t.Fatal(""Middleware was called for a method mismatch"")
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=53c1911da2b537f792e7cafcb446b05ffe33b996,https://github.com/gorilla/mux/blob/53c1911da2b537f792e7cafcb446b05ffe33b996/middleware_test.go
53c1911da2b537f792e7cafcb446b05ffe33b996,efabd24175118b684f08928140c2775be958104a,mux.go,,"Tue, 16 Jan 2018 17:23:47 GMT",modified,9,0,9,"@@ -63,6 +63,8 @@ type Router struct {
 	KeepContext bool
 	// see Router.UseEncodedPath(). This defines a flag for all routes.
 	useEncodedPath bool
+	// Slice of middlewares to be called after a match is found
+	middlewares []middleware
 }
 
 // Match attempts to match the given request against the router's registered routes.
@@ -79,6 +81,12 @@ type Router struct {
 func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 	for _, route := range r.routes {
 		if route.Match(req, match) {
+			// Build middleware chain if no error was found
+			if match.MatchErr == nil {
+				for i := len(r.middlewares) - 1; i >= 0; i-- {
+					match.Handler = r.middlewares[i].Middleware(match.Handler)
+				}
+			}
 			return true
 		}
 	}
@@ -147,6 +155,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	if !r.KeepContext {
 		defer contextClear(req)
 	}
+
 	handler.ServeHTTP(w, req)
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=53c1911da2b537f792e7cafcb446b05ffe33b996,https://github.com/gorilla/mux/blob/53c1911da2b537f792e7cafcb446b05ffe33b996/mux.go
5bbbb5b2b5729b132181cc7f4aa3b3c973e9a0ed,20094574cf2d67ec2c2b6da64ae5bda9b2cdd21f,README.md,,"Sun, 07 Jan 2018 15:57:08 GMT",modified,96,32,128,"@@ -27,6 +27,7 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 * [Static Files](#static-files)
 * [Registered URLs](#registered-urls)
 * [Walking Routes](#walking-routes)
+* [Graceful Shutdown](#graceful-shutdown)
 * [Full Example](#full-example)
 
 ---
@@ -45,11 +46,11 @@ Let's start registering a couple of URL paths and handlers:
 
 ```go
 func main() {
-	r := mux.NewRouter()
-	r.HandleFunc(""/"", HomeHandler)
-	r.HandleFunc(""/products"", ProductsHandler)
-	r.HandleFunc(""/articles"", ArticlesHandler)
-	http.Handle(""/"", r)
+    r := mux.NewRouter()
+    r.HandleFunc(""/"", HomeHandler)
+    r.HandleFunc(""/products"", ProductsHandler)
+    r.HandleFunc(""/articles"", ArticlesHandler)
+    http.Handle(""/"", r)
 }
 ```
 
@@ -68,9 +69,9 @@ The names are used to create a map of route variables which can be retrieved cal
 
 ```go
 func ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) {
-	vars := mux.Vars(r)
-	w.WriteHeader(http.StatusOK)
-	fmt.Fprintf(w, ""Category: %v\n"", vars[""category""])
+    vars := mux.Vars(r)
+    w.WriteHeader(http.StatusOK)
+    fmt.Fprintf(w, ""Category: %v\n"", vars[""category""])
 }
 ```
 
@@ -122,7 +123,7 @@ r.Queries(""key"", ""value"")
 
 ```go
 r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
-	return r.ProtoMajor == 0
+    return r.ProtoMajor == 0
 })
 ```
 
@@ -243,24 +244,24 @@ request that matches ""/static/*"". This makes it easy to serve static files with
 
 ```go
 func main() {
-	var dir string
+    var dir string
 
-	flag.StringVar(&dir, ""dir"", ""."", ""the directory to serve files from. Defaults to the current dir"")
-	flag.Parse()
-	r := mux.NewRouter()
+    flag.StringVar(&dir, ""dir"", ""."", ""the directory to serve files from. Defaults to the current dir"")
+    flag.Parse()
+    r := mux.NewRouter()
 
-	// This will serve files under http://localhost:8000/static/<filename>
-	r.PathPrefix(""/static/"").Handler(http.StripPrefix(""/static/"", http.FileServer(http.Dir(dir))))
+    // This will serve files under http://localhost:8000/static/<filename>
+    r.PathPrefix(""/static/"").Handler(http.StripPrefix(""/static/"", http.FileServer(http.Dir(dir))))
 
-	srv := &http.Server{
-		Handler:      r,
-		Addr:         ""127.0.0.1:8000"",
-		// Good practice: enforce timeouts for servers you create!
-		WriteTimeout: 15 * time.Second,
-		ReadTimeout:  15 * time.Second,
-	}
+    srv := &http.Server{
+        Handler:      r,
+        Addr:         ""127.0.0.1:8000"",
+        // Good practice: enforce timeouts for servers you create!
+        WriteTimeout: 15 * time.Second,
+        ReadTimeout:  15 * time.Second,
+    }
 
-	log.Fatal(srv.ListenAndServe())
+    log.Fatal(srv.ListenAndServe())
 }
 ```
 
@@ -383,6 +384,69 @@ r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error
 })
 ```
 
+### Graceful Shutdown
+
+Go 1.8 introduced the ability to [gracefully shutdown](https://golang.org/doc/go1.8#http_shutdown) a `*http.Server`. Here's how to do that alongside `mux`:
+
+```go
+package main
+
+import (
+    ""context""
+    ""flag""
+    ""log""
+    ""net/http""
+    ""os""
+    ""os/signal""
+
+    ""github.com/gorilla/mux""
+)
+
+func main() {
+    var wait time.Duration
+    flag.DurationVar(&wait, ""graceful-timeout"", time.Second * 15, ""the duration for which the server gracefully wait for existing connections to finish - e.g. 15s or 1m"")
+    flag.Parse()
+
+    r := mux.NewRouter()
+    // Add your routes as needed
+    
+    srv := &http.Server{
+        Addr:         ""0.0.0.0:8080"",
+        // Good practice to set timeouts to avoid Slowloris attacks.
+        WriteTimeout: time.Second * 15,
+        ReadTimeout:  time.Second * 15,
+        IdleTimeout:  time.Second * 60,
+        Handler: r, // Pass our instance of gorilla/mux in.
+    }
+
+    // Run our server in a goroutine so that it doesn't block.
+    go func() {
+        if err := srv.ListenAndServe(); err != nil {
+            log.Println(err)
+        }
+    }()
+    
+    c := make(chan os.Signal, 1)
+    // We'll accept graceful shutdowns when quit via SIGINT (Ctrl+C)
+    // SIGKILL, SIGQUIT or SIGTERM (Ctrl+/) will not be caught.
+    signal.Notify(c, os.Interrupt)
+
+    // Block until we receive our signal.
+    <-c
+
+    // Create a deadline to wait for.
+    ctx, cancel := context.WithTimeout(ctx, wait)
+    // Doesn't block if no connections, but will otherwise wait
+    // until the timeout deadline.
+    srv.Shutdown(ctx)
+    // Optionally, you could run srv.Shutdown in a goroutine and block on
+    // <-ctx.Done() if your application should wait for other services
+    // to finalize based on context cancellation.
+    log.Println(""shutting down"")
+    os.Exit(0)
+}
+```
+
 ## Full Example
 
 Here's a complete, runnable example of a small `mux` based server:
@@ -391,22 +455,22 @@ Here's a complete, runnable example of a small `mux` based server:
 package main
 
 import (
-	""net/http""
-	""log""
-	""github.com/gorilla/mux""
+    ""net/http""
+    ""log""
+    ""github.com/gorilla/mux""
 )
 
 func YourHandler(w http.ResponseWriter, r *http.Request) {
-	w.Write([]byte(""Gorilla!\n""))
+    w.Write([]byte(""Gorilla!\n""))
 }
 
 func main() {
-	r := mux.NewRouter()
-	// Routes consist of a path and a handler function.
-	r.HandleFunc(""/"", YourHandler)
+    r := mux.NewRouter()
+    // Routes consist of a path and a handler function.
+    r.HandleFunc(""/"", YourHandler)
 
-	// Bind to a port and pass our router in
-	log.Fatal(http.ListenAndServe("":8000"", r))
+    // Bind to a port and pass our router in
+    log.Fatal(http.ListenAndServe("":8000"", r))
 }
 ```
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=5bbbb5b2b5729b132181cc7f4aa3b3c973e9a0ed,https://github.com/gorilla/mux/blob/5bbbb5b2b5729b132181cc7f4aa3b3c973e9a0ed/README.md
512169e5d707b96d6306216743bb7884a2b3a3c9,9e93c9830014e9e6939d5405625fc470b8c54ec9,mux_test.go,,"Fri, 05 Jan 2018 18:40:59 GMT",modified,1,1,2,"@@ -25,7 +25,7 @@ func (r *Route) GoString() string {
 }
 
 func (r *routeRegexp) GoString() string {
-	return fmt.Sprintf(""&routeRegexp{template: %q, matchHost: %t, matchQuery: %t, strictSlash: %t, regexp: regexp.MustCompile(%q), reverse: %q, varsN: %v, varsR: %v"", r.template, r.matchHost, r.matchQuery, r.strictSlash, r.regexp.String(), r.reverse, r.varsN, r.varsR)
+	return fmt.Sprintf(""&routeRegexp{template: %q, regexpType: %v, options: %v, regexp: regexp.MustCompile(%q), reverse: %q, varsN: %v, varsR: %v"", r.template, r.regexpType, r.options, r.regexp.String(), r.reverse, r.varsN, r.varsR)
 }
 
 type routeTest struct {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=512169e5d707b96d6306216743bb7884a2b3a3c9,https://github.com/gorilla/mux/blob/512169e5d707b96d6306216743bb7884a2b3a3c9/mux_test.go
512169e5d707b96d6306216743bb7884a2b3a3c9,b228983c4834fe676912a29a822157bb3c539f16,old_test.go,,"Fri, 05 Jan 2018 18:40:59 GMT",modified,1,1,2,"@@ -681,7 +681,7 @@ func TestNewRegexp(t *testing.T) {
 	}
 
 	for pattern, paths := range tests {
-		p, _ = newRouteRegexp(pattern, false, false, false, false, false)
+		p, _ = newRouteRegexp(pattern, regexpTypePath, routeRegexpOptions{})
 		for path, result := range paths {
 			matches = p.regexp.FindStringSubmatch(path)
 			if result == nil {",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=512169e5d707b96d6306216743bb7884a2b3a3c9,https://github.com/gorilla/mux/blob/512169e5d707b96d6306216743bb7884a2b3a3c9/old_test.go
512169e5d707b96d6306216743bb7884a2b3a3c9,2b57e5627d54267a3f36775744ffd0d546c4c36b,regexp.go,,"Fri, 05 Jan 2018 18:40:59 GMT",modified,40,34,74,"@@ -14,6 +14,20 @@ import (
 	""strings""
 )
 
+type routeRegexpOptions struct {
+	strictSlash    bool
+	useEncodedPath bool
+}
+
+type regexpType int
+
+const (
+	regexpTypePath   regexpType = 0
+	regexpTypeHost   regexpType = 1
+	regexpTypePrefix regexpType = 2
+	regexpTypeQuery  regexpType = 3
+)
+
 // newRouteRegexp parses a route template and returns a routeRegexp,
 // used to match a host, a path or a query string.
 //
@@ -24,7 +38,7 @@ import (
 // Previously we accepted only Python-like identifiers for variable
 // names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that
 // name and pattern can't be empty, and names can't contain a colon.
-func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash, useEncodedPath bool) (*routeRegexp, error) {
+func newRouteRegexp(tpl string, typ regexpType, options routeRegexpOptions) (*routeRegexp, error) {
 	// Check if it is well-formed.
 	idxs, errBraces := braceIndices(tpl)
 	if errBraces != nil {
@@ -34,19 +48,18 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash,
 	template := tpl
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
-	if matchQuery {
+	if typ == regexpTypeQuery {
 		defaultPattern = "".*""
-	} else if matchHost {
+	} else if typ == regexpTypeHost {
 		defaultPattern = ""[^.]+""
-		matchPrefix = false
 	}
 	// Only match strict slash if not matching
-	if matchPrefix || matchHost || matchQuery {
-		strictSlash = false
+	if typ != regexpTypePath {
+		options.strictSlash = false
 	}
 	// Set a flag for strictSlash.
 	endSlash := false
-	if strictSlash && strings.HasSuffix(tpl, ""/"") {
+	if options.strictSlash && strings.HasSuffix(tpl, ""/"") {
 		tpl = tpl[:len(tpl)-1]
 		endSlash = true
 	}
@@ -88,16 +101,16 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash,
 	// Add the remaining.
 	raw := tpl[end:]
 	pattern.WriteString(regexp.QuoteMeta(raw))
-	if strictSlash {
+	if options.strictSlash {
 		pattern.WriteString(""[/]?"")
 	}
-	if matchQuery {
+	if typ == regexpTypeQuery {
 		// Add the default pattern if the query value is empty
 		if queryVal := strings.SplitN(template, ""="", 2)[1]; queryVal == """" {
 			pattern.WriteString(defaultPattern)
 		}
 	}
-	if !matchPrefix {
+	if typ != regexpTypePrefix {
 		pattern.WriteByte('$')
 	}
 	reverse.WriteString(raw)
@@ -118,15 +131,13 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash,
 
 	// Done!
 	return &routeRegexp{
-		template:       template,
-		matchHost:      matchHost,
-		matchQuery:     matchQuery,
-		strictSlash:    strictSlash,
-		useEncodedPath: useEncodedPath,
-		regexp:         reg,
-		reverse:        reverse.String(),
-		varsN:          varsN,
-		varsR:          varsR,
+		template:   template,
+		regexpType: typ,
+		options:    options,
+		regexp:     reg,
+		reverse:    reverse.String(),
+		varsN:      varsN,
+		varsR:      varsR,
 	}, nil
 }
 
@@ -135,15 +146,10 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash,
 type routeRegexp struct {
 	// The unmodified template.
 	template string
-	// True for host match, false for path or query string match.
-	matchHost bool
-	// True for query string match, false for path and host match.
-	matchQuery bool
-	// The strictSlash value defined on the route, but disabled if PathPrefix was used.
-	strictSlash bool
-	// Determines whether to use encoded req.URL.EnscapedPath() or unencoded
-	// req.URL.Path for path matching
-	useEncodedPath bool
+	// The type of match
+	regexpType regexpType
+	// Options for matching
+	options routeRegexpOptions
 	// Expanded regexp.
 	regexp *regexp.Regexp
 	// Reverse template.
@@ -156,12 +162,12 @@ type routeRegexp struct {
 
 // Match matches the regexp against the URL host or path.
 func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
-	if !r.matchHost {
-		if r.matchQuery {
+	if r.regexpType != regexpTypeHost {
+		if r.regexpType == regexpTypeQuery {
 			return r.matchQueryString(req)
 		}
 		path := req.URL.Path
-		if r.useEncodedPath {
+		if r.options.useEncodedPath {
 			path = req.URL.EscapedPath()
 		}
 		return r.regexp.MatchString(path)
@@ -178,7 +184,7 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 		if !ok {
 			return """", fmt.Errorf(""mux: missing route variable %q"", v)
 		}
-		if r.matchQuery {
+		if r.regexpType == regexpTypeQuery {
 			value = url.QueryEscape(value)
 		}
 		urlValues[k] = value
@@ -203,7 +209,7 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 // For a URL with foo=bar&baz=ding, we return only the relevant key
 // value pair for the routeRegexp.
 func (r *routeRegexp) getURLQuery(req *http.Request) string {
-	if !r.matchQuery {
+	if r.regexpType != regexpTypeQuery {
 		return """"
 	}
 	templateKey := strings.SplitN(r.template, ""="", 2)[0]
@@ -280,7 +286,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 		if len(matches) > 0 {
 			extractVars(path, matches, v.path.varsN, m.Vars)
 			// Check if we should redirect.
-			if v.path.strictSlash {
+			if v.path.options.strictSlash {
 				p1 := strings.HasSuffix(path, ""/"")
 				p2 := strings.HasSuffix(v.path.template, ""/"")
 				if p1 != p2 {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=512169e5d707b96d6306216743bb7884a2b3a3c9,https://github.com/gorilla/mux/blob/512169e5d707b96d6306216743bb7884a2b3a3c9/regexp.go
512169e5d707b96d6306216743bb7884a2b3a3c9,4ce098d4fbf03c0822149cac25e9551d026d1b42,route.go,,"Fri, 05 Jan 2018 18:40:59 GMT",modified,12,9,21,"@@ -171,20 +171,23 @@ func (r *Route) addMatcher(m matcher) *Route {
 }
 
 // addRegexpMatcher adds a host or path matcher and builder to a route.
-func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery bool) error {
+func (r *Route) addRegexpMatcher(tpl string, typ regexpType) error {
 	if r.err != nil {
 		return r.err
 	}
 	r.regexp = r.getRegexpGroup()
-	if !matchHost && !matchQuery {
+	if typ == regexpTypePath || typ == regexpTypePrefix {
 		if len(tpl) > 0 && tpl[0] != '/' {
 			return fmt.Errorf(""mux: path must start with a slash, got %q"", tpl)
 		}
 		if r.regexp.path != nil {
 			tpl = strings.TrimRight(r.regexp.path.template, ""/"") + tpl
 		}
 	}
-	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, matchQuery, r.strictSlash, r.useEncodedPath)
+	rr, err := newRouteRegexp(tpl, typ, routeRegexpOptions{
+		strictSlash:    r.strictSlash,
+		useEncodedPath: r.useEncodedPath,
+	})
 	if err != nil {
 		return err
 	}
@@ -193,7 +196,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 			return err
 		}
 	}
-	if matchHost {
+	if typ == regexpTypeHost {
 		if r.regexp.path != nil {
 			if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
 				return err
@@ -206,7 +209,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 				return err
 			}
 		}
-		if matchQuery {
+		if typ == regexpTypeQuery {
 			r.regexp.queries = append(r.regexp.queries, rr)
 		} else {
 			r.regexp.path = rr
@@ -289,7 +292,7 @@ func (r *Route) HeadersRegexp(pairs ...string) *Route {
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
 func (r *Route) Host(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, true, false, false)
+	r.err = r.addRegexpMatcher(tpl, regexpTypeHost)
 	return r
 }
 
@@ -349,7 +352,7 @@ func (r *Route) Methods(methods ...string) *Route {
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
 func (r *Route) Path(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, false, false, false)
+	r.err = r.addRegexpMatcher(tpl, regexpTypePath)
 	return r
 }
 
@@ -365,7 +368,7 @@ func (r *Route) Path(tpl string) *Route {
 // Also note that the setting of Router.StrictSlash() has no effect on routes
 // with a PathPrefix matcher.
 func (r *Route) PathPrefix(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, false, true, false)
+	r.err = r.addRegexpMatcher(tpl, regexpTypePrefix)
 	return r
 }
 
@@ -396,7 +399,7 @@ func (r *Route) Queries(pairs ...string) *Route {
 		return nil
 	}
 	for i := 0; i < length; i += 2 {
-		if r.err = r.addRegexpMatcher(pairs[i]+""=""+pairs[i+1], false, false, true); r.err != nil {
+		if r.err = r.addRegexpMatcher(pairs[i]+""=""+pairs[i+1], regexpTypeQuery); r.err != nil {
 			return r
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=512169e5d707b96d6306216743bb7884a2b3a3c9,https://github.com/gorilla/mux/blob/512169e5d707b96d6306216743bb7884a2b3a3c9/route.go
5ab525f4fb1678e197ae59401e9050fa0b6cb5fd,8b2c4a4c580e09c2b127e0c3ee54dc5fa6eb5d4b,test_helpers.go,,"Fri, 08 Dec 2017 16:08:15 GMT",added,18,0,18,"@@ -0,0 +1,18 @@
+// Copyright 2012 The Gorilla Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mux
+
+import ""net/http""
+
+// SetURLVars sets the URL variables for the given request, to be accessed via
+// mux.Vars for testing route behaviour.
+//
+// This API should only be used for testing purposes; it provides a way to
+// inject variables into the request context. Alternatively, URL variables
+// can be set by making a route that captures the required variables,
+// starting a server and sending the request to that server.
+func SetURLVars(r *http.Request, val map[string]string) *http.Request {
+	return setVars(r, val)
+}",https://api.github.com/repos/gorilla/mux/contents/test_helpers.go?ref=5ab525f4fb1678e197ae59401e9050fa0b6cb5fd,https://github.com/gorilla/mux/blob/5ab525f4fb1678e197ae59401e9050fa0b6cb5fd/test_helpers.go
7904d2e42e7ebbdb4a6eb3e57eb201b11df25c57,1125570713e6a15ab99579834150c648d017c9a0,example_route_test.go,,"Mon, 04 Dec 2017 16:11:14 GMT",added,51,0,51,"@@ -0,0 +1,51 @@
+package mux_test
+
+import (
+	""fmt""
+	""net/http""
+
+	""github.com/gorilla/mux""
+)
+
+// This example demonstrates setting a regular expression matcher for
+// the header value. A plain word will match any value that contains a
+// matching substring as if the pattern was wrapped with `.*`.
+func ExampleRoute_HeadersRegexp() {
+	r := mux.NewRouter()
+	route := r.NewRoute().HeadersRegexp(""Accept"", ""html"")
+
+	req1, _ := http.NewRequest(""GET"", ""example.com"", nil)
+	req1.Header.Add(""Accept"", ""text/plain"")
+	req1.Header.Add(""Accept"", ""text/html"")
+
+	req2, _ := http.NewRequest(""GET"", ""example.com"", nil)
+	req2.Header.Set(""Accept"", ""application/xhtml+xml"")
+
+	matchInfo := &mux.RouteMatch{}
+	fmt.Printf(""Match: %v %q\n"", route.Match(req1, matchInfo), req1.Header[""Accept""])
+	fmt.Printf(""Match: %v %q\n"", route.Match(req2, matchInfo), req2.Header[""Accept""])
+	// Output:
+	// Match: true [""text/plain"" ""text/html""]
+	// Match: true [""application/xhtml+xml""]
+}
+
+// This example demonstrates setting a strict regular expression matcher
+// for the header value. Using the start and end of string anchors, the
+// value must be an exact match.
+func ExampleRoute_HeadersRegexp_exactMatch() {
+	r := mux.NewRouter()
+	route := r.NewRoute().HeadersRegexp(""Origin"", ""^https://example.co$"")
+
+	yes, _ := http.NewRequest(""GET"", ""example.co"", nil)
+	yes.Header.Set(""Origin"", ""https://example.co"")
+
+	no, _ := http.NewRequest(""GET"", ""example.co.uk"", nil)
+	no.Header.Set(""Origin"", ""https://example.co.uk"")
+
+	matchInfo := &mux.RouteMatch{}
+	fmt.Printf(""Match: %v %q\n"", route.Match(yes, matchInfo), yes.Header[""Origin""])
+	fmt.Printf(""Match: %v %q\n"", route.Match(no, matchInfo), no.Header[""Origin""])
+	// Output:
+	// Match: true [""https://example.co""]
+	// Match: false [""https://example.co.uk""]
+}",https://api.github.com/repos/gorilla/mux/contents/example_route_test.go?ref=7904d2e42e7ebbdb4a6eb3e57eb201b11df25c57,https://github.com/gorilla/mux/blob/7904d2e42e7ebbdb4a6eb3e57eb201b11df25c57/example_route_test.go
7904d2e42e7ebbdb4a6eb3e57eb201b11df25c57,d0a71a9266c24af831443461d69f9b9ea38e02ac,route.go,,"Mon, 04 Dec 2017 16:11:14 GMT",modified,2,1,3,"@@ -258,7 +258,8 @@ func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
 //               ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both the request header matches both regular expressions.
-// It the value is an empty string, it will match any value if the key is set.
+// If the value is an empty string, it will match any value if the key is set.
+// Use the start and end of string anchors (^ and $) to match an exact value.
 func (r *Route) HeadersRegexp(pairs ...string) *Route {
 	if r.err == nil {
 		var headers map[string]*regexp.Regexp",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=7904d2e42e7ebbdb4a6eb3e57eb201b11df25c57,https://github.com/gorilla/mux/blob/7904d2e42e7ebbdb4a6eb3e57eb201b11df25c57/route.go
c572efe4294d5a0e354e01f2ddaa8b1f0c3cb3dd,5fd5fa83f4a8f1f29acf1ef17d05ebb55d30d786,mux.go,,"Sat, 02 Dec 2017 20:38:52 GMT",modified,6,1,7,"@@ -164,13 +164,18 @@ func (r *Router) GetRoute(name string) *Route {
 // StrictSlash defines the trailing slash behavior for new routes. The initial
 // value is false.
 //
-// When true, if the route path is ""/path/"", accessing ""/path"" will redirect
+// When true, if the route path is ""/path/"", accessing ""/path"" will perform a redirect
 // to the former and vice versa. In other words, your application will always
 // see the path as specified in the route.
 //
 // When false, if the route path is ""/path"", accessing ""/path/"" will not match
 // this route and vice versa.
 //
+// The re-direct is a HTTP 301 (Moved Permanently). Note that when this is set for
+// routes with a non-idempotent method (e.g. POST, PUT), the subsequent re-directed
+// request will be made as a GET by most clients. Use middleware or client settings
+// to modify this behaviour as needed.
+//
 // Special case: when a route sets a path prefix using the PathPrefix() method,
 // strict slash is ignored for that route because the redirect behavior can't
 // be determined from a prefix alone. However, any subrouters created from that",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=c572efe4294d5a0e354e01f2ddaa8b1f0c3cb3dd,https://github.com/gorilla/mux/blob/c572efe4294d5a0e354e01f2ddaa8b1f0c3cb3dd/mux.go
65ec7248c53f499f6b480655e019e0b9d7a6ce11,232be82e47a6abe7fbf9e73ccadde10b3022264c,ISSUE_TEMPLATE.md,,"Wed, 29 Nov 2017 00:00:09 GMT",added,11,0,11,"@@ -0,0 +1,11 @@
+**What version of Go are you running?** (Paste the output of `go version`)
+
+
+**What version of gorilla/mux are you at?** (Paste the output of `git rev-parse HEAD` inside `$GOPATH/src/github.com/gorilla/mux`)
+
+
+**Describe your problem** (and what you have tried so far)
+
+
+**Paste a minimal, runnable, reproduction of your issue below** (use backticks to format it)
+",https://api.github.com/repos/gorilla/mux/contents/ISSUE_TEMPLATE.md?ref=65ec7248c53f499f6b480655e019e0b9d7a6ce11,https://github.com/gorilla/mux/blob/65ec7248c53f499f6b480655e019e0b9d7a6ce11/ISSUE_TEMPLATE.md
4a3d4f3dd2a7b32b26dc262a143440e75767f94d,c39cb86a33f07238ff15a40a6b4411bf48003a0d,mux_test.go,,"Tue, 28 Nov 2017 19:51:17 GMT",modified,312,0,312,"@@ -1967,6 +1967,318 @@ func TestErrMatchNotFound(t *testing.T) {
 	}
 }
 
+// methodsSubrouterTest models the data necessary for testing handler
+// matching for subrouters created after HTTP methods matcher registration.
+type methodsSubrouterTest struct {
+	title    string
+	wantCode int
+	router   *Router
+	// method is the input into the request and expected response
+	method string
+	// input request path
+	path string
+	// redirectTo is the expected location path for strict-slash matches
+	redirectTo string
+}
+
+// methodHandler writes the method string in response.
+func methodHandler(method string) http.HandlerFunc {
+	return func(w http.ResponseWriter, r *http.Request) {
+		w.Write([]byte(method))
+	}
+}
+
+// TestMethodsSubrouterCatchall matches handlers for subrouters where a
+// catchall handler is set for a mis-matching method.
+func TestMethodsSubrouterCatchall(t *testing.T) {
+	t.Parallel()
+
+	router := NewRouter()
+	router.Methods(""PATCH"").Subrouter().PathPrefix(""/"").HandlerFunc(methodHandler(""PUT""))
+	router.Methods(""GET"").Subrouter().HandleFunc(""/foo"", methodHandler(""GET""))
+	router.Methods(""POST"").Subrouter().HandleFunc(""/foo"", methodHandler(""POST""))
+	router.Methods(""DELETE"").Subrouter().HandleFunc(""/foo"", methodHandler(""DELETE""))
+
+	tests := []methodsSubrouterTest{
+		{
+			title:    ""match GET handler"",
+			router:   router,
+			path:     ""http://localhost/foo"",
+			method:   ""GET"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match POST handler"",
+			router:   router,
+			method:   ""POST"",
+			path:     ""http://localhost/foo"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match DELETE handler"",
+			router:   router,
+			method:   ""DELETE"",
+			path:     ""http://localhost/foo"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""disallow PUT method"",
+			router:   router,
+			method:   ""PUT"",
+			path:     ""http://localhost/foo"",
+			wantCode: http.StatusMethodNotAllowed,
+		},
+	}
+
+	for _, test := range tests {
+		testMethodsSubrouter(t, test)
+	}
+}
+
+// TestMethodsSubrouterStrictSlash matches handlers on subrouters with
+// strict-slash matchers.
+func TestMethodsSubrouterStrictSlash(t *testing.T) {
+	t.Parallel()
+
+	router := NewRouter()
+	sub := router.PathPrefix(""/"").Subrouter()
+	sub.StrictSlash(true).Path(""/foo"").Methods(""GET"").Subrouter().HandleFunc("""", methodHandler(""GET""))
+	sub.StrictSlash(true).Path(""/foo/"").Methods(""PUT"").Subrouter().HandleFunc(""/"", methodHandler(""PUT""))
+	sub.StrictSlash(true).Path(""/foo/"").Methods(""POST"").Subrouter().HandleFunc(""/"", methodHandler(""POST""))
+
+	tests := []methodsSubrouterTest{
+		{
+			title:    ""match POST handler"",
+			router:   router,
+			method:   ""POST"",
+			path:     ""http://localhost/foo/"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match GET handler"",
+			router:   router,
+			method:   ""GET"",
+			path:     ""http://localhost/foo"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:      ""match POST handler, redirect strict-slash"",
+			router:     router,
+			method:     ""POST"",
+			path:       ""http://localhost/foo"",
+			redirectTo: ""http://localhost/foo/"",
+			wantCode:   http.StatusMovedPermanently,
+		},
+		{
+			title:      ""match GET handler, redirect strict-slash"",
+			router:     router,
+			method:     ""GET"",
+			path:       ""http://localhost/foo/"",
+			redirectTo: ""http://localhost/foo"",
+			wantCode:   http.StatusMovedPermanently,
+		},
+		{
+			title:    ""disallow DELETE method"",
+			router:   router,
+			method:   ""DELETE"",
+			path:     ""http://localhost/foo"",
+			wantCode: http.StatusMethodNotAllowed,
+		},
+	}
+
+	for _, test := range tests {
+		testMethodsSubrouter(t, test)
+	}
+}
+
+// TestMethodsSubrouterPathPrefix matches handlers on subrouters created
+// on a router with a path prefix matcher and method matcher.
+func TestMethodsSubrouterPathPrefix(t *testing.T) {
+	t.Parallel()
+
+	router := NewRouter()
+	router.PathPrefix(""/1"").Methods(""POST"").Subrouter().HandleFunc(""/2"", methodHandler(""POST""))
+	router.PathPrefix(""/1"").Methods(""DELETE"").Subrouter().HandleFunc(""/2"", methodHandler(""DELETE""))
+	router.PathPrefix(""/1"").Methods(""PUT"").Subrouter().HandleFunc(""/2"", methodHandler(""PUT""))
+	router.PathPrefix(""/1"").Methods(""POST"").Subrouter().HandleFunc(""/2"", methodHandler(""POST2""))
+
+	tests := []methodsSubrouterTest{
+		{
+			title:    ""match first POST handler"",
+			router:   router,
+			method:   ""POST"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match DELETE handler"",
+			router:   router,
+			method:   ""DELETE"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match PUT handler"",
+			router:   router,
+			method:   ""PUT"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""disallow PATCH method"",
+			router:   router,
+			method:   ""PATCH"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusMethodNotAllowed,
+		},
+	}
+
+	for _, test := range tests {
+		testMethodsSubrouter(t, test)
+	}
+}
+
+// TestMethodsSubrouterSubrouter matches handlers on subrouters produced
+// from method matchers registered on a root subrouter.
+func TestMethodsSubrouterSubrouter(t *testing.T) {
+	t.Parallel()
+
+	router := NewRouter()
+	sub := router.PathPrefix(""/1"").Subrouter()
+	sub.Methods(""POST"").Subrouter().HandleFunc(""/2"", methodHandler(""POST""))
+	sub.Methods(""GET"").Subrouter().HandleFunc(""/2"", methodHandler(""GET""))
+	sub.Methods(""PATCH"").Subrouter().HandleFunc(""/2"", methodHandler(""PATCH""))
+	sub.HandleFunc(""/2"", methodHandler(""PUT"")).Subrouter().Methods(""PUT"")
+	sub.HandleFunc(""/2"", methodHandler(""POST2"")).Subrouter().Methods(""POST"")
+
+	tests := []methodsSubrouterTest{
+		{
+			title:    ""match first POST handler"",
+			router:   router,
+			method:   ""POST"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match GET handler"",
+			router:   router,
+			method:   ""GET"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match PATCH handler"",
+			router:   router,
+			method:   ""PATCH"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match PUT handler"",
+			router:   router,
+			method:   ""PUT"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""disallow DELETE method"",
+			router:   router,
+			method:   ""DELETE"",
+			path:     ""http://localhost/1/2"",
+			wantCode: http.StatusMethodNotAllowed,
+		},
+	}
+
+	for _, test := range tests {
+		testMethodsSubrouter(t, test)
+	}
+}
+
+// TestMethodsSubrouterPathVariable matches handlers on matching paths
+// with path variables in them.
+func TestMethodsSubrouterPathVariable(t *testing.T) {
+	t.Parallel()
+
+	router := NewRouter()
+	router.Methods(""GET"").Subrouter().HandleFunc(""/foo"", methodHandler(""GET""))
+	router.Methods(""POST"").Subrouter().HandleFunc(""/{any}"", methodHandler(""POST""))
+	router.Methods(""DELETE"").Subrouter().HandleFunc(""/1/{any}"", methodHandler(""DELETE""))
+	router.Methods(""PUT"").Subrouter().HandleFunc(""/1/{any}"", methodHandler(""PUT""))
+
+	tests := []methodsSubrouterTest{
+		{
+			title:    ""match GET handler"",
+			router:   router,
+			method:   ""GET"",
+			path:     ""http://localhost/foo"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match POST handler"",
+			router:   router,
+			method:   ""POST"",
+			path:     ""http://localhost/foo"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match DELETE handler"",
+			router:   router,
+			method:   ""DELETE"",
+			path:     ""http://localhost/1/foo"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""match PUT handler"",
+			router:   router,
+			method:   ""PUT"",
+			path:     ""http://localhost/1/foo"",
+			wantCode: http.StatusOK,
+		},
+		{
+			title:    ""disallow PATCH method"",
+			router:   router,
+			method:   ""PATCH"",
+			path:     ""http://localhost/1/foo"",
+			wantCode: http.StatusMethodNotAllowed,
+		},
+	}
+
+	for _, test := range tests {
+		testMethodsSubrouter(t, test)
+	}
+}
+
+// testMethodsSubrouter runs an individual methodsSubrouterTest.
+func testMethodsSubrouter(t *testing.T, test methodsSubrouterTest) {
+	// Execute request
+	req, _ := http.NewRequest(test.method, test.path, nil)
+	resp := NewRecorder()
+	test.router.ServeHTTP(resp, req)
+
+	switch test.wantCode {
+	case http.StatusMethodNotAllowed:
+		if resp.Code != http.StatusMethodNotAllowed {
+			t.Errorf(`(%s) Expected ""405 Method Not Allowed"", but got %d code`, test.title, resp.Code)
+		} else if matchedMethod := resp.Body.String(); matchedMethod != """" {
+			t.Errorf(`(%s) Expected ""405 Method Not Allowed"", but %q handler was called`, test.title, matchedMethod)
+		}
+
+	case http.StatusMovedPermanently:
+		if gotLocation := resp.HeaderMap.Get(""Location""); gotLocation != test.redirectTo {
+			t.Errorf(""(%s) Expected %q route-match to redirect to %q, but got %q"", test.title, test.method, test.redirectTo, gotLocation)
+		}
+
+	case http.StatusOK:
+		if matchedMethod := resp.Body.String(); matchedMethod != test.method {
+			t.Errorf(""(%s) Expected %q handler to be called, but %q handler was called"", test.title, test.method, matchedMethod)
+		}
+
+	default:
+		expectedCodes := []int{http.StatusMethodNotAllowed, http.StatusMovedPermanently, http.StatusOK}
+		t.Errorf(""(%s) Expected wantCode to be one of: %v, but got %d"", test.title, expectedCodes, test.wantCode)
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=4a3d4f3dd2a7b32b26dc262a143440e75767f94d,https://github.com/gorilla/mux/blob/4a3d4f3dd2a7b32b26dc262a143440e75767f94d/mux_test.go
4a3d4f3dd2a7b32b26dc262a143440e75767f94d,2b3de8bf4be06f3d69da2a83f479bcb563ac4796,route.go,,"Tue, 28 Nov 2017 19:51:17 GMT",modified,2,0,2,"@@ -75,6 +75,8 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if match.MatchErr == ErrMethodMismatch {
 		// We found a route which matches request method, clear MatchErr
 		match.MatchErr = nil
+		// Then override the mis-matched handler
+		match.Handler = r.handler
 	}
 
 	// Yay, we have a match. Let's collect some info about it.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=4a3d4f3dd2a7b32b26dc262a143440e75767f94d,https://github.com/gorilla/mux/blob/4a3d4f3dd2a7b32b26dc262a143440e75767f94d/route.go
2d5fef06b891c971b14aa6f71ca5ab6c03a36e0e,9aec0face8b57de6bdd48579ee9b99bcc60209fa,mux.go,,"Thu, 09 Nov 2017 03:54:02 GMT",modified,0,4,4,"@@ -196,10 +196,6 @@ func (r *Router) SkipClean(value bool) *Router {
 // UseEncodedPath tells the router to match the encoded original path
 // to the routes.
 // For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to"".
-// This behavior has the drawback of needing to match routes against
-// r.RequestURI instead of r.URL.Path. Any modifications (such as http.StripPrefix)
-// to r.URL.Path will not affect routing when this flag is on and thus may
-// induce unintended behavior.
 //
 // If not called, the router will match the unencoded path to the routes.
 // For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/foo/bar/to""",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=2d5fef06b891c971b14aa6f71ca5ab6c03a36e0e,https://github.com/gorilla/mux/blob/2d5fef06b891c971b14aa6f71ca5ab6c03a36e0e/mux.go
7f08801859139f86dfafd1c296e2cba9a80d292e,49de7892365446069776ae0644145aff8d937d45,mux.go,,"Sun, 05 Nov 2017 17:23:20 GMT",modified,11,3,14,"@@ -14,6 +14,7 @@ import (
 
 var (
 	ErrMethodMismatch = errors.New(""method is not allowed"")
+	ErrNotFound       = errors.New(""no matching route was found"")
 )
 
 // NewRouter returns a new router instance.
@@ -82,16 +83,23 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 		}
 	}
 
-	if match.MatchErr == ErrMethodMismatch && r.MethodNotAllowedHandler != nil {
-		match.Handler = r.MethodNotAllowedHandler
-		return true
+	if match.MatchErr == ErrMethodMismatch {
+		if r.MethodNotAllowedHandler != nil {
+			match.Handler = r.MethodNotAllowedHandler
+			return true
+		} else {
+			return false
+		}
 	}
 
 	// Closest match for a router (includes sub-routers)
 	if r.NotFoundHandler != nil {
 		match.Handler = r.NotFoundHandler
+		match.MatchErr = ErrNotFound
 		return true
 	}
+
+	match.MatchErr = ErrNotFound
 	return false
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=7f08801859139f86dfafd1c296e2cba9a80d292e,https://github.com/gorilla/mux/blob/7f08801859139f86dfafd1c296e2cba9a80d292e/mux.go
7f08801859139f86dfafd1c296e2cba9a80d292e,6c7e30d1917037eaa66df6c40f79a686f4980808,mux_test.go,,"Sun, 05 Nov 2017 17:23:20 GMT",modified,90,39,129,"@@ -1877,6 +1877,96 @@ func TestSubrouterHeader(t *testing.T) {
 	}
 }
 
+func TestNoMatchMethodErrorHandler(t *testing.T) {
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/"", func1).Methods(""GET"", ""POST"")
+
+	req, _ := http.NewRequest(""PUT"", ""http://localhost/"", nil)
+	match := new(RouteMatch)
+	matched := r.Match(req, match)
+
+	if matched {
+		t.Error(""Should not have matched route for methods"")
+	}
+
+	if match.MatchErr != ErrMethodMismatch {
+		t.Error(""Should get ErrMethodMismatch error"")
+	}
+
+	resp := NewRecorder()
+	r.ServeHTTP(resp, req)
+	if resp.Code != 405 {
+		t.Errorf(""Expecting code %v"", 405)
+	}
+
+	// Add matching route
+	r.HandleFunc(""/"", func1).Methods(""PUT"")
+
+	match = new(RouteMatch)
+	matched = r.Match(req, match)
+
+	if !matched {
+		t.Error(""Should have matched route for methods"")
+	}
+
+	if match.MatchErr != nil {
+		t.Error(""Should not have any matching error. Found:"", match.MatchErr)
+	}
+}
+
+func TestErrMatchNotFound(t *testing.T) {
+	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/"", emptyHandler)
+	s := r.PathPrefix(""/sub/"").Subrouter()
+	s.HandleFunc(""/"", emptyHandler)
+
+	// Regular 404 not found
+	req, _ := http.NewRequest(""GET"", ""/sub/whatever"", nil)
+	match := new(RouteMatch)
+	matched := r.Match(req, match)
+
+	if matched {
+		t.Errorf(""Subrouter should not have matched that, got %v"", match.Route)
+	}
+	// Even without a custom handler, MatchErr is set to ErrNotFound
+	if match.MatchErr != ErrNotFound {
+		t.Errorf(""Expected ErrNotFound MatchErr, but was %v"", match.MatchErr)
+	}
+
+	// Now lets add a 404 handler to subrouter
+	s.NotFoundHandler = http.NotFoundHandler()
+	req, _ = http.NewRequest(""GET"", ""/sub/whatever"", nil)
+
+	// Test the subrouter first
+	match = new(RouteMatch)
+	matched = s.Match(req, match)
+	// Now we should get a match
+	if !matched {
+		t.Errorf(""Subrouter should have matched %s"", req.RequestURI)
+	}
+	// But MatchErr should be set to ErrNotFound anyway
+	if match.MatchErr != ErrNotFound {
+		t.Errorf(""Expected ErrNotFound MatchErr, but was %v"", match.MatchErr)
+	}
+
+	// Now test the parent (MatchErr should propagate)
+	match = new(RouteMatch)
+	matched = r.Match(req, match)
+
+	// Now we should get a match
+	if !matched {
+		t.Errorf(""Router should have matched %s via subrouter"", req.RequestURI)
+	}
+	// But MatchErr should be set to ErrNotFound anyway
+	if match.MatchErr != ErrNotFound {
+		t.Errorf(""Expected ErrNotFound MatchErr, but was %v"", match.MatchErr)
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int
@@ -1943,42 +2033,3 @@ func newRequest(method, url string) *http.Request {
 	}
 	return req
 }
-
-func TestNoMatchMethodErrorHandler(t *testing.T) {
-	func1 := func(w http.ResponseWriter, r *http.Request) {}
-
-	r := NewRouter()
-	r.HandleFunc(""/"", func1).Methods(""GET"", ""POST"")
-
-	req, _ := http.NewRequest(""PUT"", ""http://localhost/"", nil)
-	match := new(RouteMatch)
-	matched := r.Match(req, match)
-
-	if matched {
-		t.Error(""Should not have matched route for methods"")
-	}
-
-	if match.MatchErr != ErrMethodMismatch {
-		t.Error(""Should get ErrMethodMismatch error"")
-	}
-
-	resp := NewRecorder()
-	r.ServeHTTP(resp, req)
-	if resp.Code != 405 {
-		t.Errorf(""Expecting code %v"", 405)
-	}
-
-	// Add matching route
-	r.HandleFunc(""/"", func1).Methods(""PUT"")
-
-	match = new(RouteMatch)
-	matched = r.Match(req, match)
-
-	if !matched {
-		t.Error(""Should have matched route for methods"")
-	}
-
-	if match.MatchErr != nil {
-		t.Error(""Should not have any matching error. Found:"", match.MatchErr)
-	}
-}",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=7f08801859139f86dfafd1c296e2cba9a80d292e,https://github.com/gorilla/mux/blob/7f08801859139f86dfafd1c296e2cba9a80d292e/mux_test.go
7f08801859139f86dfafd1c296e2cba9a80d292e,69aeae791af28e65abe298e29de3d29e8719897e,route.go,,"Sun, 05 Nov 2017 17:23:20 GMT",modified,5,1,6,"@@ -72,7 +72,11 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 		return false
 	}
 
-	match.MatchErr = nil
+	if match.MatchErr == ErrMethodMismatch {
+		// We found a route which matches request method, clear MatchErr
+		match.MatchErr = nil
+	}
+
 	// Yay, we have a match. Let's collect some info about it.
 	if match.Route == nil {
 		match.Route = r",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=7f08801859139f86dfafd1c296e2cba9a80d292e,https://github.com/gorilla/mux/blob/7f08801859139f86dfafd1c296e2cba9a80d292e/route.go
9f48112f18a17f59ef17cfd7eea0d8c955504ebc,a0d55e56b38da6d4cfc6c8d8484e3853124bf5b2,mux.go,,"Sun, 05 Nov 2017 04:08:26 GMT",modified,11,1,12,"@@ -64,7 +64,17 @@ type Router struct {
 	useEncodedPath bool
 }
 
-// Match matches registered routes against the request.
+// Match attempts to match the given request against the router's registered routes.
+//
+// If the request matches a route of this router or one of its subrouters the Route,
+// Handler, and Vars fields of the the match argument are filled and this function
+// returns true.
+//
+// If the request does not match any of this router's or its subrouters' routes
+// then this function returns false. If available, a reason for the match failure
+// will be filled in the match argument's MatchErr field. If the match failure type
+// (eg: not found) has a registered handler, the handler is assigned to the Handler
+// field of the match argument.
 func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 	for _, route := range r.routes {
 		if route.Match(req, match) {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=9f48112f18a17f59ef17cfd7eea0d8c955504ebc,https://github.com/gorilla/mux/blob/9f48112f18a17f59ef17cfd7eea0d8c955504ebc/mux.go
bc452d92e321dc63d7b1190f9627ecd950ef1899,3302233f3c37250ce23e3c984b003af79de2e0e3,.travis.yml,,"Sat, 04 Nov 2017 20:51:27 GMT",modified,2,0,2,"@@ -9,6 +9,8 @@ matrix:
     - go: 1.8
     - go: 1.9
     - go: tip
+  allow_failures:
+    - go: tip
 
 install:
   - # Skip",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=bc452d92e321dc63d7b1190f9627ecd950ef1899,https://github.com/gorilla/mux/blob/bc452d92e321dc63d7b1190f9627ecd950ef1899/.travis.yml
7625a85c14e615274a4ee4bc8654f72310a563e4,a319fdc417976be28da619aef34447e0d06e0746,.travis.yml,,"Fri, 20 Oct 2017 03:47:00 GMT",modified,0,3,3,"@@ -3,9 +3,6 @@ sudo: false
 
 matrix:
   include:
-    - go: 1.2
-    - go: 1.3
-    - go: 1.4
     - go: 1.5
     - go: 1.6
     - go: 1.7",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=7625a85c14e615274a4ee4bc8654f72310a563e4,https://github.com/gorilla/mux/blob/7625a85c14e615274a4ee4bc8654f72310a563e4/.travis.yml
c9183aaddd2672bdebcc2d2192ed9c788b4af1e8,cf4ac54b223e451ae6191886b6491142c106a74a,mux.go,,"Fri, 20 Oct 2017 03:46:20 GMT",modified,1,24,25,"@@ -10,7 +10,6 @@ import (
 	""net/http""
 	""path""
 	""regexp""
-	""strings""
 )
 
 var (
@@ -94,7 +93,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	if !r.skipClean {
 		path := req.URL.Path
 		if r.useEncodedPath {
-			path = getPath(req)
+			path = req.URL.EscapedPath()
 		}
 		// Clean path to canonical form and redirect.
 		if p := cleanPath(path); p != path {
@@ -409,28 +408,6 @@ func setCurrentRoute(r *http.Request, val interface{}) *http.Request {
 // Helpers
 // ----------------------------------------------------------------------------
 
-// getPath returns the escaped path if possible; doing what URL.EscapedPath()
-// which was added in go1.5 does
-func getPath(req *http.Request) string {
-	if req.RequestURI != """" {
-		// Extract the path from RequestURI (which is escaped unlike URL.Path)
-		// as detailed here as detailed in https://golang.org/pkg/net/url/#URL
-		// for < 1.5 server side workaround
-		// http://localhost/path/here?v=1 -> /path/here
-		path := req.RequestURI
-		path = strings.TrimPrefix(path, req.URL.Scheme+`://`)
-		path = strings.TrimPrefix(path, req.URL.Host)
-		if i := strings.LastIndex(path, ""?""); i > -1 {
-			path = path[:i]
-		}
-		if i := strings.LastIndex(path, ""#""); i > -1 {
-			path = path[:i]
-		}
-		return path
-	}
-	return req.URL.Path
-}
-
 // cleanPath returns the canonical path for p, eliminating . and .. elements.
 // Borrowed from the net/http package.
 func cleanPath(p string) string {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=c9183aaddd2672bdebcc2d2192ed9c788b4af1e8,https://github.com/gorilla/mux/blob/c9183aaddd2672bdebcc2d2192ed9c788b4af1e8/mux.go
c9183aaddd2672bdebcc2d2192ed9c788b4af1e8,e83213b7dff501fc109cd14a895c2c698b9605d3,regexp.go,,"Fri, 20 Oct 2017 03:46:20 GMT",modified,3,3,6,"@@ -141,7 +141,7 @@ type routeRegexp struct {
 	matchQuery bool
 	// The strictSlash value defined on the route, but disabled if PathPrefix was used.
 	strictSlash bool
-	// Determines whether to use encoded path from getPath function or unencoded
+	// Determines whether to use encoded req.URL.EnscapedPath() or unencoded
 	// req.URL.Path for path matching
 	useEncodedPath bool
 	// Expanded regexp.
@@ -162,7 +162,7 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 		}
 		path := req.URL.Path
 		if r.useEncodedPath {
-			path = getPath(req)
+			path = req.URL.EscapedPath()
 		}
 		return r.regexp.MatchString(path)
 	}
@@ -272,7 +272,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	}
 	path := req.URL.Path
 	if r.useEncodedPath {
-		path = getPath(req)
+		path = req.URL.EscapedPath()
 	}
 	// Store path variables.
 	if v.path != nil {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=c9183aaddd2672bdebcc2d2192ed9c788b4af1e8,https://github.com/gorilla/mux/blob/c9183aaddd2672bdebcc2d2192ed9c788b4af1e8/regexp.go
10490f55fae320638e3418054ae58b3ab0ec2e98,67a79e00afcb3278482ae078cf59fe102554117e,README.md,,"Fri, 20 Oct 2017 01:19:04 GMT",modified,26,2,28,"@@ -201,22 +201,34 @@ func main() {
     r.HandleFunc(""/products"", handler).Methods(""POST"")
     r.HandleFunc(""/articles"", handler).Methods(""GET"")
     r.HandleFunc(""/articles/{id}"", handler).Methods(""GET"", ""PUT"")
+    r.HandleFunc(""/authors"", handler).Queries(""surname"", ""{surname}"")
     r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
         t, err := route.GetPathTemplate()
         if err != nil {
             return err
         }
+        qt, err := route.GetQueriesTemplates()
+        if err != nil {
+            return err
+        }
         // p will contain regular expression is compatible with regular expression in Perl, Python, and other languages.
         // for instance the regular expression for path '/articles/{id}' will be '^/articles/(?P<v0>[^/]+)$'
         p, err := route.GetPathRegexp()
         if err != nil {
             return err
         }
+        // qr will contain a list of regular expressions with the same semantics as GetPathRegexp,
+        // just applied to the Queries pairs instead, e.g., 'Queries(""surname"", ""{surname}"") will return
+        // {""^surname=(?P<v0>.*)$}. Where each combined query pair will have an entry in the list.
+        qr, err := route.GetQueriesRegexp()
+        if err != nil {
+            return err
+        }
         m, err := route.GetMethods()
         if err != nil {
             return err
         }
-        fmt.Println(strings.Join(m, "",""), t, p)
+        fmt.Println(strings.Join(m, "",""), strings.Join(qt, "",""), strings.Join(qr, "",""), t, p)
         return nil
     })
     http.Handle(""/"", r)
@@ -339,22 +351,34 @@ r.HandleFunc(""/"", handler)
 r.HandleFunc(""/products"", handler).Methods(""POST"")
 r.HandleFunc(""/articles"", handler).Methods(""GET"")
 r.HandleFunc(""/articles/{id}"", handler).Methods(""GET"", ""PUT"")
+r.HandleFunc(""/authors"", handler).Queries(""surname"", ""{surname}"")
 r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
     t, err := route.GetPathTemplate()
     if err != nil {
         return err
     }
+    qt, err := route.GetQueriesTemplates()
+    if err != nil {
+        return err
+    }
     // p will contain a regular expression that is compatible with regular expressions in Perl, Python, and other languages.
     // For example, the regular expression for path '/articles/{id}' will be '^/articles/(?P<v0>[^/]+)$'.
     p, err := route.GetPathRegexp()
     if err != nil {
         return err
     }
+    // qr will contain a list of regular expressions with the same semantics as GetPathRegexp,
+    // just applied to the Queries pairs instead, e.g., 'Queries(""surname"", ""{surname}"") will return
+    // {""^surname=(?P<v0>.*)$}. Where each combined query pair will have an entry in the list.
+    qr, err := route.GetQueriesRegexp()
+    if err != nil {
+        return err
+    }
     m, err := route.GetMethods()
     if err != nil {
         return err
     }
-    fmt.Println(strings.Join(m, "",""), t, p)
+    fmt.Println(strings.Join(m, "",""), strings.Join(qt, "",""), strings.Join(qr, "",""), t, p)
     return nil
 })
 ```",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=10490f55fae320638e3418054ae58b3ab0ec2e98,https://github.com/gorilla/mux/blob/10490f55fae320638e3418054ae58b3ab0ec2e98/README.md
10490f55fae320638e3418054ae58b3ab0ec2e98,6c7f83d12436be4e05157a195504d7668546100f,mux_test.go,,"Fri, 20 Oct 2017 01:19:04 GMT",modified,330,258,588,"@@ -29,20 +29,22 @@ func (r *routeRegexp) GoString() string {
 }
 
 type routeTest struct {
-	title          string            // title of the test
-	route          *Route            // the route being tested
-	request        *http.Request     // a request to test the route
-	vars           map[string]string // the expected vars of the match
-	scheme         string            // the expected scheme of the built URL
-	host           string            // the expected host of the built URL
-	path           string            // the expected path of the built URL
-	query          string            // the expected query string of the built URL
-	pathTemplate   string            // the expected path template of the route
-	hostTemplate   string            // the expected host template of the route
-	methods        []string          // the expected route methods
-	pathRegexp     string            // the expected path regexp
-	shouldMatch    bool              // whether the request is expected to match the route at all
-	shouldRedirect bool              // whether the request should result in a redirect
+	title           string            // title of the test
+	route           *Route            // the route being tested
+	request         *http.Request     // a request to test the route
+	vars            map[string]string // the expected vars of the match
+	scheme          string            // the expected scheme of the built URL
+	host            string            // the expected host of the built URL
+	path            string            // the expected path of the built URL
+	query           string            // the expected query string of the built URL
+	pathTemplate    string            // the expected path template of the route
+	hostTemplate    string            // the expected host template of the route
+	queriesTemplate string            // the expected query template of the route
+	methods         []string          // the expected route methods
+	pathRegexp      string            // the expected path regexp
+	queriesRegexp   string            // the expected query regexp
+	shouldMatch     bool              // whether the request is expected to match the route at all
+	shouldRedirect  bool              // whether the request should result in a redirect
 }
 
 func TestHost(t *testing.T) {
@@ -739,257 +741,309 @@ func TestMethods(t *testing.T) {
 func TestQueries(t *testing.T) {
 	tests := []routeTest{
 		{
-			title:       ""Queries route, match"",
-			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			query:       ""foo=bar&baz=ding"",
-			shouldMatch: true,
-		},
-		{
-			title:        ""Queries route, match with a query string"",
-			route:        new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:      newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
-			vars:         map[string]string{},
-			host:         """",
-			path:         """",
-			query:        ""foo=bar&baz=ding"",
-			pathTemplate: `/api`,
-			hostTemplate: `www.example.com`,
-			shouldMatch:  true,
-		},
-		{
-			title:        ""Queries route, match with a query string out of order"",
-			route:        new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:      newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
-			vars:         map[string]string{},
-			host:         """",
-			path:         """",
-			query:        ""foo=bar&baz=ding"",
-			pathTemplate: `/api`,
-			hostTemplate: `www.example.com`,
-			shouldMatch:  true,
-		},
-		{
-			title:       ""Queries route, bad query"",
-			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Queries route with pattern, match"",
-			route:       new(Route).Queries(""foo"", ""{v1}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
-			vars:        map[string]string{""v1"": ""bar""},
-			host:        """",
-			path:        """",
-			query:       ""foo=bar"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with multiple patterns, match"",
-			route:       new(Route).Queries(""foo"", ""{v1}"", ""baz"", ""{v2}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
-			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
-			host:        """",
-			path:        """",
-			query:       ""foo=bar&baz=ding"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with regexp pattern, match"",
-			route:       new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=10""),
-			vars:        map[string]string{""v1"": ""10""},
-			host:        """",
-			path:        """",
-			query:       ""foo=10"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with regexp pattern, regexp does not match"",
-			route:       new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=a""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Queries route with regexp pattern with quantifier, match"",
-			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=1""),
-			vars:        map[string]string{""v1"": ""1""},
-			host:        """",
-			path:        """",
-			query:       ""foo=1"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with regexp pattern with quantifier, additional variable in query string, match"",
-			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
-			request:     newRequest(""GET"", ""http://localhost?bar=2&foo=1""),
-			vars:        map[string]string{""v1"": ""1""},
-			host:        """",
-			path:        """",
-			query:       ""foo=1"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with regexp pattern with quantifier, regexp does not match"",
-			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=12""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Queries route with regexp pattern with quantifier, additional capturing group"",
-			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}(?:a|b)}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
-			vars:        map[string]string{""v1"": ""1a""},
-			host:        """",
-			path:        """",
-			query:       ""foo=1a"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
-			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=12""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Queries route with hyphenated name, match"",
-			route:       new(Route).Queries(""foo"", ""{v-1}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
-			vars:        map[string]string{""v-1"": ""bar""},
-			host:        """",
-			path:        """",
-			query:       ""foo=bar"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with multiple hyphenated names, match"",
-			route:       new(Route).Queries(""foo"", ""{v-1}"", ""baz"", ""{v-2}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
-			vars:        map[string]string{""v-1"": ""bar"", ""v-2"": ""ding""},
-			host:        """",
-			path:        """",
-			query:       ""foo=bar&baz=ding"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with hyphenate name and pattern, match"",
-			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=10""),
-			vars:        map[string]string{""v-1"": ""10""},
-			host:        """",
-			path:        """",
-			query:       ""foo=10"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with hyphenated name and pattern with quantifier, additional capturing group"",
-			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]{1}(?:a|b)}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
-			vars:        map[string]string{""v-1"": ""1a""},
-			host:        """",
-			path:        """",
-			query:       ""foo=1a"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with empty value, should match"",
-			route:       new(Route).Queries(""foo"", """"),
-			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			query:       ""foo="",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with empty value and no parameter in request, should not match"",
-			route:       new(Route).Queries(""foo"", """"),
-			request:     newRequest(""GET"", ""http://localhost""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Queries route with empty value and empty parameter in request, should match"",
-			route:       new(Route).Queries(""foo"", """"),
-			request:     newRequest(""GET"", ""http://localhost?foo=""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			query:       ""foo="",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route with overlapping value, should not match"",
-			route:       new(Route).Queries(""foo"", ""bar""),
-			request:     newRequest(""GET"", ""http://localhost?foo=barfoo""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Queries route with no parameter in request, should not match"",
-			route:       new(Route).Queries(""foo"", ""{bar}""),
-			request:     newRequest(""GET"", ""http://localhost""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Queries route with empty parameter in request, should match"",
-			route:       new(Route).Queries(""foo"", ""{bar}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=""),
-			vars:        map[string]string{""foo"": """"},
-			host:        """",
-			path:        """",
-			query:       ""foo="",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Queries route, bad submatch"",
-			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:     newRequest(""GET"", ""http://localhost?fffoo=bar&baz=dingggg""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Queries route with pattern, match, escaped value"",
-			route:       new(Route).Queries(""foo"", ""{v1}""),
-			request:     newRequest(""GET"", ""http://localhost?foo=%25bar%26%20%2F%3D%3F""),
-			vars:        map[string]string{""v1"": ""%bar& /=?""},
-			host:        """",
-			path:        """",
-			query:       ""foo=%25bar%26+%2F%3D%3F"",
-			shouldMatch: true,
+			title:           ""Queries route, match"",
+			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			query:           ""foo=bar&baz=ding"",
+			queriesTemplate: ""foo=bar,baz=ding"",
+			queriesRegexp:   ""^foo=bar$,^baz=ding$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route, match with a query string"",
+			route:           new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:         newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			query:           ""foo=bar&baz=ding"",
+			pathTemplate:    `/api`,
+			hostTemplate:    `www.example.com`,
+			queriesTemplate: ""foo=bar,baz=ding"",
+			queriesRegexp:   ""^foo=bar$,^baz=ding$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route, match with a query string out of order"",
+			route:           new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:         newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			query:           ""foo=bar&baz=ding"",
+			pathTemplate:    `/api`,
+			hostTemplate:    `www.example.com`,
+			queriesTemplate: ""foo=bar,baz=ding"",
+			queriesRegexp:   ""^foo=bar$,^baz=ding$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route, bad query"",
+			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			queriesTemplate: ""foo=bar,baz=ding"",
+			queriesRegexp:   ""^foo=bar$,^baz=ding$"",
+			shouldMatch:     false,
+		},
+		{
+			title:           ""Queries route with pattern, match"",
+			route:           new(Route).Queries(""foo"", ""{v1}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:            map[string]string{""v1"": ""bar""},
+			host:            """",
+			path:            """",
+			query:           ""foo=bar"",
+			queriesTemplate: ""foo={v1}"",
+			queriesRegexp:   ""^foo=(?P<v0>.*)$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with multiple patterns, match"",
+			route:           new(Route).Queries(""foo"", ""{v1}"", ""baz"", ""{v2}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:            map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:            """",
+			path:            """",
+			query:           ""foo=bar&baz=ding"",
+			queriesTemplate: ""foo={v1},baz={v2}"",
+			queriesRegexp:   ""^foo=(?P<v0>.*)$,^baz=(?P<v0>.*)$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with regexp pattern, match"",
+			route:           new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=10""),
+			vars:            map[string]string{""v1"": ""10""},
+			host:            """",
+			path:            """",
+			query:           ""foo=10"",
+			queriesTemplate: ""foo={v1:[0-9]+}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]+)$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with regexp pattern, regexp does not match"",
+			route:           new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=a""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			queriesTemplate: ""foo={v1:[0-9]+}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]+)$"",
+			shouldMatch:     false,
+		},
+		{
+			title:           ""Queries route with regexp pattern with quantifier, match"",
+			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=1""),
+			vars:            map[string]string{""v1"": ""1""},
+			host:            """",
+			path:            """",
+			query:           ""foo=1"",
+			queriesTemplate: ""foo={v1:[0-9]{1}}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]{1})$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with regexp pattern with quantifier, additional variable in query string, match"",
+			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
+			request:         newRequest(""GET"", ""http://localhost?bar=2&foo=1""),
+			vars:            map[string]string{""v1"": ""1""},
+			host:            """",
+			path:            """",
+			query:           ""foo=1"",
+			queriesTemplate: ""foo={v1:[0-9]{1}}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]{1})$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with regexp pattern with quantifier, regexp does not match"",
+			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=12""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			queriesTemplate: ""foo={v1:[0-9]{1}}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]{1})$"",
+			shouldMatch:     false,
+		},
+		{
+			title:           ""Queries route with regexp pattern with quantifier, additional capturing group"",
+			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}(?:a|b)}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=1a""),
+			vars:            map[string]string{""v1"": ""1a""},
+			host:            """",
+			path:            """",
+			query:           ""foo=1a"",
+			queriesTemplate: ""foo={v1:[0-9]{1}(?:a|b)}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]{1}(?:a|b))$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
+			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=12""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			queriesTemplate: ""foo={v1:[0-9]{1}}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]{1})$"",
+			shouldMatch:     false,
+		},
+		{
+			title:           ""Queries route with hyphenated name, match"",
+			route:           new(Route).Queries(""foo"", ""{v-1}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:            map[string]string{""v-1"": ""bar""},
+			host:            """",
+			path:            """",
+			query:           ""foo=bar"",
+			queriesTemplate: ""foo={v-1}"",
+			queriesRegexp:   ""^foo=(?P<v0>.*)$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with multiple hyphenated names, match"",
+			route:           new(Route).Queries(""foo"", ""{v-1}"", ""baz"", ""{v-2}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:            map[string]string{""v-1"": ""bar"", ""v-2"": ""ding""},
+			host:            """",
+			path:            """",
+			query:           ""foo=bar&baz=ding"",
+			queriesTemplate: ""foo={v-1},baz={v-2}"",
+			queriesRegexp:   ""^foo=(?P<v0>.*)$,^baz=(?P<v0>.*)$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with hyphenate name and pattern, match"",
+			route:           new(Route).Queries(""foo"", ""{v-1:[0-9]+}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=10""),
+			vars:            map[string]string{""v-1"": ""10""},
+			host:            """",
+			path:            """",
+			query:           ""foo=10"",
+			queriesTemplate: ""foo={v-1:[0-9]+}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]+)$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with hyphenated name and pattern with quantifier, additional capturing group"",
+			route:           new(Route).Queries(""foo"", ""{v-1:[0-9]{1}(?:a|b)}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=1a""),
+			vars:            map[string]string{""v-1"": ""1a""},
+			host:            """",
+			path:            """",
+			query:           ""foo=1a"",
+			queriesTemplate: ""foo={v-1:[0-9]{1}(?:a|b)}"",
+			queriesRegexp:   ""^foo=(?P<v0>[0-9]{1}(?:a|b))$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with empty value, should match"",
+			route:           new(Route).Queries(""foo"", """"),
+			request:         newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			query:           ""foo="",
+			queriesTemplate: ""foo="",
+			queriesRegexp:   ""^foo=.*$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with empty value and no parameter in request, should not match"",
+			route:           new(Route).Queries(""foo"", """"),
+			request:         newRequest(""GET"", ""http://localhost""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			queriesTemplate: ""foo="",
+			queriesRegexp:   ""^foo=.*$"",
+			shouldMatch:     false,
+		},
+		{
+			title:           ""Queries route with empty value and empty parameter in request, should match"",
+			route:           new(Route).Queries(""foo"", """"),
+			request:         newRequest(""GET"", ""http://localhost?foo=""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			query:           ""foo="",
+			queriesTemplate: ""foo="",
+			queriesRegexp:   ""^foo=.*$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route with overlapping value, should not match"",
+			route:           new(Route).Queries(""foo"", ""bar""),
+			request:         newRequest(""GET"", ""http://localhost?foo=barfoo""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			queriesTemplate: ""foo=bar"",
+			queriesRegexp:   ""^foo=bar$"",
+			shouldMatch:     false,
+		},
+		{
+			title:           ""Queries route with no parameter in request, should not match"",
+			route:           new(Route).Queries(""foo"", ""{bar}""),
+			request:         newRequest(""GET"", ""http://localhost""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			queriesTemplate: ""foo={bar}"",
+			queriesRegexp:   ""^foo=(?P<v0>.*)$"",
+			shouldMatch:     false,
+		},
+		{
+			title:           ""Queries route with empty parameter in request, should match"",
+			route:           new(Route).Queries(""foo"", ""{bar}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=""),
+			vars:            map[string]string{""foo"": """"},
+			host:            """",
+			path:            """",
+			query:           ""foo="",
+			queriesTemplate: ""foo={bar}"",
+			queriesRegexp:   ""^foo=(?P<v0>.*)$"",
+			shouldMatch:     true,
+		},
+		{
+			title:           ""Queries route, bad submatch"",
+			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:         newRequest(""GET"", ""http://localhost?fffoo=bar&baz=dingggg""),
+			vars:            map[string]string{},
+			host:            """",
+			path:            """",
+			queriesTemplate: ""foo=bar,baz=ding"",
+			queriesRegexp:   ""^foo=bar$,^baz=ding$"",
+			shouldMatch:     false,
+		},
+		{
+			title:           ""Queries route with pattern, match, escaped value"",
+			route:           new(Route).Queries(""foo"", ""{v1}""),
+			request:         newRequest(""GET"", ""http://localhost?foo=%25bar%26%20%2F%3D%3F""),
+			vars:            map[string]string{""v1"": ""%bar& /=?""},
+			host:            """",
+			path:            """",
+			query:           ""foo=%25bar%26+%2F%3D%3F"",
+			queriesTemplate: ""foo={v1}"",
+			queriesRegexp:   ""^foo=(?P<v0>.*)$"",
+			shouldMatch:     true,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
+		testQueriesTemplates(t, test)
 		testUseEscapedRoute(t, test)
+		testQueriesRegexp(t, test)
 	}
 }
 
@@ -1717,6 +1771,24 @@ func testRegexp(t *testing.T, test routeTest) {
 	}
 }
 
+func testQueriesRegexp(t *testing.T, test routeTest) {
+	route := test.route
+	queries, queriesErr := route.GetQueriesRegexp()
+	gotQueries := strings.Join(queries, "","")
+	if test.queriesRegexp != """" && queriesErr == nil && gotQueries != test.queriesRegexp {
+		t.Errorf(""(%v) GetQueriesRegexp not equal: expected %v, got %v"", test.title, test.queriesRegexp, gotQueries)
+	}
+}
+
+func testQueriesTemplates(t *testing.T, test routeTest) {
+	route := test.route
+	queries, queriesErr := route.GetQueriesTemplates()
+	gotQueries := strings.Join(queries, "","")
+	if test.queriesTemplate != """" && queriesErr == nil && gotQueries != test.queriesTemplate {
+		t.Errorf(""(%v) GetQueriesTemplates not equal: expected %v, got %v"", test.title, test.queriesTemplate, gotQueries)
+	}
+}
+
 type TestA301ResponseWriter struct {
 	hh     http.Header
 	status int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=10490f55fae320638e3418054ae58b3ab0ec2e98,https://github.com/gorilla/mux/blob/10490f55fae320638e3418054ae58b3ab0ec2e98/mux_test.go
10490f55fae320638e3418054ae58b3ab0ec2e98,96f746c27794b6709e8ce93819c9edc06657478a,route.go,,"Fri, 20 Oct 2017 01:19:04 GMT",modified,38,0,38,"@@ -608,6 +608,44 @@ func (r *Route) GetPathRegexp() (string, error) {
 	return r.regexp.path.regexp.String(), nil
 }
 
+// GetQueriesRegexp returns the expanded regular expressions used to match the
+// route queries.
+// This is useful for building simple REST API documentation and for instrumentation
+// against third-party services.
+// An empty list will be returned if the route does not have queries.
+func (r *Route) GetQueriesRegexp() ([]string, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	if r.regexp == nil || r.regexp.queries == nil {
+		return nil, errors.New(""mux: route doesn't have queries"")
+	}
+	var queries []string
+	for _, query := range r.regexp.queries {
+		queries = append(queries, query.regexp.String())
+	}
+	return queries, nil
+}
+
+// GetQueriesTemplates returns the templates used to build the
+// query matching.
+// This is useful for building simple REST API documentation and for instrumentation
+// against third-party services.
+// An empty list will be returned if the route does not define queries.
+func (r *Route) GetQueriesTemplates() ([]string, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	if r.regexp == nil || r.regexp.queries == nil {
+		return nil, errors.New(""mux: route doesn't have queries"")
+	}
+	var queries []string
+	for _, query := range r.regexp.queries {
+		queries = append(queries, query.template)
+	}
+	return queries, nil
+}
+
 // GetMethods returns the methods the route matches against
 // This is useful for building simple REST API documentation and for instrumentation
 // against third-party services.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=10490f55fae320638e3418054ae58b3ab0ec2e98,https://github.com/gorilla/mux/blob/10490f55fae320638e3418054ae58b3ab0ec2e98/route.go
9bd9ff2d1d2a0660d35050674f2c3112547997af,783b79b43f12cdd0539628c0f4769b7547e66cb1,.travis.yml,,"Tue, 10 Oct 2017 21:54:56 GMT",modified,1,0,1,"@@ -10,6 +10,7 @@ matrix:
     - go: 1.6
     - go: 1.7
     - go: 1.8
+    - go: 1.9
     - go: tip
 
 install:",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=9bd9ff2d1d2a0660d35050674f2c3112547997af,https://github.com/gorilla/mux/blob/9bd9ff2d1d2a0660d35050674f2c3112547997af/.travis.yml
bdd5a5a1b0b489d297b73eb62b5f6328df198bfc,b588095c3a77ce5d9655c799a0847d2a9178de7b,mux_test.go,,"Sun, 08 Oct 2017 21:49:13 GMT",modified,3,3,6,"@@ -1722,15 +1722,15 @@ type TestA301ResponseWriter struct {
 	status int
 }
 
-func (ho TestA301ResponseWriter) Header() http.Header {
+func (ho *TestA301ResponseWriter) Header() http.Header {
 	return http.Header(ho.hh)
 }
 
-func (ho TestA301ResponseWriter) Write(b []byte) (int, error) {
+func (ho *TestA301ResponseWriter) Write(b []byte) (int, error) {
 	return 0, nil
 }
 
-func (ho TestA301ResponseWriter) WriteHeader(code int) {
+func (ho *TestA301ResponseWriter) WriteHeader(code int) {
 	ho.status = code
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=bdd5a5a1b0b489d297b73eb62b5f6328df198bfc,https://github.com/gorilla/mux/blob/bdd5a5a1b0b489d297b73eb62b5f6328df198bfc/mux_test.go
3f19343c7d9ce75569b952758bd236af94956061,b096bf6348f27ebbb0d9a93c3be8f6bd5185eecd,README.md,,"Fri, 22 Sep 2017 20:54:14 GMT",modified,8,0,8,"@@ -135,6 +135,14 @@ r.HandleFunc(""/products"", ProductsHandler).
   Schemes(""http"")
 ```
 
+Routes are tested in the order they were added to the router. If two routes match, the first one wins:
+
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/specific"", specificHandler)
+r.PathPrefix(""/"").Handler(catchAllHandler)
+```
+
 Setting the same matching conditions again and again can be boring, so we have a way to group several routes that share the same requirements. We call it ""subrouting"".
 
 For example, let's say we have several URLs that should only match when the host is `www.example.com`. Create a route for that host and get a ""subrouter"" from it:",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=3f19343c7d9ce75569b952758bd236af94956061,https://github.com/gorilla/mux/blob/3f19343c7d9ce75569b952758bd236af94956061/README.md
24fca303ac6da784b9e8269f724ddeb0b2eea5e7,8dcd7188700893494ec123076a7b65a3c8412907,README.md,,"Tue, 05 Sep 2017 17:10:44 GMT",modified,1,1,2,"@@ -274,7 +274,7 @@ This also works for host and query value variables:
 r := mux.NewRouter()
 r.Host(""{subdomain}.domain.com"").
   Path(""/articles/{category}/{id:[0-9]+}"").
-  Queries(""filter"", ""{filter}"")
+  Queries(""filter"", ""{filter}"").
   HandlerFunc(ArticleHandler).
   Name(""article"")
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=24fca303ac6da784b9e8269f724ddeb0b2eea5e7,https://github.com/gorilla/mux/blob/24fca303ac6da784b9e8269f724ddeb0b2eea5e7/README.md
bb285ea687c5c77bb6935fdb2402b121d8efcbec,484fab431e95a7e429f22fa8fe0a3526006984b4,mux_test.go,,"Wed, 30 Aug 2017 20:57:41 GMT",modified,1,1,2,"@@ -1896,7 +1896,7 @@ func TestNoMatchMethodErrorHandler(t *testing.T) {
 		t.Errorf(""Expecting code %v"", 405)
 	}
 
-	//Add matching route now
+	// Add matching route
 	r.HandleFunc(""/"", func1).Methods(""PUT"")
 
 	match = new(RouteMatch)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=bb285ea687c5c77bb6935fdb2402b121d8efcbec,https://github.com/gorilla/mux/blob/bb285ea687c5c77bb6935fdb2402b121d8efcbec/mux_test.go
a659b61323b075cb38ad03aa43749e52eb4948e0,fb69196dbd2094009ad0b9d5de99f9e813b29960,mux.go,,"Wed, 30 Aug 2017 05:39:17 GMT",modified,33,0,33,"@@ -13,6 +13,10 @@ import (
 	""strings""
 )
 
+var (
+	ErrMethodMismatch = errors.New(""method is not allowed"")
+)
+
 // NewRouter returns a new router instance.
 func NewRouter() *Router {
 	return &Router{namedRoutes: make(map[string]*Route), KeepContext: false}
@@ -39,6 +43,10 @@ func NewRouter() *Router {
 type Router struct {
 	// Configurable Handler to be used when no route matches.
 	NotFoundHandler http.Handler
+
+	// Configurable Handler to be used when the request method does not match the route.
+	MethodNotAllowedHandler http.Handler
+
 	// Parent route, if this is a subrouter.
 	parent parentRoute
 	// Routes to be matched, in order.
@@ -65,6 +73,11 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 		}
 	}
 
+	if match.MatchErr == ErrMethodMismatch && r.MethodNotAllowedHandler != nil {
+		match.Handler = r.MethodNotAllowedHandler
+		return true
+	}
+
 	// Closest match for a router (includes sub-routers)
 	if r.NotFoundHandler != nil {
 		match.Handler = r.NotFoundHandler
@@ -105,9 +118,15 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		req = setVars(req, match.Vars)
 		req = setCurrentRoute(req, match.Route)
 	}
+
+	if handler == nil && match.MatchErr == ErrMethodMismatch {
+		handler = methodNotAllowedHandler()
+	}
+
 	if handler == nil {
 		handler = http.NotFoundHandler()
 	}
+
 	if !r.KeepContext {
 		defer contextClear(req)
 	}
@@ -344,6 +363,11 @@ type RouteMatch struct {
 	Route   *Route
 	Handler http.Handler
 	Vars    map[string]string
+
+	// MatchErr is set to appropriate matching error
+	// It is set to ErrMethodMismatch if there is a mismatch in
+	// the request method and route method
+	MatchErr error
 }
 
 type contextKey int
@@ -545,3 +569,12 @@ func matchMapWithRegex(toCheck map[string]*regexp.Regexp, toMatch map[string][]s
 	}
 	return true
 }
+
+// methodNotAllowed replies to the request with an HTTP status code 405.
+func methodNotAllowed(w http.ResponseWriter, r *http.Request) {
+	w.WriteHeader(http.StatusMethodNotAllowed)
+}
+
+// methodNotAllowedHandler returns a simple request handler
+// that replies to each request with a status code 405.
+func methodNotAllowedHandler() http.Handler { return http.HandlerFunc(methodNotAllowed) }",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=a659b61323b075cb38ad03aa43749e52eb4948e0,https://github.com/gorilla/mux/blob/a659b61323b075cb38ad03aa43749e52eb4948e0/mux.go
a659b61323b075cb38ad03aa43749e52eb4948e0,413f13f5b7085df34a2867ad772710e1e31cbed6,mux_test.go,,"Wed, 30 Aug 2017 05:39:17 GMT",modified,39,0,39,"@@ -1871,3 +1871,42 @@ func newRequest(method, url string) *http.Request {
 	}
 	return req
 }
+
+func TestNoMatchMethodErrorHandler(t *testing.T) {
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/"", func1).Methods(""GET"", ""POST"")
+
+	req, _ := http.NewRequest(""PUT"", ""http://localhost/"", nil)
+	match := new(RouteMatch)
+	matched := r.Match(req, match)
+
+	if matched {
+		t.Error(""Should not have matched route for methods"")
+	}
+
+	if match.MatchErr != ErrMethodMismatch {
+		t.Error(""Should get ErrMethodMismatch error"")
+	}
+
+	resp := NewRecorder()
+	r.ServeHTTP(resp, req)
+	if resp.Code != 405 {
+		t.Errorf(""Expecting code %v"", 405)
+	}
+
+	//Add matching route now
+	r.HandleFunc(""/"", func1).Methods(""PUT"")
+
+	match = new(RouteMatch)
+	matched = r.Match(req, match)
+
+	if !matched {
+		t.Error(""Should have matched route for methods"")
+	}
+
+	if match.MatchErr != nil {
+		t.Error(""Should not have any matching error. Found:"", match.MatchErr)
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a659b61323b075cb38ad03aa43749e52eb4948e0,https://github.com/gorilla/mux/blob/a659b61323b075cb38ad03aa43749e52eb4948e0/mux_test.go
a659b61323b075cb38ad03aa43749e52eb4948e0,3751e4727b5c4262256e92bc5fec7cc3cb633129,old_test.go,,"Wed, 30 Aug 2017 05:39:17 GMT",modified,1,7,8,"@@ -121,12 +121,7 @@ func TestRouteMatchers(t *testing.T) {
 		var routeMatch RouteMatch
 		matched := router.Match(request, &routeMatch)
 		if matched != shouldMatch {
-			// Need better messages. :)
-			if matched {
-				t.Errorf(""Should match."")
-			} else {
-				t.Errorf(""Should not match."")
-			}
+			t.Errorf(""Expected: %v\nGot: %v\nRequest: %v %v"", shouldMatch, matched, request.Method, url)
 		}
 
 		if matched {
@@ -188,7 +183,6 @@ func TestRouteMatchers(t *testing.T) {
 	match(true)
 
 	// 2nd route --------------------------------------------------------------
-
 	// Everything match.
 	reset2()
 	match(true)",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=a659b61323b075cb38ad03aa43749e52eb4948e0,https://github.com/gorilla/mux/blob/a659b61323b075cb38ad03aa43749e52eb4948e0/old_test.go
a659b61323b075cb38ad03aa43749e52eb4948e0,6863adba50e60f895a32f949c6225892f9e62673,route.go,,"Wed, 30 Aug 2017 05:39:17 GMT",modified,16,0,16,"@@ -52,12 +52,27 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if r.buildOnly || r.err != nil {
 		return false
 	}
+
+	var matchErr error
+
 	// Match everything.
 	for _, m := range r.matchers {
 		if matched := m.Match(req, match); !matched {
+			if _, ok := m.(methodMatcher); ok {
+				matchErr = ErrMethodMismatch
+				continue
+			}
+			matchErr = nil
 			return false
 		}
 	}
+
+	if matchErr != nil {
+		match.MatchErr = matchErr
+		return false
+	}
+
+	match.MatchErr = nil
 	// Yay, we have a match. Let's collect some info about it.
 	if match.Route == nil {
 		match.Route = r
@@ -68,6 +83,7 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if match.Vars == nil {
 		match.Vars = make(map[string]string)
 	}
+
 	// Set variables.
 	if r.regexp != nil {
 		r.regexp.setMatch(req, match, r)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=a659b61323b075cb38ad03aa43749e52eb4948e0,https://github.com/gorilla/mux/blob/a659b61323b075cb38ad03aa43749e52eb4948e0/route.go
ac112f7d75a0714af1bd86ab17749b31f7809640,f6cfb443d086780ec6851758b02d2d90f2e61562,mux_test.go,,"Tue, 04 Jul 2017 07:43:45 GMT",modified,11,0,11,"@@ -1226,6 +1226,17 @@ func TestSubRouter(t *testing.T) {
 			hostTemplate: `google.com`,
 			shouldMatch:  true,
 		},
+		{
+			title:        ""Prefer scheme on child route when building URLs"",
+			route:        new(Route).Schemes(""https"", ""ftp"").Host(""google.com"").Subrouter().Schemes(""ftp"").Path(""/""),
+			request:      newRequest(""GET"", ""ftp://google.com/""),
+			scheme:       ""ftp"",
+			host:         ""google.com"",
+			path:         ""/"",
+			pathTemplate: `/`,
+			hostTemplate: `google.com`,
+			shouldMatch:  true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=ac112f7d75a0714af1bd86ab17749b31f7809640,https://github.com/gorilla/mux/blob/ac112f7d75a0714af1bd86ab17749b31f7809640/mux_test.go
ac112f7d75a0714af1bd86ab17749b31f7809640,6d4a07a20d597349ba12404eff08974c163e9bdd,route.go,,"Tue, 04 Jul 2017 07:43:45 GMT",modified,1,1,2,"@@ -396,7 +396,7 @@ func (r *Route) Schemes(schemes ...string) *Route {
 	for k, v := range schemes {
 		schemes[k] = strings.ToLower(v)
 	}
-	if r.getBuildScheme() == """" && len(schemes) > 0 {
+	if r.buildScheme == """" && len(schemes) > 0 {
 		r.buildScheme = schemes[0]
 	}
 	return r.addMatcher(schemeMatcher(schemes))",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=ac112f7d75a0714af1bd86ab17749b31f7809640,https://github.com/gorilla/mux/blob/ac112f7d75a0714af1bd86ab17749b31f7809640/route.go
37b3a6cace5ebe92c9b1494fab04d5e7767b271b,aa195979a9565e0d7f47c5097186acdf2dad6a95,mux.go,,"Tue, 04 Jul 2017 07:43:45 GMT",modified,7,0,7,"@@ -176,6 +176,13 @@ func (r *Router) UseEncodedPath() *Router {
 // parentRoute
 // ----------------------------------------------------------------------------
 
+func (r *Router) getBuildScheme() string {
+	if r.parent != nil {
+		return r.parent.getBuildScheme()
+	}
+	return """"
+}
+
 // getNamedRoutes returns the map where named routes are registered.
 func (r *Router) getNamedRoutes() map[string]*Route {
 	if r.namedRoutes == nil {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=37b3a6cace5ebe92c9b1494fab04d5e7767b271b,https://github.com/gorilla/mux/blob/37b3a6cace5ebe92c9b1494fab04d5e7767b271b/mux.go
37b3a6cace5ebe92c9b1494fab04d5e7767b271b,9dd06f0218297ffcacbc986a9ddc99baf78505a4,mux_test.go,,"Tue, 04 Jul 2017 07:43:45 GMT",modified,11,0,11,"@@ -1215,6 +1215,17 @@ func TestSubRouter(t *testing.T) {
 			pathTemplate: `/{category}`,
 			shouldMatch:  true,
 		},
+		{
+			title:        ""Build with scheme on parent router"",
+			route:        new(Route).Schemes(""ftp"").Host(""google.com"").Subrouter().Path(""/""),
+			request:      newRequest(""GET"", ""ftp://google.com/""),
+			scheme:       ""ftp"",
+			host:         ""google.com"",
+			path:         ""/"",
+			pathTemplate: `/`,
+			hostTemplate: `google.com`,
+			shouldMatch:  true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=37b3a6cace5ebe92c9b1494fab04d5e7767b271b,https://github.com/gorilla/mux/blob/37b3a6cace5ebe92c9b1494fab04d5e7767b271b/mux_test.go
37b3a6cace5ebe92c9b1494fab04d5e7767b271b,5c8e7c0c0b4c6644f05a7fbcce52cf2d8dc6dd17,route.go,,"Tue, 04 Jul 2017 07:43:45 GMT",modified,16,5,21,"@@ -396,7 +396,7 @@ func (r *Route) Schemes(schemes ...string) *Route {
 	for k, v := range schemes {
 		schemes[k] = strings.ToLower(v)
 	}
-	if r.buildScheme == """" && len(schemes) > 0 {
+	if r.getBuildScheme() == """" && len(schemes) > 0 {
 		r.buildScheme = schemes[0]
 	}
 	return r.addMatcher(schemeMatcher(schemes))
@@ -488,8 +488,8 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 			return nil, err
 		}
 		scheme = ""http""
-		if r.buildScheme != """" {
-			scheme = r.buildScheme
+		if s := r.getBuildScheme(); s != """" {
+			scheme = s
 		}
 	}
 	if r.regexp.path != nil {
@@ -534,8 +534,8 @@ func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
 		Scheme: ""http"",
 		Host:   host,
 	}
-	if r.buildScheme != """" {
-		u.Scheme = r.buildScheme
+	if s := r.getBuildScheme(); s != """" {
+		u.Scheme = s
 	}
 	return u, nil
 }
@@ -649,11 +649,22 @@ func (r *Route) buildVars(m map[string]string) map[string]string {
 
 // parentRoute allows routes to know about parent host and path definitions.
 type parentRoute interface {
+	getBuildScheme() string
 	getNamedRoutes() map[string]*Route
 	getRegexpGroup() *routeRegexpGroup
 	buildVars(map[string]string) map[string]string
 }
 
+func (r *Route) getBuildScheme() string {
+	if r.buildScheme != """" {
+		return r.buildScheme
+	}
+	if r.parent != nil {
+		return r.parent.getBuildScheme()
+	}
+	return """"
+}
+
 // getNamedRoutes returns the map where named routes are registered.
 func (r *Route) getNamedRoutes() map[string]*Route {
 	if r.parent == nil {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=37b3a6cace5ebe92c9b1494fab04d5e7767b271b,https://github.com/gorilla/mux/blob/37b3a6cace5ebe92c9b1494fab04d5e7767b271b/route.go
8c683ee571b6ee7ffc9f1cafd13103c422e71cbf,709ea056e82955afe3412a1dac348d0df22438bb,mux.go,,"Wed, 21 Jun 2017 22:07:33 GMT",modified,1,1,2,"@@ -456,7 +456,7 @@ func mapFromPairsToString(pairs ...string) (map[string]string, error) {
 	return m, nil
 }
 
-// mapFromPairsToRegex converts variadic string paramers to a
+// mapFromPairsToRegex converts variadic string parameters to a
 // string to regex map.
 func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
 	length, err := checkPairs(pairs...)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=8c683ee571b6ee7ffc9f1cafd13103c422e71cbf,https://github.com/gorilla/mux/blob/8c683ee571b6ee7ffc9f1cafd13103c422e71cbf/mux.go
18fca31550181693b3a834a15b74b564b3605876,4340c506b37aba05f02c428e752160e62c8d02e3,mux_test.go,,"Fri, 02 Jun 2017 19:31:40 GMT",modified,11,1,12,"@@ -36,7 +36,7 @@ type routeTest struct {
 	scheme         string            // the expected scheme of the built URL
 	host           string            // the expected host of the built URL
 	path           string            // the expected path of the built URL
-	query          string            // the expected query string to match
+	query          string            // the expected query string of the built URL
 	pathTemplate   string            // the expected path template of the route
 	hostTemplate   string            // the expected host template of the route
 	methods        []string          // the expected route methods
@@ -974,6 +974,16 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with pattern, match, escaped value"",
+			route:       new(Route).Queries(""foo"", ""{v1}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=%25bar%26%20%2F%3D%3F""),
+			vars:        map[string]string{""v1"": ""%bar& /=?""},
+			host:        """",
+			path:        """",
+			query:       ""foo=%25bar%26+%2F%3D%3F"",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=18fca31550181693b3a834a15b74b564b3605876,https://github.com/gorilla/mux/blob/18fca31550181693b3a834a15b74b564b3605876/mux_test.go
18fca31550181693b3a834a15b74b564b3605876,80d1f785804e996282c703c26f80c641119acd08,regexp.go,,"Fri, 02 Jun 2017 19:31:40 GMT",modified,1,1,2,"@@ -35,7 +35,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash,
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
 	if matchQuery {
-		defaultPattern = ""[^?&]*""
+		defaultPattern = "".*""
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
 		matchPrefix = false",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=18fca31550181693b3a834a15b74b564b3605876,https://github.com/gorilla/mux/blob/18fca31550181693b3a834a15b74b564b3605876/regexp.go
c7a138dbc1778cafd4aaddb7ce7975a5f3649a49,859539732f3c53db30fe71e9331eb4e5de019f34,README.md,,"Fri, 02 Jun 2017 19:31:40 GMT",modified,6,4,10,"@@ -15,7 +15,7 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 
 * It implements the `http.Handler` interface so it is compatible with the standard `http.ServeMux`.
 * Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers.
-* URL hosts and paths can have variables with an optional regular expression.
+* URL hosts, paths and query values can have variables with an optional regular expression.
 * Registered URLs can be built, or ""reversed"", which helps maintaining references to resources.
 * Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching.
 
@@ -268,19 +268,21 @@ url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
 ""/articles/technology/42""
 ```
 
-This also works for host variables:
+This also works for host and query value variables:
 
 ```go
 r := mux.NewRouter()
 r.Host(""{subdomain}.domain.com"").
   Path(""/articles/{category}/{id:[0-9]+}"").
+  Queries(""filter"", ""{filter}"")
   HandlerFunc(ArticleHandler).
   Name(""article"")
 
-// url.String() will be ""http://news.domain.com/articles/technology/42""
+// url.String() will be ""http://news.domain.com/articles/technology/42?filter=gorilla""
 url, err := r.Get(""article"").URL(""subdomain"", ""news"",
                                  ""category"", ""technology"",
-                                 ""id"", ""42"")
+                                 ""id"", ""42"",
+                                 ""filter"", ""gorilla"")
 ```
 
 All variables defined in the route are required, and their values must conform to the corresponding patterns. These requirements guarantee that a generated URL will always match a registered route -- the only exception is for explicitly defined ""build-only"" routes which never match.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=c7a138dbc1778cafd4aaddb7ce7975a5f3649a49,https://github.com/gorilla/mux/blob/c7a138dbc1778cafd4aaddb7ce7975a5f3649a49/README.md
c7a138dbc1778cafd4aaddb7ce7975a5f3649a49,cce30b2f04c7b062c768a1c35dc3f7ff83e70778,doc.go,,"Fri, 02 Jun 2017 19:31:40 GMT",modified,7,5,12,"@@ -12,8 +12,8 @@ or other conditions. The main features are:
 
 	* Requests can be matched based on URL host, path, path prefix, schemes,
 	  header and query values, HTTP methods or using custom matchers.
-	* URL hosts and paths can have variables with an optional regular
-	  expression.
+	* URL hosts, paths and query values can have variables with an optional
+	  regular expression.
 	* Registered URLs can be built, or ""reversed"", which helps maintaining
 	  references to resources.
 	* Routes can be used as subrouters: nested routes are only tested if the
@@ -188,18 +188,20 @@ key/value pairs for the route variables. For the previous route, we would do:
 
 	""/articles/technology/42""
 
-This also works for host variables:
+This also works for host and query value variables:
 
 	r := mux.NewRouter()
 	r.Host(""{subdomain}.domain.com"").
 	  Path(""/articles/{category}/{id:[0-9]+}"").
+	  Queries(""filter"", ""{filter}"").
 	  HandlerFunc(ArticleHandler).
 	  Name(""article"")
 
-	// url.String() will be ""http://news.domain.com/articles/technology/42""
+	// url.String() will be ""http://news.domain.com/articles/technology/42?filter=gorilla""
 	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
 	                                 ""category"", ""technology"",
-	                                 ""id"", ""42"")
+	                                 ""id"", ""42"",
+	                                 ""filter"", ""gorilla"")
 
 All variables defined in the route are required, and their values must
 conform to the corresponding patterns. These requirements guarantee that a",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=c7a138dbc1778cafd4aaddb7ce7975a5f3649a49,https://github.com/gorilla/mux/blob/c7a138dbc1778cafd4aaddb7ce7975a5f3649a49/doc.go
f9aa23a02ba450e8ded2b1cb2ac8b4cd5a8bb123,c695f6c39cc53835f32f9a13af0295d8c97da745,mux_test.go,,"Fri, 02 Jun 2017 19:31:40 GMT",modified,25,0,25,"@@ -36,6 +36,7 @@ type routeTest struct {
 	scheme         string            // the expected scheme of the built URL
 	host           string            // the expected host of the built URL
 	path           string            // the expected path of the built URL
+	query          string            // the expected query string to match
 	pathTemplate   string            // the expected path template of the route
 	hostTemplate   string            // the expected host template of the route
 	methods        []string          // the expected route methods
@@ -744,6 +745,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			query:       ""foo=bar&baz=ding"",
 			shouldMatch: true,
 		},
 		{
@@ -753,6 +755,7 @@ func TestQueries(t *testing.T) {
 			vars:         map[string]string{},
 			host:         """",
 			path:         """",
+			query:        ""foo=bar&baz=ding"",
 			pathTemplate: `/api`,
 			hostTemplate: `www.example.com`,
 			shouldMatch:  true,
@@ -764,6 +767,7 @@ func TestQueries(t *testing.T) {
 			vars:         map[string]string{},
 			host:         """",
 			path:         """",
+			query:        ""foo=bar&baz=ding"",
 			pathTemplate: `/api`,
 			hostTemplate: `www.example.com`,
 			shouldMatch:  true,
@@ -784,6 +788,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bar""},
 			host:        """",
 			path:        """",
+			query:       ""foo=bar"",
 			shouldMatch: true,
 		},
 		{
@@ -793,6 +798,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
 			host:        """",
 			path:        """",
+			query:       ""foo=bar&baz=ding"",
 			shouldMatch: true,
 		},
 		{
@@ -802,6 +808,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v1"": ""10""},
 			host:        """",
 			path:        """",
+			query:       ""foo=10"",
 			shouldMatch: true,
 		},
 		{
@@ -820,6 +827,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v1"": ""1""},
 			host:        """",
 			path:        """",
+			query:       ""foo=1"",
 			shouldMatch: true,
 		},
 		{
@@ -829,6 +837,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v1"": ""1""},
 			host:        """",
 			path:        """",
+			query:       ""foo=1"",
 			shouldMatch: true,
 		},
 		{
@@ -847,6 +856,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v1"": ""1a""},
 			host:        """",
 			path:        """",
+			query:       ""foo=1a"",
 			shouldMatch: true,
 		},
 		{
@@ -865,6 +875,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""bar""},
 			host:        """",
 			path:        """",
+			query:       ""foo=bar"",
 			shouldMatch: true,
 		},
 		{
@@ -874,6 +885,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""bar"", ""v-2"": ""ding""},
 			host:        """",
 			path:        """",
+			query:       ""foo=bar&baz=ding"",
 			shouldMatch: true,
 		},
 		{
@@ -883,6 +895,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""10""},
 			host:        """",
 			path:        """",
+			query:       ""foo=10"",
 			shouldMatch: true,
 		},
 		{
@@ -892,6 +905,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""1a""},
 			host:        """",
 			path:        """",
+			query:       ""foo=1a"",
 			shouldMatch: true,
 		},
 		{
@@ -901,6 +915,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			query:       ""foo="",
 			shouldMatch: true,
 		},
 		{
@@ -919,6 +934,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			query:       ""foo="",
 			shouldMatch: true,
 		},
 		{
@@ -946,6 +962,7 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{""foo"": """"},
 			host:        """",
 			path:        """",
+			query:       ""foo="",
 			shouldMatch: true,
 		},
 		{
@@ -1537,6 +1554,7 @@ func testRoute(t *testing.T, test routeTest) {
 	route := test.route
 	vars := test.vars
 	shouldMatch := test.shouldMatch
+	query := test.query
 	shouldRedirect := test.shouldRedirect
 	uri := url.URL{
 		Scheme: test.scheme,
@@ -1606,6 +1624,13 @@ func testRoute(t *testing.T, test routeTest) {
 				return
 			}
 		}
+		if query != """" {
+			u, _ := route.URL(mapToPairs(match.Vars)...)
+			if query != u.RawQuery {
+				t.Errorf(""(%v) URL query not equal: expected %v, got %v"", test.title, query, u.RawQuery)
+				return
+			}
+		}
 		if shouldRedirect && match.Handler == nil {
 			t.Errorf(""(%v) Did not redirect"", test.title)
 			return",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=f9aa23a02ba450e8ded2b1cb2ac8b4cd5a8bb123,https://github.com/gorilla/mux/blob/f9aa23a02ba450e8ded2b1cb2ac8b4cd5a8bb123/mux_test.go
9c9af153a18415409f478fe09658a3af59366515,7451ee006ed15de73dba23360b3fd21fb07a1b52,regexp.go,,"Fri, 02 Jun 2017 19:31:40 GMT",modified,3,0,3,"@@ -178,6 +178,9 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 		if !ok {
 			return """", fmt.Errorf(""mux: missing route variable %q"", v)
 		}
+		if r.matchQuery {
+			value = url.QueryEscape(value)
+		}
 		urlValues[k] = value
 	}
 	rv := fmt.Sprintf(r.reverse, urlValues...)",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=9c9af153a18415409f478fe09658a3af59366515,https://github.com/gorilla/mux/blob/9c9af153a18415409f478fe09658a3af59366515/regexp.go
9c9af153a18415409f478fe09658a3af59366515,916de74a3f675abd7252195ee20bd35dbb27c5ec,route.go,,"Fri, 02 Jun 2017 19:31:40 GMT",modified,12,3,15,"@@ -482,6 +482,7 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 		return nil, err
 	}
 	var scheme, host, path string
+	queries := make([]string, 0, len(r.regexp.queries))
 	if r.regexp.host != nil {
 		if host, err = r.regexp.host.url(values); err != nil {
 			return nil, err
@@ -496,10 +497,18 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 			return nil, err
 		}
 	}
+	for _, q := range r.regexp.queries {
+		var query string
+		if query, err = q.url(values); err != nil {
+			return nil, err
+		}
+		queries = append(queries, query)
+	}
 	return &url.URL{
-		Scheme: scheme,
-		Host:   host,
-		Path:   path,
+		Scheme:   scheme,
+		Host:     host,
+		Path:     path,
+		RawQuery: strings.Join(queries, ""&""),
 	}, nil
 }
 ",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=9c9af153a18415409f478fe09658a3af59366515,https://github.com/gorilla/mux/blob/9c9af153a18415409f478fe09658a3af59366515/route.go
043ee6597c29786140136a5747b6a886364f5282,6fd49589253b299193d4462441effc0048722479,README.md,,"Wed, 24 May 2017 01:01:04 GMT",modified,3,3,6,"@@ -326,9 +326,9 @@ the following prints all of the registered routes:
 ```go
 r := mux.NewRouter()
 r.HandleFunc(""/"", handler)
-r.Methods(""POST"").HandleFunc(""/products"", handler)
-r.Methods(""GET"").HandleFunc(""/articles"", handler)
-r.Methods(""GET"", ""PUT"").HandleFunc(""/articles/{id}"", handler)
+r.HandleFunc(""/products"", handler).Methods(""POST"")
+r.HandleFunc(""/articles"", handler).Methods(""GET"")
+r.HandleFunc(""/articles/{id}"", handler).Methods(""GET"", ""PUT"")
 r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
     t, err := route.GetPathTemplate()
     if err != nil {",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=043ee6597c29786140136a5747b6a886364f5282,https://github.com/gorilla/mux/blob/043ee6597c29786140136a5747b6a886364f5282/README.md
59ce66852b697ee9168e885e69857d678847633d,d1d48b2ad6cda7ffa0eb03874a50bc1d3f531db3,README.md,,"Wed, 24 May 2017 01:01:04 GMT",modified,3,3,6,"@@ -190,9 +190,9 @@ func handler(w http.ResponseWriter, r *http.Request) {
 func main() {
     r := mux.NewRouter()
     r.HandleFunc(""/"", handler)
-    r.Methods(""POST"").HandleFunc(""/products"", handler)
-    r.Methods(""GET"").HandleFunc(""/articles"", handler)
-    r.Methods(""GET"", ""PUT"").HandleFunc(""/articles/{id}"", handler)
+    r.HandleFunc(""/products"", handler).Methods(""POST"")
+    r.HandleFunc(""/articles"", handler).Methods(""GET"")
+    r.HandleFunc(""/articles/{id}"", handler).Methods(""GET"", ""PUT"")
     r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
         t, err := route.GetPathTemplate()
         if err != nil {",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=59ce66852b697ee9168e885e69857d678847633d,https://github.com/gorilla/mux/blob/59ce66852b697ee9168e885e69857d678847633d/README.md
85b8c203a414fa3650401cd5c6aa926dd1e275d9,8e5a6bc3a670beaeff63ed261dffd8b2c0cb4495,README.md,,"Tue, 23 May 2017 02:46:13 GMT",modified,0,2,2,"@@ -168,8 +168,6 @@ s.HandleFunc(""/{key}/"", ProductHandler)
 // ""/products/{key}/details""
 s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 ```
-
-<<<<<<< f85983fbfd0e0146e24ba184acbdca25f0361e99
 ### Listing Routes
 
 Routes on a mux can be listed using the Router.Walk method—useful for generating documentation:",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=85b8c203a414fa3650401cd5c6aa926dd1e275d9,https://github.com/gorilla/mux/blob/85b8c203a414fa3650401cd5c6aa926dd1e275d9/README.md
456bcfa82d672db7cae587c9b541463f65bc2718,046e797ef54a84a6ff95cc1da2e5e70c057f4b56,README.md,,"Mon, 22 May 2017 15:17:48 GMT",modified,33,1,34,"@@ -24,9 +24,9 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 * [Install](#install)
 * [Examples](#examples)
 * [Matching Routes](#matching-routes)
-* [Listing Routes](#listing-routes)
 * [Static Files](#static-files)
 * [Registered URLs](#registered-urls)
+* [Walking Routes](#walking-routes)
 * [Full Example](#full-example)
 
 ---
@@ -169,6 +169,7 @@ s.HandleFunc(""/{key}/"", ProductHandler)
 s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 ```
 
+<<<<<<< f85983fbfd0e0146e24ba184acbdca25f0361e99
 ### Listing Routes
 
 Routes on a mux can be listed using the Router.Walk method—useful for generating documentation:
@@ -319,6 +320,37 @@ url, err := r.Get(""article"").URL(""subdomain"", ""news"",
                                  ""id"", ""42"")
 ```
 
+### Walking Routes
+
+The `Walk` function on `mux.Router` can be used to visit all of the routes that are registered on a router. For example,
+the following prints all of the registered routes:
+
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/"", handler)
+r.Methods(""POST"").HandleFunc(""/products"", handler)
+r.Methods(""GET"").HandleFunc(""/articles"", handler)
+r.Methods(""GET"", ""PUT"").HandleFunc(""/articles/{id}"", handler)
+r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
+    t, err := route.GetPathTemplate()
+    if err != nil {
+        return err
+    }
+    // p will contain a regular expression that is compatible with regular expressions in Perl, Python, and other languages.
+    // For example, the regular expression for path '/articles/{id}' will be '^/articles/(?P<v0>[^/]+)$'.
+    p, err := route.GetPathRegexp()
+    if err != nil {
+        return err
+    }
+    m, err := route.GetMethods()
+    if err != nil {
+        return err
+    }
+    fmt.Println(strings.Join(m, "",""), t, p)
+    return nil
+})
+```
+
 ## Full Example
 
 Here's a complete, runnable example of a small `mux` based server:",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=456bcfa82d672db7cae587c9b541463f65bc2718,https://github.com/gorilla/mux/blob/456bcfa82d672db7cae587c9b541463f65bc2718/README.md
4d814f7650d4fb90c7f13da96d37831f6c11f86e,fe31f09cff65b9b6a339464db2e133b8266dae13,mux.go,,"Mon, 22 May 2017 15:17:48 GMT",modified,2,0,2,"@@ -308,10 +308,12 @@ func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
 		}
 		for _, sr := range t.matchers {
 			if h, ok := sr.(*Router); ok {
+				ancestors = append(ancestors, t)
 				err := h.walk(walkFn, ancestors)
 				if err != nil {
 					return err
 				}
+				ancestors = ancestors[:len(ancestors)-1]
 			}
 		}
 		if h, ok := t.handler.(*Router); ok {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=4d814f7650d4fb90c7f13da96d37831f6c11f86e,https://github.com/gorilla/mux/blob/4d814f7650d4fb90c7f13da96d37831f6c11f86e/mux.go
4d814f7650d4fb90c7f13da96d37831f6c11f86e,dd7836b0ea4bacbaddfd54a5a5a87814ae14fd35,mux_test.go,,"Mon, 22 May 2017 15:17:48 GMT",modified,21,4,25,"@@ -11,6 +11,7 @@ import (
 	""fmt""
 	""net/http""
 	""net/url""
+	""reflect""
 	""strings""
 	""testing""
 )
@@ -1382,22 +1383,38 @@ func TestWalkNested(t *testing.T) {
 	l2 := l1.PathPrefix(""/l"").Subrouter()
 	l2.Path(""/a"")
 
-	paths := []string{""/g"", ""/g/o"", ""/g/o/r"", ""/g/o/r/i"", ""/g/o/r/i/l"", ""/g/o/r/i/l/l"", ""/g/o/r/i/l/l/a""}
+	testCases := []struct {
+		path      string
+		ancestors []*Route
+	}{
+		{""/g"", []*Route{}},
+		{""/g/o"", []*Route{g.parent.(*Route)}},
+		{""/g/o/r"", []*Route{g.parent.(*Route), o.parent.(*Route)}},
+		{""/g/o/r/i"", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route)}},
+		{""/g/o/r/i/l"", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route)}},
+		{""/g/o/r/i/l/l"", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route), l1.parent.(*Route)}},
+		{""/g/o/r/i/l/l/a"", []*Route{g.parent.(*Route), o.parent.(*Route), r.parent.(*Route), i.parent.(*Route), l1.parent.(*Route), l2.parent.(*Route)}},
+	}
+
 	idx := 0
 	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
-		path := paths[idx]
+		path := testCases[idx].path
 		tpl := route.regexp.path.template
 		if tpl != path {
 			t.Errorf(`Expected %s got %s`, path, tpl)
 		}
+		currWantAncestors := testCases[idx].ancestors
+		if !reflect.DeepEqual(currWantAncestors, ancestors) {
+			t.Errorf(`Expected %+v got %+v`, currWantAncestors, ancestors)
+		}
 		idx++
 		return nil
 	})
 	if err != nil {
 		panic(err)
 	}
-	if idx != len(paths) {
-		t.Errorf(""Expected %d routes, found %d"", len(paths), idx)
+	if idx != len(testCases) {
+		t.Errorf(""Expected %d routes, found %d"", len(testCases), idx)
 	}
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=4d814f7650d4fb90c7f13da96d37831f6c11f86e,https://github.com/gorilla/mux/blob/4d814f7650d4fb90c7f13da96d37831f6c11f86e/mux_test.go
a322b2c2ecff2decd1b67fe1fa472ad779e9ae0f,73c09967f8aa14a7af8dd28967256a35cb93158d,mux.go,,"Sun, 21 May 2017 21:35:07 GMT",modified,0,4,4,"@@ -299,10 +299,6 @@ type WalkFunc func(route *Route, router *Router, ancestors []*Route) error
 
 func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
 	for _, t := range r.routes {
-		if t.regexp == nil || t.regexp.path == nil || t.regexp.path.template == """" {
-			continue
-		}
-
 		err := walkFn(t, r, ancestors)
 		if err == SkipRouter {
 			continue",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=a322b2c2ecff2decd1b67fe1fa472ad779e9ae0f,https://github.com/gorilla/mux/blob/a322b2c2ecff2decd1b67fe1fa472ad779e9ae0f/mux.go
a322b2c2ecff2decd1b67fe1fa472ad779e9ae0f,6d3bdd251ee8622d7fc82d71c1c602037c875b8a,mux_test.go,,"Sun, 21 May 2017 21:35:07 GMT",modified,28,0,28,"@@ -1401,6 +1401,34 @@ func TestWalkNested(t *testing.T) {
 	}
 }
 
+func TestWalkSubrouters(t *testing.T) {
+	router := NewRouter()
+
+	g := router.Path(""/g"").Subrouter()
+	o := g.PathPrefix(""/o"").Subrouter()
+	o.Methods(""GET"")
+	o.Methods(""PUT"")
+
+	// all 4 routes should be matched, but final 2 routes do not have path templates
+	paths := []string{""/g"", ""/g/o"", """", """"}
+	idx := 0
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		path := paths[idx]
+		tpl, _ := route.GetPathTemplate()
+		if tpl != path {
+			t.Errorf(`Expected %s got %s`, path, tpl)
+		}
+		idx++
+		return nil
+	})
+	if err != nil {
+		panic(err)
+	}
+	if idx != len(paths) {
+		t.Errorf(""Expected %d routes, found %d"", len(paths), idx)
+	}
+}
+
 func TestWalkErrorRoute(t *testing.T) {
 	router := NewRouter()
 	router.Path(""/g"")",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a322b2c2ecff2decd1b67fe1fa472ad779e9ae0f,https://github.com/gorilla/mux/blob/a322b2c2ecff2decd1b67fe1fa472ad779e9ae0f/mux_test.go
bcd8bc72b08df0f70df986b97f95590779502d31,19ef5a8cceb0badbd5dd39498e995f7bcfcbb605,mux_test.go,,"Sun, 21 May 2017 04:50:13 GMT",modified,152,80,232,"@@ -10,6 +10,7 @@ import (
 	""errors""
 	""fmt""
 	""net/http""
+	""net/url""
 	""strings""
 	""testing""
 )
@@ -31,10 +32,11 @@ type routeTest struct {
 	route          *Route            // the route being tested
 	request        *http.Request     // a request to test the route
 	vars           map[string]string // the expected vars of the match
-	host           string            // the expected host of the match
-	path           string            // the expected path of the match
-	pathTemplate   string            // the expected path template to match
-	hostTemplate   string            // the expected host template to match
+	scheme         string            // the expected scheme of the built URL
+	host           string            // the expected host of the built URL
+	path           string            // the expected path of the built URL
+	pathTemplate   string            // the expected path template of the route
+	hostTemplate   string            // the expected host template of the route
 	methods        []string          // the expected route methods
 	pathRegexp     string            // the expected path regexp
 	shouldMatch    bool              // whether the request is expected to match the route at all
@@ -197,46 +199,6 @@ func TestHost(t *testing.T) {
 			hostTemplate: `{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}`,
 			shouldMatch:  true,
 		},
-		{
-			title:        ""Path route with single pattern with pipe, match"",
-			route:        new(Route).Path(""/{category:a|b/c}""),
-			request:      newRequest(""GET"", ""http://localhost/a""),
-			vars:         map[string]string{""category"": ""a""},
-			host:         """",
-			path:         ""/a"",
-			pathTemplate: `/{category:a|b/c}`,
-			shouldMatch:  true,
-		},
-		{
-			title:        ""Path route with single pattern with pipe, match"",
-			route:        new(Route).Path(""/{category:a|b/c}""),
-			request:      newRequest(""GET"", ""http://localhost/b/c""),
-			vars:         map[string]string{""category"": ""b/c""},
-			host:         """",
-			path:         ""/b/c"",
-			pathTemplate: `/{category:a|b/c}`,
-			shouldMatch:  true,
-		},
-		{
-			title:        ""Path route with multiple patterns with pipe, match"",
-			route:        new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
-			request:      newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:         map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
-			host:         """",
-			path:         ""/a/product_name/1"",
-			pathTemplate: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
-			shouldMatch:  true,
-		},
-		{
-			title:        ""Path route with multiple patterns with pipe, match"",
-			route:        new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
-			request:      newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
-			vars:         map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
-			host:         """",
-			path:         ""/b/c/product_name/1"",
-			pathTemplate: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
-			shouldMatch:  true,
-		},
 	}
 	for _, test := range tests {
 		testRoute(t, test)
@@ -428,6 +390,46 @@ func TestPath(t *testing.T) {
 			pathRegexp:   `^/(?P<v0>[0-9]*)(?P<v1>[a-z]*)/(?P<v2>[0-9]*)$`,
 			shouldMatch:  true,
 		},
+		{
+			title:        ""Path route with single pattern with pipe, match"",
+			route:        new(Route).Path(""/{category:a|b/c}""),
+			request:      newRequest(""GET"", ""http://localhost/a""),
+			vars:         map[string]string{""category"": ""a""},
+			host:         """",
+			path:         ""/a"",
+			pathTemplate: `/{category:a|b/c}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with single pattern with pipe, match"",
+			route:        new(Route).Path(""/{category:a|b/c}""),
+			request:      newRequest(""GET"", ""http://localhost/b/c""),
+			vars:         map[string]string{""category"": ""b/c""},
+			host:         """",
+			path:         ""/b/c"",
+			pathTemplate: `/{category:a|b/c}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with multiple patterns with pipe, match"",
+			route:        new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:      newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:         map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:         """",
+			path:         ""/a/product_name/1"",
+			pathTemplate: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with multiple patterns with pipe, match"",
+			route:        new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:      newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
+			vars:         map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
+			host:         """",
+			path:         ""/b/c/product_name/1"",
+			pathTemplate: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
+			shouldMatch:  true,
+		},
 	}
 
 	for _, test := range tests {
@@ -516,15 +518,28 @@ func TestPathPrefix(t *testing.T) {
 	}
 }
 
-func TestHostPath(t *testing.T) {
+func TestSchemeHostPath(t *testing.T) {
 	tests := []routeTest{
 		{
 			title:        ""Host and Path route, match"",
 			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
 			vars:         map[string]string{},
-			host:         """",
-			path:         """",
+			scheme:       ""http"",
+			host:         ""aaa.bbb.ccc"",
+			path:         ""/111/222/333"",
+			pathTemplate: `/111/222/333`,
+			hostTemplate: `aaa.bbb.ccc`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Scheme, Host, and Path route, match"",
+			route:        new(Route).Schemes(""https"").Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:      newRequest(""GET"", ""https://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{},
+			scheme:       ""https"",
+			host:         ""aaa.bbb.ccc"",
+			path:         ""/111/222/333"",
 			pathTemplate: `/111/222/333`,
 			hostTemplate: `aaa.bbb.ccc`,
 			shouldMatch:  true,
@@ -534,8 +549,9 @@ func TestHostPath(t *testing.T) {
 			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
 			vars:         map[string]string{},
-			host:         """",
-			path:         """",
+			scheme:       ""http"",
+			host:         ""aaa.bbb.ccc"",
+			path:         ""/111/222/333"",
 			pathTemplate: `/111/222/333`,
 			hostTemplate: `aaa.bbb.ccc`,
 			shouldMatch:  false,
@@ -545,6 +561,19 @@ func TestHostPath(t *testing.T) {
 			route:        new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
 			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
 			vars:         map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			scheme:       ""http"",
+			host:         ""aaa.bbb.ccc"",
+			path:         ""/111/222/333"",
+			pathTemplate: `/111/{v2:[0-9]{3}}/333`,
+			hostTemplate: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Scheme, Host, and Path route with host and path patterns, match"",
+			route:        new(Route).Schemes(""ftp"", ""ssss"").Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:      newRequest(""GET"", ""ssss://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			scheme:       ""ftp"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
 			pathTemplate: `/111/{v2:[0-9]{3}}/333`,
@@ -556,6 +585,7 @@ func TestHostPath(t *testing.T) {
 			route:        new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
 			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
 			vars:         map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
 			pathTemplate: `/111/{v2:[0-9]{3}}/333`,
@@ -567,6 +597,7 @@ func TestHostPath(t *testing.T) {
 			route:        new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
 			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
 			vars:         map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
 			pathTemplate: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
@@ -578,6 +609,7 @@ func TestHostPath(t *testing.T) {
 			route:        new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
 			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
 			vars:         map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
 			pathTemplate: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
@@ -649,7 +681,6 @@ func TestHeaders(t *testing.T) {
 		testRoute(t, test)
 		testTemplate(t, test)
 	}
-
 }
 
 func TestMethods(t *testing.T) {
@@ -938,30 +969,43 @@ func TestSchemes(t *testing.T) {
 	tests := []routeTest{
 		// Schemes
 		{
-			title:       ""Schemes route, match https"",
-			route:       new(Route).Schemes(""https"", ""ftp""),
+			title:       ""Schemes route, default scheme, match http, build http"",
+			route:       new(Route).Host(""localhost""),
+			request:     newRequest(""GET"", ""http://localhost""),
+			scheme:      ""http"",
+			host:        ""localhost"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Schemes route, match https, build https"",
+			route:       new(Route).Schemes(""https"", ""ftp"").Host(""localhost""),
 			request:     newRequest(""GET"", ""https://localhost""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
+			scheme:      ""https"",
+			host:        ""localhost"",
 			shouldMatch: true,
 		},
 		{
-			title:       ""Schemes route, match ftp"",
-			route:       new(Route).Schemes(""https"", ""ftp""),
+			title:       ""Schemes route, match ftp, build https"",
+			route:       new(Route).Schemes(""https"", ""ftp"").Host(""localhost""),
 			request:     newRequest(""GET"", ""ftp://localhost""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
+			scheme:      ""https"",
+			host:        ""localhost"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Schemes route, match ftp, build ftp"",
+			route:       new(Route).Schemes(""ftp"", ""https"").Host(""localhost""),
+			request:     newRequest(""GET"", ""ftp://localhost""),
+			scheme:      ""ftp"",
+			host:        ""localhost"",
 			shouldMatch: true,
 		},
 		{
 			title:       ""Schemes route, bad scheme"",
-			route:       new(Route).Schemes(""https"", ""ftp""),
+			route:       new(Route).Schemes(""https"", ""ftp"").Host(""localhost""),
 			request:     newRequest(""GET"", ""http://localhost""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
+			scheme:      ""https"",
+			host:        ""localhost"",
 			shouldMatch: false,
 		},
 	}
@@ -1448,10 +1492,15 @@ func testRoute(t *testing.T, test routeTest) {
 	route := test.route
 	vars := test.vars
 	shouldMatch := test.shouldMatch
-	host := test.host
-	path := test.path
-	url := test.host + test.path
 	shouldRedirect := test.shouldRedirect
+	uri := url.URL{
+		Scheme: test.scheme,
+		Host:   test.host,
+		Path:   test.path,
+	}
+	if uri.Scheme == """" {
+		uri.Scheme = ""http""
+	}
 
 	var match RouteMatch
 	ok := route.Match(request, &match)
@@ -1464,28 +1513,51 @@ func testRoute(t *testing.T, test routeTest) {
 		return
 	}
 	if shouldMatch {
-		if test.vars != nil && !stringMapEqual(test.vars, match.Vars) {
+		if vars != nil && !stringMapEqual(vars, match.Vars) {
 			t.Errorf(""(%v) Vars not equal: expected %v, got %v"", test.title, vars, match.Vars)
 			return
 		}
-		if host != """" {
-			u, _ := test.route.URLHost(mapToPairs(match.Vars)...)
-			if host != u.Host {
-				t.Errorf(""(%v) URLHost not equal: expected %v, got %v -- %v"", test.title, host, u.Host, getRouteTemplate(route))
+		if test.scheme != """" {
+			u, err := route.URL(mapToPairs(match.Vars)...)
+			if err != nil {
+				t.Fatalf(""(%v) URL error: %v -- %v"", test.title, err, getRouteTemplate(route))
+			}
+			if uri.Scheme != u.Scheme {
+				t.Errorf(""(%v) URLScheme not equal: expected %v, got %v"", test.title, uri.Scheme, u.Scheme)
+				return
+			}
+		}
+		if test.host != """" {
+			u, err := test.route.URLHost(mapToPairs(match.Vars)...)
+			if err != nil {
+				t.Fatalf(""(%v) URLHost error: %v -- %v"", test.title, err, getRouteTemplate(route))
+			}
+			if uri.Scheme != u.Scheme {
+				t.Errorf(""(%v) URLHost scheme not equal: expected %v, got %v -- %v"", test.title, uri.Scheme, u.Scheme, getRouteTemplate(route))
+				return
+			}
+			if uri.Host != u.Host {
+				t.Errorf(""(%v) URLHost host not equal: expected %v, got %v -- %v"", test.title, uri.Host, u.Host, getRouteTemplate(route))
 				return
 			}
 		}
-		if path != """" {
-			u, _ := route.URLPath(mapToPairs(match.Vars)...)
-			if path != u.Path {
-				t.Errorf(""(%v) URLPath not equal: expected %v, got %v -- %v"", test.title, path, u.Path, getRouteTemplate(route))
+		if test.path != """" {
+			u, err := route.URLPath(mapToPairs(match.Vars)...)
+			if err != nil {
+				t.Fatalf(""(%v) URLPath error: %v -- %v"", test.title, err, getRouteTemplate(route))
+			}
+			if uri.Path != u.Path {
+				t.Errorf(""(%v) URLPath not equal: expected %v, got %v -- %v"", test.title, uri.Path, u.Path, getRouteTemplate(route))
 				return
 			}
 		}
-		if url != """" {
-			u, _ := route.URL(mapToPairs(match.Vars)...)
-			if url != u.Host+u.Path {
-				t.Errorf(""(%v) URL not equal: expected %v, got %v -- %v"", test.title, url, u.Host+u.Path, getRouteTemplate(route))
+		if test.host != """" && test.path != """" {
+			u, err := route.URL(mapToPairs(match.Vars)...)
+			if err != nil {
+				t.Fatalf(""(%v) URL error: %v -- %v"", test.title, err, getRouteTemplate(route))
+			}
+			if expected, got := uri.String(), u.String(); expected != got {
+				t.Errorf(""(%v) URL not equal: expected %v, got %v -- %v"", test.title, expected, got, getRouteTemplate(route))
 				return
 			}
 		}",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=bcd8bc72b08df0f70df986b97f95590779502d31,https://github.com/gorilla/mux/blob/bcd8bc72b08df0f70df986b97f95590779502d31/mux_test.go
bcd8bc72b08df0f70df986b97f95590779502d31,56dcbbdc50ad865e69125f250a865e67a8fab9cd,route.go,,"Sun, 21 May 2017 04:50:13 GMT",modified,15,4,19,"@@ -31,6 +31,8 @@ type Route struct {
 	skipClean bool
 	// If true, ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to""
 	useEncodedPath bool
+	// The scheme used when building URLs.
+	buildScheme string
 	// If true, this route never matches: it is only used to build URLs.
 	buildOnly bool
 	// The name used to build URLs.
@@ -394,6 +396,9 @@ func (r *Route) Schemes(schemes ...string) *Route {
 	for k, v := range schemes {
 		schemes[k] = strings.ToLower(v)
 	}
+	if r.buildScheme == """" && len(schemes) > 0 {
+		r.buildScheme = schemes[0]
+	}
 	return r.addMatcher(schemeMatcher(schemes))
 }
 
@@ -478,11 +483,13 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 	}
 	var scheme, host, path string
 	if r.regexp.host != nil {
-		// Set a default scheme.
-		scheme = ""http""
 		if host, err = r.regexp.host.url(values); err != nil {
 			return nil, err
 		}
+		scheme = ""http""
+		if r.buildScheme != """" {
+			scheme = r.buildScheme
+		}
 	}
 	if r.regexp.path != nil {
 		if path, err = r.regexp.path.url(values); err != nil {
@@ -514,10 +521,14 @@ func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
 	if err != nil {
 		return nil, err
 	}
-	return &url.URL{
+	u := &url.URL{
 		Scheme: ""http"",
 		Host:   host,
-	}, nil
+	}
+	if r.buildScheme != """" {
+		u.Scheme = r.buildScheme
+	}
+	return u, nil
 }
 
 // URLPath builds the path part of the URL for a route. See Route.URL().",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=bcd8bc72b08df0f70df986b97f95590779502d31,https://github.com/gorilla/mux/blob/bcd8bc72b08df0f70df986b97f95590779502d31/route.go
751308a60a84015f1232e8aa1fa7f4f4ecb2dd0f,56c67134f897e3ac421ea9995b0acfab71b42ffc,README.md,,"Sat, 20 May 2017 22:55:46 GMT",modified,15,4,19,"@@ -179,6 +179,7 @@ package main
 import (
     ""fmt""
     ""net/http""
+    ""strings""
 
     ""github.com/gorilla/mux""
 )
@@ -190,15 +191,25 @@ func handler(w http.ResponseWriter, r *http.Request) {
 func main() {
     r := mux.NewRouter()
     r.HandleFunc(""/"", handler)
-    r.HandleFunc(""/products"", handler)
-    r.HandleFunc(""/articles"", handler)
-    r.HandleFunc(""/articles/{id}"", handler)
+    r.Methods(""POST"").HandleFunc(""/products"", handler)
+    r.Methods(""GET"").HandleFunc(""/articles"", handler)
+    r.Methods(""GET"", ""PUT"").HandleFunc(""/articles/{id}"", handler)
     r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
         t, err := route.GetPathTemplate()
         if err != nil {
             return err
         }
-        fmt.Println(t)
+        // p will contain regular expression is compatible with regular expression in Perl, Python, and other languages.
+        // for instance the regular expression for path '/articles/{id}' will be '^/articles/(?P<v0>[^/]+)$'
+        p, err := route.GetPathRegexp()
+        if err != nil {
+            return err
+        }
+        m, err := route.GetMethods()
+        if err != nil {
+            return err
+        }
+        fmt.Println(strings.Join(m, "",""), t, p)
         return nil
     })
     http.Handle(""/"", r)",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=751308a60a84015f1232e8aa1fa7f4f4ecb2dd0f,https://github.com/gorilla/mux/blob/751308a60a84015f1232e8aa1fa7f4f4ecb2dd0f/README.md
b552615e22224a497dda4bae89940eeb05c0cd53,d0584dfc0121ec77e03e1837fef1981424e5298a,mux_test.go,,"Sat, 20 May 2017 22:55:46 GMT",modified,23,0,23,"@@ -35,6 +35,7 @@ type routeTest struct {
 	path           string            // the expected path of the match
 	pathTemplate   string            // the expected path template to match
 	hostTemplate   string            // the expected host template to match
+	methods        []string          // the expected route methods
 	pathRegexp     string            // the expected path regexp
 	shouldMatch    bool              // whether the request is expected to match the route at all
 	shouldRedirect bool              // whether the request should result in a redirect
@@ -660,6 +661,7 @@ func TestMethods(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			methods:     []string{""GET"", ""POST""},
 			shouldMatch: true,
 		},
 		{
@@ -669,6 +671,7 @@ func TestMethods(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			methods:     []string{""GET"", ""POST""},
 			shouldMatch: true,
 		},
 		{
@@ -678,13 +681,25 @@ func TestMethods(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			methods:     []string{""GET"", ""POST""},
 			shouldMatch: false,
 		},
+		{
+			title:       ""Route without methods"",
+			route:       new(Route),
+			request:     newRequest(""PUT"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			methods:     []string{},
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
+		testMethods(t, test)
 	}
 }
 
@@ -1512,6 +1527,14 @@ func testTemplate(t *testing.T, test routeTest) {
 	}
 }
 
+func testMethods(t *testing.T, test routeTest) {
+	route := test.route
+	methods, _ := route.GetMethods()
+	if strings.Join(methods, "","") != strings.Join(test.methods, "","") {
+		t.Errorf(""(%v) GetMethods not equal: expected %v, got %v"", test.title, test.methods, methods)
+	}
+}
+
 func testRegexp(t *testing.T, test routeTest) {
 	route := test.route
 	routePathRegexp, regexpErr := route.GetPathRegexp()",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=b552615e22224a497dda4bae89940eeb05c0cd53,https://github.com/gorilla/mux/blob/b552615e22224a497dda4bae89940eeb05c0cd53/mux_test.go
b552615e22224a497dda4bae89940eeb05c0cd53,a7c7d8c6f49abb9fbc95bc62afa1a53c3d20ab87,route.go,,"Sat, 20 May 2017 22:55:46 GMT",modified,16,0,16,"@@ -572,6 +572,22 @@ func (r *Route) GetPathRegexp() (string, error) {
 	return r.regexp.path.regexp.String(), nil
 }
 
+// GetMethods returns the methods the route matches against
+// This is useful for building simple REST API documentation and for instrumentation
+// against third-party services.
+// An empty list will be returned if route does not have methods.
+func (r *Route) GetMethods() ([]string, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	for _, m := range r.matchers {
+		if methods, ok := m.(methodMatcher); ok {
+			return []string(methods), nil
+		}
+	}
+	return nil, nil
+}
+
 // GetHostTemplate returns the template used to build the
 // route match.
 // This is useful for building simple REST API documentation and for instrumentation",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=b552615e22224a497dda4bae89940eeb05c0cd53,https://github.com/gorilla/mux/blob/b552615e22224a497dda4bae89940eeb05c0cd53/route.go
1856953e530eab2cb8793c42c7e9c1e6b1dc2709,1ccc920b1abd6662a4d0c40700041817f4581f7b,mux_test.go,,"Sat, 20 May 2017 22:55:46 GMT",modified,21,0,21,"@@ -35,6 +35,7 @@ type routeTest struct {
 	path           string            // the expected path of the match
 	pathTemplate   string            // the expected path template to match
 	hostTemplate   string            // the expected host template to match
+	pathRegexp     string            // the expected path regexp
 	shouldMatch    bool              // whether the request is expected to match the route at all
 	shouldRedirect bool              // whether the request should result in a redirect
 }
@@ -270,6 +271,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/111"",
 			pathTemplate: `/111/`,
+			pathRegexp:   `^/111/$`,
 			shouldMatch:  false,
 		},
 		{
@@ -290,6 +292,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
+			pathRegexp:   `^/$`,
 			shouldMatch:  true,
 		},
 		{
@@ -333,6 +336,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/111/222/333"",
 			pathTemplate: `/111/{v1:[0-9]{3}}/333`,
+			pathRegexp:   `^/111/(?P<v0>[0-9]{3})/333$`,
 			shouldMatch:  false,
 		},
 		{
@@ -343,6 +347,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/111/222/333"",
 			pathTemplate: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
+			pathRegexp:   `^/(?P<v0>[0-9]{3})/(?P<v1>[0-9]{3})/(?P<v2>[0-9]{3})$`,
 			shouldMatch:  true,
 		},
 		{
@@ -353,6 +358,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/111/222/333"",
 			pathTemplate: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
+			pathRegexp:   `^/(?P<v0>[0-9]{3})/(?P<v1>[0-9]{3})/(?P<v2>[0-9]{3})$`,
 			shouldMatch:  false,
 		},
 		{
@@ -363,6 +369,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/a/product_name/1"",
 			pathTemplate: `/{category:a|(?:b/c)}/{product}/{id:[0-9]+}`,
+			pathRegexp:   `^/(?P<v0>a|(?:b/c))/(?P<v1>[^/]+)/(?P<v2>[0-9]+)$`,
 			shouldMatch:  true,
 		},
 		{
@@ -373,6 +380,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/111/222/333"",
 			pathTemplate: `/111/{v-1:[0-9]{3}}/333`,
+			pathRegexp:   `^/111/(?P<v0>[0-9]{3})/333$`,
 			shouldMatch:  true,
 		},
 		{
@@ -383,6 +391,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/111/222/333"",
 			pathTemplate: `/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}`,
+			pathRegexp:   `^/(?P<v0>[0-9]{3})/(?P<v1>[0-9]{3})/(?P<v2>[0-9]{3})$`,
 			shouldMatch:  true,
 		},
 		{
@@ -393,6 +402,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/a/product_name/1"",
 			pathTemplate: `/{product-category:a|(?:b/c)}/{product-name}/{product-id:[0-9]+}`,
+			pathRegexp:   `^/(?P<v0>a|(?:b/c))/(?P<v1>[^/]+)/(?P<v2>[0-9]+)$`,
 			shouldMatch:  true,
 		},
 		{
@@ -403,6 +413,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/daily-2016-01-01"",
 			pathTemplate: `/{type:(?i:daily|mini|variety)}-{date:\d{4,4}-\d{2,2}-\d{2,2}}`,
+			pathRegexp:   `^/(?P<v0>(?i:daily|mini|variety))-(?P<v1>\d{4,4}-\d{2,2}-\d{2,2})$`,
 			shouldMatch:  true,
 		},
 		{
@@ -413,6 +424,7 @@ func TestPath(t *testing.T) {
 			host:         """",
 			path:         ""/111/222"",
 			pathTemplate: `/{v1:[0-9]*}{v2:[a-z]*}/{v3:[0-9]*}`,
+			pathRegexp:   `^/(?P<v0>[0-9]*)(?P<v1>[a-z]*)/(?P<v2>[0-9]*)$`,
 			shouldMatch:  true,
 		},
 	}
@@ -421,6 +433,7 @@ func TestPath(t *testing.T) {
 		testRoute(t, test)
 		testTemplate(t, test)
 		testUseEscapedRoute(t, test)
+		testRegexp(t, test)
 	}
 }
 
@@ -1499,6 +1512,14 @@ func testTemplate(t *testing.T, test routeTest) {
 	}
 }
 
+func testRegexp(t *testing.T, test routeTest) {
+	route := test.route
+	routePathRegexp, regexpErr := route.GetPathRegexp()
+	if test.pathRegexp != """" && regexpErr == nil && routePathRegexp != test.pathRegexp {
+		t.Errorf(""(%v) GetPathRegexp not equal: expected %v, got %v"", test.title, test.pathRegexp, routePathRegexp)
+	}
+}
+
 type TestA301ResponseWriter struct {
 	hh     http.Header
 	status int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=1856953e530eab2cb8793c42c7e9c1e6b1dc2709,https://github.com/gorilla/mux/blob/1856953e530eab2cb8793c42c7e9c1e6b1dc2709/mux_test.go
1856953e530eab2cb8793c42c7e9c1e6b1dc2709,d3ba6cd3dfa4cc5aeac08176e1913928aeedc63e,route.go,,"Sat, 20 May 2017 22:55:46 GMT",modified,14,0,14,"@@ -558,6 +558,20 @@ func (r *Route) GetPathTemplate() (string, error) {
 	return r.regexp.path.template, nil
 }
 
+// GetPathRegexp returns the expanded regular expression used to match route path.
+// This is useful for building simple REST API documentation and for instrumentation
+// against third-party services.
+// An error will be returned if the route does not define a path.
+func (r *Route) GetPathRegexp() (string, error) {
+	if r.err != nil {
+		return """", r.err
+	}
+	if r.regexp == nil || r.regexp.path == nil {
+		return """", errors.New(""mux: route does not have a path"")
+	}
+	return r.regexp.path.regexp.String(), nil
+}
+
 // GetHostTemplate returns the template used to build the
 // route match.
 // This is useful for building simple REST API documentation and for instrumentation",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=1856953e530eab2cb8793c42c7e9c1e6b1dc2709,https://github.com/gorilla/mux/blob/1856953e530eab2cb8793c42c7e9c1e6b1dc2709/route.go
4c1c3952b7d9d0a061a3fa7b36fd373ba0398ebc,1dec7abefdd9745b9db143bb333edf2877fba76a,mux_test.go,,"Thu, 27 Apr 2017 04:12:50 GMT",modified,1,1,2,"@@ -1393,7 +1393,7 @@ func TestSubrouterErrorHandling(t *testing.T) {
 func TestPanicOnCapturingGroups(t *testing.T) {
 	defer func() {
 		if recover() == nil {
-			t.Errorf(""(Test that capturing groups now fail fast) Expected panic, however test completed sucessfully.\n"")
+			t.Errorf(""(Test that capturing groups now fail fast) Expected panic, however test completed successfully.\n"")
 		}
 	}()
 	NewRouter().NewRoute().Path(""/{type:(promo|special)}/{promoId}.json"")",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=4c1c3952b7d9d0a061a3fa7b36fd373ba0398ebc,https://github.com/gorilla/mux/blob/4c1c3952b7d9d0a061a3fa7b36fd373ba0398ebc/mux_test.go
599cba5e7b6137d46ddf58fb1765f5d928e69604,522156dccff20b49d8d49ca2e5054dd17ca13ab6,bench_test.go,,"Tue, 28 Feb 2017 22:43:54 GMT",modified,1,1,2,"@@ -24,7 +24,7 @@ func BenchmarkMux(b *testing.B) {
 func BenchmarkMuxAlternativeInRegexp(b *testing.B) {
 	router := new(Router)
 	handler := func(w http.ResponseWriter, r *http.Request) {}
-	router.HandleFunc(""/v1/{v1:(a|b)}"", handler)
+	router.HandleFunc(""/v1/{v1:(?:a|b)}"", handler)
 
 	requestA, _ := http.NewRequest(""GET"", ""/v1/a"", nil)
 	requestB, _ := http.NewRequest(""GET"", ""/v1/b"", nil)",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=599cba5e7b6137d46ddf58fb1765f5d928e69604,https://github.com/gorilla/mux/blob/599cba5e7b6137d46ddf58fb1765f5d928e69604/bench_test.go
ad4ce0eb1694e1a48fd8e2e764dd0e1aec118326,5544c1fd6ba4f9f4abc801c114cca215ad5135c3,route.go,,"Tue, 28 Feb 2017 03:44:49 GMT",modified,1,1,2,"@@ -153,7 +153,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 	}
 	r.regexp = r.getRegexpGroup()
 	if !matchHost && !matchQuery {
-		if tpl == ""/"" && (len(tpl) == 0 || tpl[0] != '/') {
+		if len(tpl) > 0 && tpl[0] != '/' {
 			return fmt.Errorf(""mux: path must start with a slash, got %q"", tpl)
 		}
 		if r.regexp.path != nil {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=ad4ce0eb1694e1a48fd8e2e764dd0e1aec118326,https://github.com/gorilla/mux/blob/ad4ce0eb1694e1a48fd8e2e764dd0e1aec118326/route.go
999ef73f5d50979cf6d12afed1726325b63f9570,cdab8784d11dbe7afca91183ff67a6b0208f3863,README.md,,"Thu, 23 Feb 2017 20:25:54 GMT",modified,1,0,1,"@@ -2,6 +2,7 @@ gorilla/mux
 ===
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
+[![Sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
 
 ![Gorilla Logo](http://www.gorillatoolkit.org/static/images/gorilla-icon-64.png)
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=999ef73f5d50979cf6d12afed1726325b63f9570,https://github.com/gorilla/mux/blob/999ef73f5d50979cf6d12afed1726325b63f9570/README.md
89d16fe9a0996a117f467bf04085b1660398a418,cdab8784d11dbe7afca91183ff67a6b0208f3863,README.md,,"Thu, 23 Feb 2017 19:57:28 GMT",modified,1,0,1,"@@ -2,6 +2,7 @@ gorilla/mux
 ===
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
+[![Sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
 
 ![Gorilla Logo](http://www.gorillatoolkit.org/static/images/gorilla-icon-64.png)
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=89d16fe9a0996a117f467bf04085b1660398a418,https://github.com/gorilla/mux/blob/89d16fe9a0996a117f467bf04085b1660398a418/README.md
94e7d24fd285520f3d12ae998f7fdd6b5393d453,ca377e61c62217aa70207b41aa56845bb25e1fb2,.travis.yml,,"Fri, 17 Feb 2017 19:26:16 GMT",modified,1,0,1,"@@ -9,6 +9,7 @@ matrix:
     - go: 1.5
     - go: 1.6
     - go: 1.7
+    - go: 1.8
     - go: tip
 
 install:",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=94e7d24fd285520f3d12ae998f7fdd6b5393d453,https://github.com/gorilla/mux/blob/94e7d24fd285520f3d12ae998f7fdd6b5393d453/.travis.yml
392c28fe23e1c45ddba891b0320b3b5df220beea,00daf4a721c8ef91b71eaca08e5287c309915914,doc.go,,"Wed, 18 Jan 2017 13:43:44 GMT",modified,5,0,5,"@@ -57,6 +57,11 @@ calling mux.Vars():
 	vars := mux.Vars(request)
 	category := vars[""category""]
 
+Note that if any capturing groups are present, mux will panic() during parsing. To prevent
+this, convert any capturing groups to non-capturing, e.g. change ""/{sort:(asc|desc)}"" to
+""/{sort:(?:asc|desc)}"". This is a change from prior versions which behaved unpredictably
+when capturing groups were present.
+
 And this is all you need to know about the basic usage. More advanced options
 are explained below.
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=392c28fe23e1c45ddba891b0320b3b5df220beea,https://github.com/gorilla/mux/blob/392c28fe23e1c45ddba891b0320b3b5df220beea/doc.go
392c28fe23e1c45ddba891b0320b3b5df220beea,405aca6de94b86f63ee6da46d3a273d0e01481b6,mux_test.go,,"Wed, 18 Jan 2017 13:43:44 GMT",modified,10,0,10,"@@ -1389,6 +1389,16 @@ func TestSubrouterErrorHandling(t *testing.T) {
 	}
 }
 
+// See: https://github.com/gorilla/mux/issues/200
+func TestPanicOnCapturingGroups(t *testing.T) {
+	defer func() {
+		if recover() == nil {
+			t.Errorf(""(Test that capturing groups now fail fast) Expected panic, however test completed sucessfully.\n"")
+		}
+	}()
+	NewRouter().NewRoute().Path(""/{type:(promo|special)}/{promoId}.json"")
+}
+
 // ----------------------------------------------------------------------------
 // Helpers
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=392c28fe23e1c45ddba891b0320b3b5df220beea,https://github.com/gorilla/mux/blob/392c28fe23e1c45ddba891b0320b3b5df220beea/mux_test.go
392c28fe23e1c45ddba891b0320b3b5df220beea,0189ad346fd1c2b4e26850af12f4f8659cd863b7,regexp.go,,"Wed, 18 Jan 2017 13:43:44 GMT",modified,7,0,7,"@@ -109,6 +109,13 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash,
 	if errCompile != nil {
 		return nil, errCompile
 	}
+
+	// Check for capturing groups which used to work in older versions
+	if reg.NumSubexp() != len(idxs)/2 {
+		panic(fmt.Sprintf(""route %s contains capture groups in its regexp. "", template) +
+			""Only non-capturing groups are accepted: e.g. (?:pattern) instead of (pattern)"")
+	}
+
 	// Done!
 	return &routeRegexp{
 		template:       template,",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=392c28fe23e1c45ddba891b0320b3b5df220beea,https://github.com/gorilla/mux/blob/392c28fe23e1c45ddba891b0320b3b5df220beea/regexp.go
cafdb65e9ebf0275ed34de6b54f316e440a756bb,94d396ca41682197e3012feab24c769102bf3d46,README.md,,"Wed, 18 Jan 2017 13:43:23 GMT",modified,37,0,37,"@@ -23,6 +23,7 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 * [Install](#install)
 * [Examples](#examples)
 * [Matching Routes](#matching-routes)
+* [Listing Routes](#listing-routes)
 * [Static Files](#static-files)
 * [Registered URLs](#registered-urls)
 * [Full Example](#full-example)
@@ -167,6 +168,42 @@ s.HandleFunc(""/{key}/"", ProductHandler)
 s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 ```
 
+### Listing Routes
+
+Routes on a mux can be listed using the Router.Walk method—useful for generating documentation:
+
+```go
+package main
+
+import (
+    ""fmt""
+    ""net/http""
+
+    ""github.com/gorilla/mux""
+)
+
+func handler(w http.ResponseWriter, r *http.Request) {
+    return
+}
+
+func main() {
+    r := mux.NewRouter()
+    r.HandleFunc(""/"", handler)
+    r.HandleFunc(""/products"", handler)
+    r.HandleFunc(""/articles"", handler)
+    r.HandleFunc(""/articles/{id}"", handler)
+    r.Walk(func(route *mux.Route, router *mux.Router, ancestors []*mux.Route) error {
+        t, err := route.GetPathTemplate()
+        if err != nil {
+            return err
+        }
+        fmt.Println(t)
+        return nil
+    })
+    http.Handle(""/"", r)
+}
+```
+
 ### Static Files
 
 Note that the path provided to `PathPrefix()` represents a ""wildcard"": calling",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=cafdb65e9ebf0275ed34de6b54f316e440a756bb,https://github.com/gorilla/mux/blob/cafdb65e9ebf0275ed34de6b54f316e440a756bb/README.md
b12896167c61cb7a17ee5f15c2ba0729d78793db,5f54d48139648d21cf15297517f504bcef14d3b4,README.md,,"Tue, 17 Jan 2017 07:01:07 GMT",modified,5,2,7,"@@ -65,8 +65,11 @@ r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
 The names are used to create a map of route variables which can be retrieved calling `mux.Vars()`:
 
 ```go
-vars := mux.Vars(request)
-category := vars[""category""]
+func ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) {
+	vars := mux.Vars(r)
+	w.WriteHeader(http.StatusOK)
+	fmt.Fprintf(w, ""Category: %v\n"", vars[""category""])
+}
 ```
 
 And this is all you need to know about the basic usage. More advanced options are explained below.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=b12896167c61cb7a17ee5f15c2ba0729d78793db,https://github.com/gorilla/mux/blob/b12896167c61cb7a17ee5f15c2ba0729d78793db/README.md
34dda716af12ba79ed40ce1f66b102ff75dc3411,b4b049efc60b6f0bb7c304c7b71833fb06b521a1,mux_test.go,,"Tue, 17 Jan 2017 06:41:11 GMT",modified,58,0,58,"@@ -1017,6 +1017,9 @@ func TestBuildVarsFunc(t *testing.T) {
 func TestSubRouter(t *testing.T) {
 	subrouter1 := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
 	subrouter2 := new(Route).PathPrefix(""/foo/{v1}"").Subrouter()
+	subrouter3 := new(Route).PathPrefix(""/foo"").Subrouter()
+	subrouter4 := new(Route).PathPrefix(""/foo/bar"").Subrouter()
+	subrouter5 := new(Route).PathPrefix(""/{category}"").Subrouter()
 
 	tests := []routeTest{
 		{
@@ -1057,6 +1060,61 @@ func TestSubRouter(t *testing.T) {
 			pathTemplate: `/foo/{v1}/baz/{v2}`,
 			shouldMatch:  false,
 		},
+		{
+			route:        subrouter3.Path(""/""),
+			request:      newRequest(""GET"", ""http://localhost/foo/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo/"",
+			pathTemplate: `/foo/`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter3.Path(""""),
+			request:      newRequest(""GET"", ""http://localhost/foo""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo"",
+			pathTemplate: `/foo`,
+			shouldMatch:  true,
+		},
+
+		{
+			route:        subrouter4.Path(""/""),
+			request:      newRequest(""GET"", ""http://localhost/foo/bar/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo/bar/"",
+			pathTemplate: `/foo/bar/`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter4.Path(""""),
+			request:      newRequest(""GET"", ""http://localhost/foo/bar""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo/bar"",
+			pathTemplate: `/foo/bar`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter5.Path(""/""),
+			request:      newRequest(""GET"", ""http://localhost/baz/""),
+			vars:         map[string]string{""category"": ""baz""},
+			host:         """",
+			path:         ""/baz/"",
+			pathTemplate: `/{category}/`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter5.Path(""""),
+			request:      newRequest(""GET"", ""http://localhost/baz""),
+			vars:         map[string]string{""category"": ""baz""},
+			host:         """",
+			path:         ""/baz"",
+			pathTemplate: `/{category}`,
+			shouldMatch:  true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=34dda716af12ba79ed40ce1f66b102ff75dc3411,https://github.com/gorilla/mux/blob/34dda716af12ba79ed40ce1f66b102ff75dc3411/mux_test.go
34dda716af12ba79ed40ce1f66b102ff75dc3411,922191592a85a8d5c8e141fbf1a77436220d9a15,route.go,,"Tue, 17 Jan 2017 06:41:11 GMT",modified,1,1,2,"@@ -153,7 +153,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 	}
 	r.regexp = r.getRegexpGroup()
 	if !matchHost && !matchQuery {
-		if len(tpl) == 0 || tpl[0] != '/' {
+		if tpl == ""/"" && (len(tpl) == 0 || tpl[0] != '/') {
 			return fmt.Errorf(""mux: path must start with a slash, got %q"", tpl)
 		}
 		if r.regexp.path != nil {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=34dda716af12ba79ed40ce1f66b102ff75dc3411,https://github.com/gorilla/mux/blob/34dda716af12ba79ed40ce1f66b102ff75dc3411/route.go
b9ff34f617bc0e162f0ebc5f4902303b4ac4889e,b4b049efc60b6f0bb7c304c7b71833fb06b521a1,mux_test.go,,"Tue, 17 Jan 2017 05:11:35 GMT",modified,53,5,58,"@@ -1018,6 +1018,8 @@ func TestSubRouter(t *testing.T) {
 	subrouter1 := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
 	subrouter2 := new(Route).PathPrefix(""/foo/{v1}"").Subrouter()
 	subrouter3 := new(Route).PathPrefix(""/foo"").Subrouter()
+	subrouter4 := new(Route).PathPrefix(""/foo/bar"").Subrouter()
+	subrouter5 := new(Route).PathPrefix(""/{category}"").Subrouter()
 
 	tests := []routeTest{
 		{
@@ -1049,6 +1051,15 @@ func TestSubRouter(t *testing.T) {
 			pathTemplate: `/foo/{v1}/baz/{v2}`,
 			shouldMatch:  true,
 		},
+		{
+			route:        subrouter2.Path(""/baz/{v2}""),
+			request:      newRequest(""GET"", ""http://localhost/foo/bar""),
+			vars:         map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:         """",
+			path:         ""/foo/bar/baz/ding"",
+			pathTemplate: `/foo/{v1}/baz/{v2}`,
+			shouldMatch:  false,
+		},
 		{
 			route:        subrouter3.Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/""),
@@ -1059,13 +1070,50 @@ func TestSubRouter(t *testing.T) {
 			shouldMatch:  true,
 		},
 		{
-			route:        subrouter2.Path(""/baz/{v2}""),
+			route:        subrouter3.Path(""""),
+			request:      newRequest(""GET"", ""http://localhost/foo""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo"",
+			pathTemplate: `/foo`,
+			shouldMatch:  true,
+		},
+
+		{
+			route:        subrouter4.Path(""/""),
+			request:      newRequest(""GET"", ""http://localhost/foo/bar/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo/bar/"",
+			pathTemplate: `/foo/bar/`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter4.Path(""""),
 			request:      newRequest(""GET"", ""http://localhost/foo/bar""),
-			vars:         map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			vars:         map[string]string{},
 			host:         """",
-			path:         ""/foo/bar/baz/ding"",
-			pathTemplate: `/foo/{v1}/baz/{v2}`,
-			shouldMatch:  false,
+			path:         ""/foo/bar"",
+			pathTemplate: `/foo/bar`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter5.Path(""/""),
+			request:      newRequest(""GET"", ""http://localhost/baz/""),
+			vars:         map[string]string{""category"": ""baz""},
+			host:         """",
+			path:         ""/baz/"",
+			pathTemplate: `/{category}/`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter5.Path(""""),
+			request:      newRequest(""GET"", ""http://localhost/baz""),
+			vars:         map[string]string{""category"": ""baz""},
+			host:         """",
+			path:         ""/baz"",
+			pathTemplate: `/{category}`,
+			shouldMatch:  true,
 		},
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=b9ff34f617bc0e162f0ebc5f4902303b4ac4889e,https://github.com/gorilla/mux/blob/b9ff34f617bc0e162f0ebc5f4902303b4ac4889e/mux_test.go
293ebe14936bf5aa585139c72ea2f28d4164f984,bbde2907a338248aece533be22c92557e79c5292,mux_test.go,,"Mon, 16 Jan 2017 05:47:00 GMT",modified,10,0,10,"@@ -1017,6 +1017,7 @@ func TestBuildVarsFunc(t *testing.T) {
 func TestSubRouter(t *testing.T) {
 	subrouter1 := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
 	subrouter2 := new(Route).PathPrefix(""/foo/{v1}"").Subrouter()
+	subrouter3 := new(Route).PathPrefix(""/foo"").Subrouter()
 
 	tests := []routeTest{
 		{
@@ -1048,6 +1049,15 @@ func TestSubRouter(t *testing.T) {
 			pathTemplate: `/foo/{v1}/baz/{v2}`,
 			shouldMatch:  true,
 		},
+		{
+			route:        subrouter3.Path(""/""),
+			request:      newRequest(""GET"", ""http://localhost/foo/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/foo/"",
+			pathTemplate: `/foo/`,
+			shouldMatch:  true,
+		},
 		{
 			route:        subrouter2.Path(""/baz/{v2}""),
 			request:      newRequest(""GET"", ""http://localhost/foo/bar""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=293ebe14936bf5aa585139c72ea2f28d4164f984,https://github.com/gorilla/mux/blob/293ebe14936bf5aa585139c72ea2f28d4164f984/mux_test.go
293ebe14936bf5aa585139c72ea2f28d4164f984,922191592a85a8d5c8e141fbf1a77436220d9a15,route.go,,"Mon, 16 Jan 2017 05:47:00 GMT",modified,1,1,2,"@@ -153,7 +153,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 	}
 	r.regexp = r.getRegexpGroup()
 	if !matchHost && !matchQuery {
-		if len(tpl) == 0 || tpl[0] != '/' {
+		if tpl == ""/"" && (len(tpl) == 0 || tpl[0] != '/') {
 			return fmt.Errorf(""mux: path must start with a slash, got %q"", tpl)
 		}
 		if r.regexp.path != nil {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=293ebe14936bf5aa585139c72ea2f28d4164f984,https://github.com/gorilla/mux/blob/293ebe14936bf5aa585139c72ea2f28d4164f984/route.go
910dd3aa3181e73b3605b92f5db7768a460721c1,5f54d48139648d21cf15297517f504bcef14d3b4,README.md,,"Mon, 03 Oct 2016 22:30:11 GMT",modified,0,1,1,"@@ -67,7 +67,6 @@ The names are used to create a map of route variables which can be retrieved cal
 ```go
 func ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) {
 	vars := mux.Vars(r)
-	w.Header().Set(""Content-Type"", ""application/json; charset=UTF-8"")
 	w.WriteHeader(http.StatusOK)
 	fmt.Fprintf(w, ""Category: %v\n"", vars[""category""])
 }",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=910dd3aa3181e73b3605b92f5db7768a460721c1,https://github.com/gorilla/mux/blob/910dd3aa3181e73b3605b92f5db7768a460721c1/README.md
239e05fe53b524b5e5cbccd56d6963a31094822f,3cea354998f0f4f9a2926bbf8ad68e77d3ef03c1,README.md,,"Fri, 30 Sep 2016 17:54:10 GMT",modified,6,2,8,"@@ -65,8 +65,12 @@ r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
 The names are used to create a map of route variables which can be retrieved calling `mux.Vars()`:
 
 ```go
-vars := mux.Vars(request)
-category := vars[""category""]
+func ArticlesCategoryHandler(w http.ResponseWriter, r *http.Request) {
+	vars := mux.Vars(r)
+	w.Header().Set(""Content-Type"", ""application/json; charset=UTF-8"")
+	w.WriteHeader(http.StatusOK)
+	fmt.Fprintf(w, ""Category: %v\n"", vars[""category""])
+}
 ```
 
 And this is all you need to know about the basic usage. More advanced options are explained below.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=239e05fe53b524b5e5cbccd56d6963a31094822f,https://github.com/gorilla/mux/blob/239e05fe53b524b5e5cbccd56d6963a31094822f/README.md
757bef944d0f21880861c2dd9c871ca543023cba,e9573dd8ad17b67889dd6b571824a07c54d49a98,doc.go,,"Tue, 20 Sep 2016 23:08:13 GMT",modified,4,0,4,"@@ -47,6 +47,10 @@ variable will be anything until the next slash. For example:
 	r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
 	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
 
+Groups can be used inside patterns, as long as they are non-capturing (?:re). For example:
+
+	r.HandleFunc(""/articles/{category}/{sort:(?:asc|desc|new)}"", ArticlesCategoryHandler)
+
 The names are used to create a map of route variables which can be retrieved
 calling mux.Vars():
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=757bef944d0f21880861c2dd9c871ca543023cba,https://github.com/gorilla/mux/blob/757bef944d0f21880861c2dd9c871ca543023cba/doc.go
14f5df0128b7c89faab437c00d0ea98fb56e03a0,e9573dd8ad17b67889dd6b571824a07c54d49a98,doc.go,,"Tue, 20 Sep 2016 14:06:56 GMT",modified,4,0,4,"@@ -47,6 +47,10 @@ variable will be anything until the next slash. For example:
 	r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
 	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
 
+Groups can be used inside patterns, as long as they are non-capturing (?:re). For example:
+
+	r.HandleFunc(""/articles/{category}/{sort:(?:asc|desc|new)}"", ArticlesCategoryHandler)
+
 The names are used to create a map of route variables which can be retrieved
 calling mux.Vars():
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=14f5df0128b7c89faab437c00d0ea98fb56e03a0,https://github.com/gorilla/mux/blob/14f5df0128b7c89faab437c00d0ea98fb56e03a0/doc.go
0a192a193177452756c362c20087ddafcf6829c4,d66ec38415fd30f0cadc75d2d550525c34e1ac57,mux.go,,"Fri, 02 Sep 2016 15:33:43 GMT",modified,22,2,24,"@@ -53,6 +53,8 @@ type Router struct {
 	// This has no effect when go1.7+ is used, since the context is stored
 	// on the request itself.
 	KeepContext bool
+	// see Router.UseEncodedPath(). This defines a flag for all routes.
+	useEncodedPath bool
 }
 
 // Match matches registered routes against the request.
@@ -77,7 +79,10 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 // mux.Vars(request).
 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	if !r.skipClean {
-		path := getPath(req)
+		path := req.URL.Path
+		if r.useEncodedPath {
+			path = getPath(req)
+		}
 		// Clean path to canonical form and redirect.
 		if p := cleanPath(path); p != path {
 
@@ -152,6 +157,21 @@ func (r *Router) SkipClean(value bool) *Router {
 	return r
 }
 
+// UseEncodedPath tells the router to match the encoded original path
+// to the routes.
+// For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to"".
+// This behavior has the drawback of needing to match routes against
+// r.RequestURI instead of r.URL.Path. Any modifications (such as http.StripPrefix)
+// to r.URL.Path will not affect routing when this flag is on and thus may
+// induce unintended behavior.
+//
+// If not called, the router will match the unencoded path to the routes.
+// For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/foo/bar/to""
+func (r *Router) UseEncodedPath() *Router {
+	r.useEncodedPath = true
+	return r
+}
+
 // ----------------------------------------------------------------------------
 // parentRoute
 // ----------------------------------------------------------------------------
@@ -189,7 +209,7 @@ func (r *Router) buildVars(m map[string]string) map[string]string {
 
 // NewRoute registers an empty route.
 func (r *Router) NewRoute() *Route {
-	route := &Route{parent: r, strictSlash: r.strictSlash, skipClean: r.skipClean}
+	route := &Route{parent: r, strictSlash: r.strictSlash, skipClean: r.skipClean, useEncodedPath: r.useEncodedPath}
 	r.routes = append(r.routes, route)
 	return route
 }",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=0a192a193177452756c362c20087ddafcf6829c4,https://github.com/gorilla/mux/blob/0a192a193177452756c362c20087ddafcf6829c4/mux.go
0a192a193177452756c362c20087ddafcf6829c4,39a099c1e51a2121dca77fd4fceb0cd7571b511a,mux_test.go,,"Fri, 02 Sep 2016 15:33:43 GMT",modified,44,10,54,"@@ -335,16 +335,6 @@ func TestPath(t *testing.T) {
 			pathTemplate: `/111/{v1:[0-9]{3}}/333`,
 			shouldMatch:  false,
 		},
-		{
-			title:        ""Path route, URL with encoded slash does match"",
-			route:        new(Route).Path(""/v1/{v1}/v2""),
-			request:      newRequest(""GET"", ""http://localhost/v1/1%2F2/v2""),
-			vars:         map[string]string{""v1"": ""1%2F2""},
-			host:         """",
-			path:         ""/v1/1%2F2/v2"",
-			pathTemplate: `/v1/{v1}/v2`,
-			shouldMatch:  true,
-		},
 		{
 			title:        ""Path route with multiple patterns, match"",
 			route:        new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
@@ -430,6 +420,7 @@ func TestPath(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
+		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -507,6 +498,7 @@ func TestPathPrefix(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
+		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -583,6 +575,7 @@ func TestHostPath(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
+		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -909,6 +902,7 @@ func TestQueries(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
+		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -1068,6 +1062,7 @@ func TestSubRouter(t *testing.T) {
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
+		testUseEscapedRoute(t, test)
 	}
 }
 
@@ -1161,6 +1156,40 @@ func TestStrictSlash(t *testing.T) {
 		},
 	}
 
+	for _, test := range tests {
+		testRoute(t, test)
+		testTemplate(t, test)
+		testUseEscapedRoute(t, test)
+	}
+}
+
+func TestUseEncodedPath(t *testing.T) {
+	r := NewRouter()
+	r.UseEncodedPath()
+
+	tests := []routeTest{
+		{
+			title:        ""Router with useEncodedPath, URL with encoded slash does match"",
+			route:        r.NewRoute().Path(""/v1/{v1}/v2""),
+			request:      newRequest(""GET"", ""http://localhost/v1/1%2F2/v2""),
+			vars:         map[string]string{""v1"": ""1%2F2""},
+			host:         """",
+			path:         ""/v1/1%2F2/v2"",
+			pathTemplate: `/v1/{v1}/v2`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Router with useEncodedPath, URL with encoded slash doesn't match"",
+			route:        r.NewRoute().Path(""/v1/1/2/v2""),
+			request:      newRequest(""GET"", ""http://localhost/v1/1%2F2/v2""),
+			vars:         map[string]string{""v1"": ""1%2F2""},
+			host:         """",
+			path:         ""/v1/1%2F2/v2"",
+			pathTemplate: `/v1/1/2/v2`,
+			shouldMatch:  false,
+		},
+	}
+
 	for _, test := range tests {
 		testRoute(t, test)
 		testTemplate(t, test)
@@ -1375,6 +1404,11 @@ func testRoute(t *testing.T, test routeTest) {
 	}
 }
 
+func testUseEscapedRoute(t *testing.T, test routeTest) {
+	test.route.useEncodedPath = true
+	testRoute(t, test)
+}
+
 func testTemplate(t *testing.T, test routeTest) {
 	route := test.route
 	pathTemplate := test.pathTemplate",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=0a192a193177452756c362c20087ddafcf6829c4,https://github.com/gorilla/mux/blob/0a192a193177452756c362c20087ddafcf6829c4/mux_test.go
0a192a193177452756c362c20087ddafcf6829c4,9bdc5e5d1281222cffa608e5c54bb30711dd82d9,old_test.go,,"Fri, 02 Sep 2016 15:33:43 GMT",modified,1,1,2,"@@ -687,7 +687,7 @@ func TestNewRegexp(t *testing.T) {
 	}
 
 	for pattern, paths := range tests {
-		p, _ = newRouteRegexp(pattern, false, false, false, false)
+		p, _ = newRouteRegexp(pattern, false, false, false, false, false)
 		for path, result := range paths {
 			matches = p.regexp.FindStringSubmatch(path)
 			if result == nil {",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=0a192a193177452756c362c20087ddafcf6829c4,https://github.com/gorilla/mux/blob/0a192a193177452756c362c20087ddafcf6829c4/old_test.go
0a192a193177452756c362c20087ddafcf6829c4,fd8fe39560b2297958e7cfc6e080b67e31bd3549,regexp.go,,"Fri, 02 Sep 2016 15:33:43 GMT",modified,21,11,32,"@@ -24,7 +24,7 @@ import (
 // Previously we accepted only Python-like identifiers for variable
 // names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that
 // name and pattern can't be empty, and names can't contain a colon.
-func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash bool) (*routeRegexp, error) {
+func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash, useEncodedPath bool) (*routeRegexp, error) {
 	// Check if it is well-formed.
 	idxs, errBraces := braceIndices(tpl)
 	if errBraces != nil {
@@ -111,14 +111,15 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	}
 	// Done!
 	return &routeRegexp{
-		template:    template,
-		matchHost:   matchHost,
-		matchQuery:  matchQuery,
-		strictSlash: strictSlash,
-		regexp:      reg,
-		reverse:     reverse.String(),
-		varsN:       varsN,
-		varsR:       varsR,
+		template:       template,
+		matchHost:      matchHost,
+		matchQuery:     matchQuery,
+		strictSlash:    strictSlash,
+		useEncodedPath: useEncodedPath,
+		regexp:         reg,
+		reverse:        reverse.String(),
+		varsN:          varsN,
+		varsR:          varsR,
 	}, nil
 }
 
@@ -133,6 +134,9 @@ type routeRegexp struct {
 	matchQuery bool
 	// The strictSlash value defined on the route, but disabled if PathPrefix was used.
 	strictSlash bool
+	// Determines whether to use encoded path from getPath function or unencoded
+	// req.URL.Path for path matching
+	useEncodedPath bool
 	// Expanded regexp.
 	regexp *regexp.Regexp
 	// Reverse template.
@@ -149,7 +153,10 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 		if r.matchQuery {
 			return r.matchQueryString(req)
 		}
-		path := getPath(req)
+		path := req.URL.Path
+		if r.useEncodedPath {
+			path = getPath(req)
+		}
 		return r.regexp.MatchString(path)
 	}
 
@@ -253,7 +260,10 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
-	path := getPath(req)
+	path := req.URL.Path
+	if r.useEncodedPath {
+		path = getPath(req)
+	}
 	// Store path variables.
 	if v.path != nil {
 		matches := v.path.regexp.FindStringSubmatchIndex(path)",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=0a192a193177452756c362c20087ddafcf6829c4,https://github.com/gorilla/mux/blob/0a192a193177452756c362c20087ddafcf6829c4/regexp.go
0a192a193177452756c362c20087ddafcf6829c4,293b6d49386f35132ab4d6c4270a5d218c296a5b,route.go,,"Fri, 02 Sep 2016 15:33:43 GMT",modified,3,1,4,"@@ -29,6 +29,8 @@ type Route struct {
 	// If true, when the path pattern is ""/path//to"", accessing ""/path//to""
 	// will not redirect
 	skipClean bool
+	// If true, ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to""
+	useEncodedPath bool
 	// If true, this route never matches: it is only used to build URLs.
 	buildOnly bool
 	// The name used to build URLs.
@@ -158,7 +160,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 			tpl = strings.TrimRight(r.regexp.path.template, ""/"") + tpl
 		}
 	}
-	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, matchQuery, r.strictSlash)
+	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, matchQuery, r.strictSlash, r.useEncodedPath)
 	if err != nil {
 		return err
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=0a192a193177452756c362c20087ddafcf6829c4,https://github.com/gorilla/mux/blob/0a192a193177452756c362c20087ddafcf6829c4/route.go
0b13a922203ebdbfd236c818efcd5ed46097d690,c540e4d0724997f87c4cfb7b2c1f770199fcc422,mux_test.go,,"Sat, 27 Aug 2016 16:50:34 GMT",modified,20,10,30,"@@ -127,12 +127,12 @@ func TestHost(t *testing.T) {
 		},
 		{
 			title:        ""Host route with pattern, additional capturing group, match"",
-			route:        new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
+			route:        new(Route).Host(""aaa.{v1:[a-z]{2}(?:b|c)}.ccc""),
 			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
 			vars:         map[string]string{""v1"": ""bbb""},
 			host:         ""aaa.bbb.ccc"",
 			path:         """",
-			hostTemplate: `aaa.{v1:[a-z]{2}(b|c)}.ccc`,
+			hostTemplate: `aaa.{v1:[a-z]{2}(?:b|c)}.ccc`,
 			shouldMatch:  true,
 		},
 		{
@@ -177,12 +177,12 @@ func TestHost(t *testing.T) {
 		},
 		{
 			title:        ""Host route with hyphenated name and pattern, additional capturing group, match"",
-			route:        new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
+			route:        new(Route).Host(""aaa.{v-1:[a-z]{2}(?:b|c)}.ccc""),
 			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
 			vars:         map[string]string{""v-1"": ""bbb""},
 			host:         ""aaa.bbb.ccc"",
 			path:         """",
-			hostTemplate: `aaa.{v-1:[a-z]{2}(b|c)}.ccc`,
+			hostTemplate: `aaa.{v-1:[a-z]{2}(?:b|c)}.ccc`,
 			shouldMatch:  true,
 		},
 		{
@@ -367,12 +367,12 @@ func TestPath(t *testing.T) {
 		},
 		{
 			title:        ""Path route with multiple patterns with pipe, match"",
-			route:        new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
+			route:        new(Route).Path(""/{category:a|(?:b/c)}/{product}/{id:[0-9]+}""),
 			request:      newRequest(""GET"", ""http://localhost/a/product_name/1""),
 			vars:         map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
 			host:         """",
 			path:         ""/a/product_name/1"",
-			pathTemplate: `/{category:a|(b/c)}/{product}/{id:[0-9]+}`,
+			pathTemplate: `/{category:a|(?:b/c)}/{product}/{id:[0-9]+}`,
 			shouldMatch:  true,
 		},
 		{
@@ -397,12 +397,12 @@ func TestPath(t *testing.T) {
 		},
 		{
 			title:        ""Path route with multiple hyphenated names and patterns with pipe, match"",
-			route:        new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
+			route:        new(Route).Path(""/{product-category:a|(?:b/c)}/{product-name}/{product-id:[0-9]+}""),
 			request:      newRequest(""GET"", ""http://localhost/a/product_name/1""),
 			vars:         map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
 			host:         """",
 			path:         ""/a/product_name/1"",
-			pathTemplate: `/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}`,
+			pathTemplate: `/{product-category:a|(?:b/c)}/{product-name}/{product-id:[0-9]+}`,
 			shouldMatch:  true,
 		},
 		{
@@ -415,6 +415,16 @@ func TestPath(t *testing.T) {
 			pathTemplate: `/{type:(?i:daily|mini|variety)}-{date:\d{4,4}-\d{2,2}-\d{2,2}}`,
 			shouldMatch:  true,
 		},
+		{
+			title:        ""Path route with empty match right after other match"",
+			route:        new(Route).Path(`/{v1:[0-9]*}{v2:[a-z]*}/{v3:[0-9]*}`),
+			request:      newRequest(""GET"", ""http://localhost/111/222""),
+			vars:         map[string]string{""v1"": ""111"", ""v2"": """", ""v3"": ""222""},
+			host:         """",
+			path:         ""/111/222"",
+			pathTemplate: `/{v1:[0-9]*}{v2:[a-z]*}/{v3:[0-9]*}`,
+			shouldMatch:  true,
+		},
 	}
 
 	for _, test := range tests {
@@ -779,7 +789,7 @@ func TestQueries(t *testing.T) {
 		},
 		{
 			title:       ""Queries route with regexp pattern with quantifier, additional capturing group"",
-			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}(a|b)}""),
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}(?:a|b)}""),
 			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
 			vars:        map[string]string{""v1"": ""1a""},
 			host:        """",
@@ -824,7 +834,7 @@ func TestQueries(t *testing.T) {
 		},
 		{
 			title:       ""Queries route with hyphenated name and pattern with quantifier, additional capturing group"",
-			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]{1}(a|b)}""),
+			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]{1}(?:a|b)}""),
 			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
 			vars:        map[string]string{""v-1"": ""1a""},
 			host:        """",",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=0b13a922203ebdbfd236c818efcd5ed46097d690,https://github.com/gorilla/mux/blob/0b13a922203ebdbfd236c818efcd5ed46097d690/mux_test.go
0b13a922203ebdbfd236c818efcd5ed46097d690,f645332f1ebce3716f284c5893398c9f1968977a,regexp.go,,"Sat, 27 Aug 2016 16:50:34 GMT",modified,2,9,11,"@@ -300,14 +300,7 @@ func getHost(r *http.Request) string {
 }
 
 func extractVars(input string, matches []int, names []string, output map[string]string) {
-	matchesCount := 0
-	prevEnd := -1
-	for i := 2; i < len(matches) && matchesCount < len(names); i += 2 {
-		if prevEnd < matches[i+1] {
-			value := input[matches[i]:matches[i+1]]
-			output[names[matchesCount]] = value
-			prevEnd = matches[i+1]
-			matchesCount++
-		}
+	for i, name := range names {
+		output[name] = input[matches[2*i+2]:matches[2*i+3]]
 	}
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=0b13a922203ebdbfd236c818efcd5ed46097d690,https://github.com/gorilla/mux/blob/0b13a922203ebdbfd236c818efcd5ed46097d690/regexp.go
34bf6dc9faa08144e925df4fa1838551b16d6c2a,3263a00a84da8831f79e6218faec65dcca8dbee5,mux.go,,"Wed, 24 Aug 2016 23:34:02 GMT",modified,2,6,8,"@@ -369,12 +369,8 @@ func getPath(req *http.Request) string {
 		// for < 1.5 server side workaround
 		// http://localhost/path/here?v=1 -> /path/here
 		path := req.RequestURI
-		if i := len(req.URL.Scheme); i > 0 {
-			path = path[i+len(`://`):]
-		}
-		if i := len(req.URL.Host); i > 0 {
-			path = path[i:]
-		}
+		path = strings.TrimPrefix(path, req.URL.Scheme+`://`)
+		path = strings.TrimPrefix(path, req.URL.Host)
 		if i := strings.LastIndex(path, ""?""); i > -1 {
 			path = path[:i]
 		}",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=34bf6dc9faa08144e925df4fa1838551b16d6c2a,https://github.com/gorilla/mux/blob/34bf6dc9faa08144e925df4fa1838551b16d6c2a/mux.go
34bf6dc9faa08144e925df4fa1838551b16d6c2a,424c4948c9f5de949430bd6900aac25e88406870,mux_test.go,,"Wed, 24 Aug 2016 23:34:02 GMT",modified,14,0,14,"@@ -292,6 +292,20 @@ func TestPath(t *testing.T) {
 			pathTemplate: `/`,
 			shouldMatch:  true,
 		},
+		{
+			title: ""Path route, match root with no host, App Engine format"",
+			route: new(Route).Path(""/""),
+			request: func() *http.Request {
+				r := newRequest(""GET"", ""http://localhost/"")
+				r.RequestURI = ""/""
+				return r
+			}(),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  true,
+		},
 		{
 			title:       ""Path route, wrong path in request in request URL"",
 			route:       new(Route).Path(""/111/222/333""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=34bf6dc9faa08144e925df4fa1838551b16d6c2a,https://github.com/gorilla/mux/blob/34bf6dc9faa08144e925df4fa1838551b16d6c2a/mux_test.go
674ef1c28022f33fa7200f59db45e604557f0380,514bfb0838d35b0dd9521a23c10b7a0b5746f893,mux.go,,"Wed, 24 Aug 2016 13:45:17 GMT",modified,29,1,30,"@@ -10,6 +10,7 @@ import (
 	""net/http""
 	""path""
 	""regexp""
+	""strings""
 )
 
 // NewRouter returns a new router instance.
@@ -76,8 +77,9 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 // mux.Vars(request).
 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	if !r.skipClean {
+		path := getPath(req)
 		// Clean path to canonical form and redirect.
-		if p := cleanPath(req.URL.Path); p != req.URL.Path {
+		if p := cleanPath(path); p != path {
 
 			// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
 			// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
@@ -358,6 +360,32 @@ func setCurrentRoute(r *http.Request, val interface{}) *http.Request {
 // Helpers
 // ----------------------------------------------------------------------------
 
+// getPath returns the escaped path if possible; doing what URL.EscapedPath()
+// which was added in go1.5 does
+func getPath(req *http.Request) string {
+	if req.RequestURI != """" {
+		// Extract the path from RequestURI (which is escaped unlike URL.Path)
+		// as detailed here as detailed in https://golang.org/pkg/net/url/#URL
+		// for < 1.5 server side workaround
+		// http://localhost/path/here?v=1 -> /path/here
+		path := req.RequestURI
+		if i := len(req.URL.Scheme); i > 0 {
+			path = path[i+len(`://`):]
+		}
+		if i := len(req.URL.Host); i > 0 {
+			path = path[i:]
+		}
+		if i := strings.LastIndex(path, ""?""); i > -1 {
+			path = path[:i]
+		}
+		if i := strings.LastIndex(path, ""#""); i > -1 {
+			path = path[:i]
+		}
+		return path
+	}
+	return req.URL.Path
+}
+
 // cleanPath returns the canonical path for p, eliminating . and .. elements.
 // Borrowed from the net/http package.
 func cleanPath(p string) string {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=674ef1c28022f33fa7200f59db45e604557f0380,https://github.com/gorilla/mux/blob/674ef1c28022f33fa7200f59db45e604557f0380/mux.go
674ef1c28022f33fa7200f59db45e604557f0380,16707644eb57a0fdaff2d469d3e21e077bb15846,mux_test.go,,"Wed, 24 Aug 2016 13:45:17 GMT",modified,54,1,55,"@@ -5,6 +5,8 @@
 package mux
 
 import (
+	""bufio""
+	""bytes""
 	""errors""
 	""fmt""
 	""net/http""
@@ -280,6 +282,16 @@ func TestPath(t *testing.T) {
 			pathTemplate: `/111`,
 			shouldMatch:  false,
 		},
+		{
+			title:        ""Path route, match root with no host"",
+			route:        new(Route).Path(""/""),
+			request:      newRequest(""GET"", ""/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/"",
+			pathTemplate: `/`,
+			shouldMatch:  true,
+		},
 		{
 			title:       ""Path route, wrong path in request in request URL"",
 			route:       new(Route).Path(""/111/222/333""),
@@ -309,6 +321,16 @@ func TestPath(t *testing.T) {
 			pathTemplate: `/111/{v1:[0-9]{3}}/333`,
 			shouldMatch:  false,
 		},
+		{
+			title:        ""Path route, URL with encoded slash does match"",
+			route:        new(Route).Path(""/v1/{v1}/v2""),
+			request:      newRequest(""GET"", ""http://localhost/v1/1%2F2/v2""),
+			vars:         map[string]string{""v1"": ""1%2F2""},
+			host:         """",
+			path:         ""/v1/1%2F2/v2"",
+			pathTemplate: `/v1/{v1}/v2`,
+			shouldMatch:  true,
+		},
 		{
 			title:        ""Path route with multiple patterns, match"",
 			route:        new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
@@ -1466,11 +1488,42 @@ func stringMapEqual(m1, m2 map[string]string) bool {
 	return true
 }
 
-// newRequest is a helper function to create a new request with a method and url
+// newRequest is a helper function to create a new request with a method and url.
+// The request returned is a 'server' request as opposed to a 'client' one through
+// simulated write onto the wire and read off of the wire.
+// The differences between requests are detailed in the net/http package.
 func newRequest(method, url string) *http.Request {
 	req, err := http.NewRequest(method, url, nil)
 	if err != nil {
 		panic(err)
 	}
+	// extract the escaped original host+path from url
+	// http://localhost/path/here?v=1#frag -> //localhost/path/here
+	opaque := """"
+	if i := len(req.URL.Scheme); i > 0 {
+		opaque = url[i+1:]
+	}
+
+	if i := strings.LastIndex(opaque, ""?""); i > -1 {
+		opaque = opaque[:i]
+	}
+	if i := strings.LastIndex(opaque, ""#""); i > -1 {
+		opaque = opaque[:i]
+	}
+
+	// Escaped host+path workaround as detailed in https://golang.org/pkg/net/url/#URL
+	// for < 1.5 client side workaround
+	req.URL.Opaque = opaque
+
+	// Simulate writing to wire
+	var buff bytes.Buffer
+	req.Write(&buff)
+	ioreader := bufio.NewReader(&buff)
+
+	// Parse request off of 'wire'
+	req, err = http.ReadRequest(ioreader)
+	if err != nil {
+		panic(err)
+	}
 	return req
 }",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=674ef1c28022f33fa7200f59db45e604557f0380,https://github.com/gorilla/mux/blob/674ef1c28022f33fa7200f59db45e604557f0380/mux_test.go
674ef1c28022f33fa7200f59db45e604557f0380,99d41a8fe221723c100ace718d570db17c06e933,regexp.go,,"Wed, 24 Aug 2016 13:45:17 GMT",modified,6,5,11,"@@ -149,8 +149,8 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 		if r.matchQuery {
 			return r.matchQueryString(req)
 		}
-
-		return r.regexp.MatchString(req.URL.Path)
+		path := getPath(req)
+		return r.regexp.MatchString(path)
 	}
 
 	return r.regexp.MatchString(getHost(req))
@@ -253,14 +253,15 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
+	path := getPath(req)
 	// Store path variables.
 	if v.path != nil {
-		matches := v.path.regexp.FindStringSubmatchIndex(req.URL.Path)
+		matches := v.path.regexp.FindStringSubmatchIndex(path)
 		if len(matches) > 0 {
-			extractVars(req.URL.Path, matches, v.path.varsN, m.Vars)
+			extractVars(path, matches, v.path.varsN, m.Vars)
 			// Check if we should redirect.
 			if v.path.strictSlash {
-				p1 := strings.HasSuffix(req.URL.Path, ""/"")
+				p1 := strings.HasSuffix(path, ""/"")
 				p2 := strings.HasSuffix(v.path.template, ""/"")
 				if p1 != p2 {
 					u, _ := url.Parse(req.URL.String())",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=674ef1c28022f33fa7200f59db45e604557f0380,https://github.com/gorilla/mux/blob/674ef1c28022f33fa7200f59db45e604557f0380/regexp.go
cf79e51a62d8219d52060dfc1b4e810414ba2d15,f93ce56d1ed7809332a089ee296840815e5edbcf,.travis.yml,,"Tue, 16 Aug 2016 18:46:30 GMT",modified,1,0,1,"@@ -8,6 +8,7 @@ matrix:
     - go: 1.4
     - go: 1.5
     - go: 1.6
+    - go: 1.7
     - go: tip
 
 install:",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=cf79e51a62d8219d52060dfc1b4e810414ba2d15,https://github.com/gorilla/mux/blob/cf79e51a62d8219d52060dfc1b4e810414ba2d15/.travis.yml
780415097119f6f61c55475fe59b66f3c3e9ea53,fa79a6bc3aeec1c5f9820c7035079b2a356e2190,README.md,,"Mon, 01 Aug 2016 17:00:46 GMT",modified,6,3,9,"@@ -1,19 +1,22 @@
-mux
+gorilla/mux
 ===
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
 
+![Gorilla Logo](http://www.gorillatoolkit.org/static/images/gorilla-icon-64.png)
+
 http://www.gorillatoolkit.org/pkg/mux
 
-Package `gorilla/mux` implements a request router and dispatcher.
+Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
+their respective handler.
 
 The name mux stands for ""HTTP request multiplexer"". Like the standard `http.ServeMux`, `mux.Router` matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:
 
+* It implements the `http.Handler` interface so it is compatible with the standard `http.ServeMux`.
 * Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers.
 * URL hosts and paths can have variables with an optional regular expression.
 * Registered URLs can be built, or ""reversed"", which helps maintaining references to resources.
 * Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching.
-* It implements the `http.Handler` interface so it is compatible with the standard `http.ServeMux`.
 
 ---
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=780415097119f6f61c55475fe59b66f3c3e9ea53,https://github.com/gorilla/mux/blob/780415097119f6f61c55475fe59b66f3c3e9ea53/README.md
3b15f12d155ae3bd4cc34b6919054b0b71bceed9,d9883e9e0de9157d68a9f08cfba96161fe6cbbdd,README.md,,"Mon, 01 Aug 2016 15:51:14 GMT",modified,54,0,54,"@@ -15,6 +15,27 @@ The name mux stands for ""HTTP request multiplexer"". Like the standard `http.Serv
 * Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching.
 * It implements the `http.Handler` interface so it is compatible with the standard `http.ServeMux`.
 
+---
+
+* [Install](#install)
+* [Examples](#examples)
+* [Matching Routes](#matching-routes)
+* [Static Files](#static-files)
+* [Registered URLs](#registered-urls)
+* [Full Example](#full-example)
+
+---
+
+## Install
+
+With a [correctly configured](https://golang.org/doc/install#testing) Go toolchain:
+
+```sh
+go get -u github.com/gorilla/mux
+```
+
+## Examples
+
 Let's start registering a couple of URL paths and handlers:
 
 ```go
@@ -47,6 +68,8 @@ category := vars[""category""]
 
 And this is all you need to know about the basic usage. More advanced options are explained below.
 
+### Matching Routes
+
 Routes can also be restricted to a domain or subdomain. Just define a host pattern to be matched. They can also have variables:
 
 ```go
@@ -138,6 +161,37 @@ s.HandleFunc(""/{key}/"", ProductHandler)
 s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 ```
 
+### Static Files
+
+Note that the path provided to `PathPrefix()` represents a ""wildcard"": calling
+`PathPrefix(""/static/"").Handler(...)` means that the handler will be passed any
+request that matches ""/static/*"". This makes it easy to serve static files with mux:
+
+```go
+func main() {
+	var dir string
+
+	flag.StringVar(&dir, ""dir"", ""."", ""the directory to serve files from. Defaults to the current dir"")
+	flag.Parse()
+	r := mux.NewRouter()
+
+	// This will serve files under http://localhost:8000/static/<filename>
+	r.PathPrefix(""/static/"").Handler(http.StripPrefix(""/static/"", http.FileServer(http.Dir(dir))))
+
+	srv := &http.Server{
+		Handler:      r,
+		Addr:         ""127.0.0.1:8000"",
+		// Good practice: enforce timeouts for servers you create!
+		WriteTimeout: 15 * time.Second,
+		ReadTimeout:  15 * time.Second,
+	}
+
+	log.Fatal(srv.ListenAndServe())
+}
+```
+
+### Registered URLs
+
 Now let's see how to build registered URLs.
 
 Routes can be named. All routes that define a name can have their URLs built, or ""reversed"". We define a name calling `Name()` on a route. For example:",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=3b15f12d155ae3bd4cc34b6919054b0b71bceed9,https://github.com/gorilla/mux/blob/3b15f12d155ae3bd4cc34b6919054b0b71bceed9/README.md
3b15f12d155ae3bd4cc34b6919054b0b71bceed9,291ef5e1cf2586d236074ed7cc2e2800a91b3184,doc.go,,"Mon, 01 Aug 2016 15:51:14 GMT",modified,25,0,25,"@@ -136,6 +136,31 @@ the inner routes use it as base for their paths:
 	// ""/products/{key}/details""
 	s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 
+Note that the path provided to PathPrefix() represents a ""wildcard"": calling
+PathPrefix(""/static/"").Handler(...) means that the handler will be passed any
+request that matches ""/static/*"". This makes it easy to serve static files with mux:
+
+	func main() {
+		var dir string
+
+		flag.StringVar(&dir, ""dir"", ""."", ""the directory to serve files from. Defaults to the current dir"")
+		flag.Parse()
+		r := mux.NewRouter()
+
+		// This will serve files under http://localhost:8000/static/<filename>
+		r.PathPrefix(""/static/"").Handler(http.StripPrefix(""/static/"", http.FileServer(http.Dir(dir))))
+
+		srv := &http.Server{
+			Handler:      r,
+			Addr:         ""127.0.0.1:8000"",
+			// Good practice: enforce timeouts for servers you create!
+			WriteTimeout: 15 * time.Second,
+			ReadTimeout:  15 * time.Second,
+		}
+
+		log.Fatal(srv.ListenAndServe())
+	}
+
 Now let's see how to build registered URLs.
 
 Routes can be named. All routes that define a name can have their URLs built,",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=3b15f12d155ae3bd4cc34b6919054b0b71bceed9,https://github.com/gorilla/mux/blob/3b15f12d155ae3bd4cc34b6919054b0b71bceed9/doc.go
327d4b684c13f926b0984fff1087fb8305368948,e8e2005258078a4e44ac45b32d4840f6d0e886d7,mux_test.go,,"Sat, 30 Jul 2016 23:45:59 GMT",modified,400,400,800,"@@ -31,8 +31,8 @@ type routeTest struct {
 	vars           map[string]string // the expected vars of the match
 	host           string            // the expected host of the match
 	path           string            // the expected path of the match
-	path_template  string            // the expected path template to match
-	host_template  string            // the expected host template to match
+	pathTemplate   string            // the expected path template to match
+	hostTemplate   string            // the expected host template to match
 	shouldMatch    bool              // whether the request is expected to match the route at all
 	shouldRedirect bool              // whether the request should result in a redirect
 }
@@ -114,124 +114,124 @@ func TestHost(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:         ""Host route with pattern, match"",
-			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""bbb""},
-			host:          ""aaa.bbb.ccc"",
-			path:          """",
-			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Host route with pattern, additional capturing group, match"",
-			route:         new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""bbb""},
-			host:          ""aaa.bbb.ccc"",
-			path:          """",
-			host_template: `aaa.{v1:[a-z]{2}(b|c)}.ccc`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Host route with pattern, wrong host in request URL"",
-			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""bbb""},
-			host:          ""aaa.bbb.ccc"",
-			path:          """",
-			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
-			shouldMatch:   false,
-		},
-		{
-			title:         ""Host route with multiple patterns, match"",
-			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:          ""aaa.bbb.ccc"",
-			path:          """",
-			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Host route with multiple patterns, wrong host in request URL"",
-			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:          ""aaa.bbb.ccc"",
-			path:          """",
-			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
-			shouldMatch:   false,
-		},
-		{
-			title:         ""Host route with hyphenated name and pattern, match"",
-			route:         new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{""v-1"": ""bbb""},
-			host:          ""aaa.bbb.ccc"",
-			path:          """",
-			host_template: `aaa.{v-1:[a-z]{3}}.ccc`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Host route with hyphenated name and pattern, additional capturing group, match"",
-			route:         new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{""v-1"": ""bbb""},
-			host:          ""aaa.bbb.ccc"",
-			path:          """",
-			host_template: `aaa.{v-1:[a-z]{2}(b|c)}.ccc`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Host route with multiple hyphenated names and patterns, match"",
-			route:         new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
-			host:          ""aaa.bbb.ccc"",
-			path:          """",
-			host_template: `{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with single pattern with pipe, match"",
-			route:         new(Route).Path(""/{category:a|b/c}""),
-			request:       newRequest(""GET"", ""http://localhost/a""),
-			vars:          map[string]string{""category"": ""a""},
-			host:          """",
-			path:          ""/a"",
-			path_template: `/{category:a|b/c}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with single pattern with pipe, match"",
-			route:         new(Route).Path(""/{category:a|b/c}""),
-			request:       newRequest(""GET"", ""http://localhost/b/c""),
-			vars:          map[string]string{""category"": ""b/c""},
-			host:          """",
-			path:          ""/b/c"",
-			path_template: `/{category:a|b/c}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with multiple patterns with pipe, match"",
-			route:         new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
-			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:          map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
-			host:          """",
-			path:          ""/a/product_name/1"",
-			path_template: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with multiple patterns with pipe, match"",
-			route:         new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
-			request:       newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
-			vars:          map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
-			host:          """",
-			path:          ""/b/c/product_name/1"",
-			path_template: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
-			shouldMatch:   true,
+			title:        ""Host route with pattern, match"",
+			route:        new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""bbb""},
+			host:         ""aaa.bbb.ccc"",
+			path:         """",
+			hostTemplate: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Host route with pattern, additional capturing group, match"",
+			route:        new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""bbb""},
+			host:         ""aaa.bbb.ccc"",
+			path:         """",
+			hostTemplate: `aaa.{v1:[a-z]{2}(b|c)}.ccc`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Host route with pattern, wrong host in request URL"",
+			route:        new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""bbb""},
+			host:         ""aaa.bbb.ccc"",
+			path:         """",
+			hostTemplate: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Host route with multiple patterns, match"",
+			route:        new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:         ""aaa.bbb.ccc"",
+			path:         """",
+			hostTemplate: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Host route with multiple patterns, wrong host in request URL"",
+			route:        new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:         ""aaa.bbb.ccc"",
+			path:         """",
+			hostTemplate: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Host route with hyphenated name and pattern, match"",
+			route:        new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v-1"": ""bbb""},
+			host:         ""aaa.bbb.ccc"",
+			path:         """",
+			hostTemplate: `aaa.{v-1:[a-z]{3}}.ccc`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Host route with hyphenated name and pattern, additional capturing group, match"",
+			route:        new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v-1"": ""bbb""},
+			host:         ""aaa.bbb.ccc"",
+			path:         """",
+			hostTemplate: `aaa.{v-1:[a-z]{2}(b|c)}.ccc`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Host route with multiple hyphenated names and patterns, match"",
+			route:        new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
+			host:         ""aaa.bbb.ccc"",
+			path:         """",
+			hostTemplate: `{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with single pattern with pipe, match"",
+			route:        new(Route).Path(""/{category:a|b/c}""),
+			request:      newRequest(""GET"", ""http://localhost/a""),
+			vars:         map[string]string{""category"": ""a""},
+			host:         """",
+			path:         ""/a"",
+			pathTemplate: `/{category:a|b/c}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with single pattern with pipe, match"",
+			route:        new(Route).Path(""/{category:a|b/c}""),
+			request:      newRequest(""GET"", ""http://localhost/b/c""),
+			vars:         map[string]string{""category"": ""b/c""},
+			host:         """",
+			path:         ""/b/c"",
+			pathTemplate: `/{category:a|b/c}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with multiple patterns with pipe, match"",
+			route:        new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:      newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:         map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:         """",
+			path:         ""/a/product_name/1"",
+			pathTemplate: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with multiple patterns with pipe, match"",
+			route:        new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:      newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
+			vars:         map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
+			host:         """",
+			path:         ""/b/c/product_name/1"",
+			pathTemplate: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
+			shouldMatch:  true,
 		},
 	}
 	for _, test := range tests {
@@ -261,24 +261,24 @@ func TestPath(t *testing.T) {
 			shouldMatch: true,
 		},
 		{
-			title:         ""Path route, do not match with trailing slash in path"",
-			route:         new(Route).Path(""/111/""),
-			request:       newRequest(""GET"", ""http://localhost/111""),
-			vars:          map[string]string{},
-			host:          """",
-			path:          ""/111"",
-			path_template: `/111/`,
-			shouldMatch:   false,
+			title:        ""Path route, do not match with trailing slash in path"",
+			route:        new(Route).Path(""/111/""),
+			request:      newRequest(""GET"", ""http://localhost/111""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/111"",
+			pathTemplate: `/111/`,
+			shouldMatch:  false,
 		},
 		{
-			title:         ""Path route, do not match with trailing slash in request"",
-			route:         new(Route).Path(""/111""),
-			request:       newRequest(""GET"", ""http://localhost/111/""),
-			vars:          map[string]string{},
-			host:          """",
-			path:          ""/111/"",
-			path_template: `/111`,
-			shouldMatch:   false,
+			title:        ""Path route, do not match with trailing slash in request"",
+			route:        new(Route).Path(""/111""),
+			request:      newRequest(""GET"", ""http://localhost/111/""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         ""/111/"",
+			pathTemplate: `/111`,
+			shouldMatch:  false,
 		},
 		{
 			title:       ""Path route, wrong path in request in request URL"",
@@ -290,94 +290,94 @@ func TestPath(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:         ""Path route with pattern, match"",
-			route:         new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:          map[string]string{""v1"": ""222""},
-			host:          """",
-			path:          ""/111/222/333"",
-			path_template: `/111/{v1:[0-9]{3}}/333`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with pattern, URL in request does not match"",
-			route:         new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:          map[string]string{""v1"": ""222""},
-			host:          """",
-			path:          ""/111/222/333"",
-			path_template: `/111/{v1:[0-9]{3}}/333`,
-			shouldMatch:   false,
-		},
-		{
-			title:         ""Path route with multiple patterns, match"",
-			route:         new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:          """",
-			path:          ""/111/222/333"",
-			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with multiple patterns, URL in request does not match"",
-			route:         new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:          """",
-			path:          ""/111/222/333"",
-			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
-			shouldMatch:   false,
-		},
-		{
-			title:         ""Path route with multiple patterns with pipe, match"",
-			route:         new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
-			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:          map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
-			host:          """",
-			path:          ""/a/product_name/1"",
-			path_template: `/{category:a|(b/c)}/{product}/{id:[0-9]+}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with hyphenated name and pattern, match"",
-			route:         new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
-			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:          map[string]string{""v-1"": ""222""},
-			host:          """",
-			path:          ""/111/222/333"",
-			path_template: `/111/{v-1:[0-9]{3}}/333`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with multiple hyphenated names and patterns, match"",
-			route:         new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:          map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
-			host:          """",
-			path:          ""/111/222/333"",
-			path_template: `/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with multiple hyphenated names and patterns with pipe, match"",
-			route:         new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
-			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:          map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
-			host:          """",
-			path:          ""/a/product_name/1"",
-			path_template: `/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Path route with multiple hyphenated names and patterns with pipe and case insensitive, match"",
-			route:         new(Route).Path(""/{type:(?i:daily|mini|variety)}-{date:\\d{4,4}-\\d{2,2}-\\d{2,2}}""),
-			request:       newRequest(""GET"", ""http://localhost/daily-2016-01-01""),
-			vars:          map[string]string{""type"": ""daily"", ""date"": ""2016-01-01""},
-			host:          """",
-			path:          ""/daily-2016-01-01"",
-			path_template: `/{type:(?i:daily|mini|variety)}-{date:\d{4,4}-\d{2,2}-\d{2,2}}`,
-			shouldMatch:   true,
+			title:        ""Path route with pattern, match"",
+			route:        new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:      newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:         map[string]string{""v1"": ""222""},
+			host:         """",
+			path:         ""/111/222/333"",
+			pathTemplate: `/111/{v1:[0-9]{3}}/333`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with pattern, URL in request does not match"",
+			route:        new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:      newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:         map[string]string{""v1"": ""222""},
+			host:         """",
+			path:         ""/111/222/333"",
+			pathTemplate: `/111/{v1:[0-9]{3}}/333`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Path route with multiple patterns, match"",
+			route:        new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:         map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:         """",
+			path:         ""/111/222/333"",
+			pathTemplate: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with multiple patterns, URL in request does not match"",
+			route:        new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:         map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:         """",
+			path:         ""/111/222/333"",
+			pathTemplate: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Path route with multiple patterns with pipe, match"",
+			route:        new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
+			request:      newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:         map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:         """",
+			path:         ""/a/product_name/1"",
+			pathTemplate: `/{category:a|(b/c)}/{product}/{id:[0-9]+}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with hyphenated name and pattern, match"",
+			route:        new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
+			request:      newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:         map[string]string{""v-1"": ""222""},
+			host:         """",
+			path:         ""/111/222/333"",
+			pathTemplate: `/111/{v-1:[0-9]{3}}/333`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with multiple hyphenated names and patterns, match"",
+			route:        new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:         map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
+			host:         """",
+			path:         ""/111/222/333"",
+			pathTemplate: `/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with multiple hyphenated names and patterns with pipe, match"",
+			route:        new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
+			request:      newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:         map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
+			host:         """",
+			path:         ""/a/product_name/1"",
+			pathTemplate: `/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Path route with multiple hyphenated names and patterns with pipe and case insensitive, match"",
+			route:        new(Route).Path(""/{type:(?i:daily|mini|variety)}-{date:\\d{4,4}-\\d{2,2}-\\d{2,2}}""),
+			request:      newRequest(""GET"", ""http://localhost/daily-2016-01-01""),
+			vars:         map[string]string{""type"": ""daily"", ""date"": ""2016-01-01""},
+			host:         """",
+			path:         ""/daily-2016-01-01"",
+			pathTemplate: `/{type:(?i:daily|mini|variety)}-{date:\d{4,4}-\d{2,2}-\d{2,2}}`,
+			shouldMatch:  true,
 		},
 	}
 
@@ -417,44 +417,44 @@ func TestPathPrefix(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:         ""PathPrefix route with pattern, match"",
-			route:         new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:          map[string]string{""v1"": ""222""},
-			host:          """",
-			path:          ""/111/222"",
-			path_template: `/111/{v1:[0-9]{3}}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""PathPrefix route with pattern, URL prefix in request does not match"",
-			route:         new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:          map[string]string{""v1"": ""222""},
-			host:          """",
-			path:          ""/111/222"",
-			path_template: `/111/{v1:[0-9]{3}}`,
-			shouldMatch:   false,
-		},
-		{
-			title:         ""PathPrefix route with multiple patterns, match"",
-			route:         new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:          """",
-			path:          ""/111/222"",
-			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
-			route:         new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:          """",
-			path:          ""/111/222"",
-			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
-			shouldMatch:   false,
+			title:        ""PathPrefix route with pattern, match"",
+			route:        new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:         map[string]string{""v1"": ""222""},
+			host:         """",
+			path:         ""/111/222"",
+			pathTemplate: `/111/{v1:[0-9]{3}}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""PathPrefix route with pattern, URL prefix in request does not match"",
+			route:        new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:         map[string]string{""v1"": ""222""},
+			host:         """",
+			path:         ""/111/222"",
+			pathTemplate: `/111/{v1:[0-9]{3}}`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""PathPrefix route with multiple patterns, match"",
+			route:        new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:         map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:         """",
+			path:         ""/111/222"",
+			pathTemplate: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
+			route:        new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:         map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:         """",
+			path:         ""/111/222"",
+			pathTemplate: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
+			shouldMatch:  false,
 		},
 	}
 
@@ -467,70 +467,70 @@ func TestPathPrefix(t *testing.T) {
 func TestHostPath(t *testing.T) {
 	tests := []routeTest{
 		{
-			title:         ""Host and Path route, match"",
-			route:         new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{},
-			host:          """",
-			path:          """",
-			path_template: `/111/222/333`,
-			host_template: `aaa.bbb.ccc`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Host and Path route, wrong host in request URL"",
-			route:         new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:          map[string]string{},
-			host:          """",
-			path:          """",
-			path_template: `/111/222/333`,
-			host_template: `aaa.bbb.ccc`,
-			shouldMatch:   false,
-		},
-		{
-			title:         ""Host and Path route with pattern, match"",
-			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:          ""aaa.bbb.ccc"",
-			path:          ""/111/222/333"",
-			path_template: `/111/{v2:[0-9]{3}}/333`,
-			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Host and Path route with pattern, URL in request does not match"",
-			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:          ""aaa.bbb.ccc"",
-			path:          ""/111/222/333"",
-			path_template: `/111/{v2:[0-9]{3}}/333`,
-			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
-			shouldMatch:   false,
-		},
-		{
-			title:         ""Host and Path route with multiple patterns, match"",
-			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:          ""aaa.bbb.ccc"",
-			path:          ""/111/222/333"",
-			path_template: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
-			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
-			shouldMatch:   true,
-		},
-		{
-			title:         ""Host and Path route with multiple patterns, URL in request does not match"",
-			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:          ""aaa.bbb.ccc"",
-			path:          ""/111/222/333"",
-			path_template: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
-			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
-			shouldMatch:   false,
+			title:        ""Host and Path route, match"",
+			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         """",
+			pathTemplate: `/111/222/333`,
+			hostTemplate: `aaa.bbb.ccc`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Host and Path route, wrong host in request URL"",
+			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         """",
+			pathTemplate: `/111/222/333`,
+			hostTemplate: `aaa.bbb.ccc`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Host and Path route with pattern, match"",
+			route:        new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:         ""aaa.bbb.ccc"",
+			path:         ""/111/222/333"",
+			pathTemplate: `/111/{v2:[0-9]{3}}/333`,
+			hostTemplate: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Host and Path route with pattern, URL in request does not match"",
+			route:        new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:         ""aaa.bbb.ccc"",
+			path:         ""/111/222/333"",
+			pathTemplate: `/111/{v2:[0-9]{3}}/333`,
+			hostTemplate: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:  false,
+		},
+		{
+			title:        ""Host and Path route with multiple patterns, match"",
+			route:        new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:         ""aaa.bbb.ccc"",
+			path:         ""/111/222/333"",
+			pathTemplate: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
+			hostTemplate: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
+			shouldMatch:  true,
+		},
+		{
+			title:        ""Host and Path route with multiple patterns, URL in request does not match"",
+			route:        new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:         map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:         ""aaa.bbb.ccc"",
+			path:         ""/111/222/333"",
+			pathTemplate: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
+			hostTemplate: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
+			shouldMatch:  false,
 		},
 	}
 
@@ -648,26 +648,26 @@ func TestQueries(t *testing.T) {
 			shouldMatch: true,
 		},
 		{
-			title:         ""Queries route, match with a query string"",
-			route:         new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:       newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
-			vars:          map[string]string{},
-			host:          """",
-			path:          """",
-			path_template: `/api`,
-			host_template: `www.example.com`,
-			shouldMatch:   true,
+			title:        ""Queries route, match with a query string"",
+			route:        new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:      newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         """",
+			pathTemplate: `/api`,
+			hostTemplate: `www.example.com`,
+			shouldMatch:  true,
 		},
 		{
-			title:         ""Queries route, match with a query string out of order"",
-			route:         new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:       newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
-			vars:          map[string]string{},
-			host:          """",
-			path:          """",
-			path_template: `/api`,
-			host_template: `www.example.com`,
-			shouldMatch:   true,
+			title:        ""Queries route, match with a query string out of order"",
+			route:        new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:      newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
+			vars:         map[string]string{},
+			host:         """",
+			path:         """",
+			pathTemplate: `/api`,
+			hostTemplate: `www.example.com`,
+			shouldMatch:  true,
 		},
 		{
 			title:       ""Queries route, bad query"",
@@ -947,10 +947,10 @@ func TestBuildVarsFunc(t *testing.T) {
 				vars[""v2""] = ""a""
 				return vars
 			}),
-			request:       newRequest(""GET"", ""http://localhost/111/2""),
-			path:          ""/111/3a"",
-			path_template: `/111/{v1:\d}{v2:.*}`,
-			shouldMatch:   true,
+			request:      newRequest(""GET"", ""http://localhost/111/2""),
+			path:         ""/111/3a"",
+			pathTemplate: `/111/{v1:\d}{v2:.*}`,
+			shouldMatch:  true,
 		},
 		{
 			title: ""BuildVarsFunc set on route and parent route"",
@@ -961,10 +961,10 @@ func TestBuildVarsFunc(t *testing.T) {
 				vars[""v2""] = ""b""
 				return vars
 			}),
-			request:       newRequest(""GET"", ""http://localhost/1/a""),
-			path:          ""/2/b"",
-			path_template: `/{v1:\d}/{v2:\w}`,
-			shouldMatch:   true,
+			request:      newRequest(""GET"", ""http://localhost/1/a""),
+			path:         ""/2/b"",
+			pathTemplate: `/{v1:\d}/{v2:\w}`,
+			shouldMatch:  true,
 		},
 	}
 
@@ -980,42 +980,42 @@ func TestSubRouter(t *testing.T) {
 
 	tests := []routeTest{
 		{
-			route:         subrouter1.Path(""/{v2:[a-z]+}""),
-			request:       newRequest(""GET"", ""http://aaa.google.com/bbb""),
-			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
-			host:          ""aaa.google.com"",
-			path:          ""/bbb"",
-			path_template: `/{v2:[a-z]+}`,
-			host_template: `{v1:[a-z]+}.google.com`,
-			shouldMatch:   true,
-		},
-		{
-			route:         subrouter1.Path(""/{v2:[a-z]+}""),
-			request:       newRequest(""GET"", ""http://111.google.com/111""),
-			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
-			host:          ""aaa.google.com"",
-			path:          ""/bbb"",
-			path_template: `/{v2:[a-z]+}`,
-			host_template: `{v1:[a-z]+}.google.com`,
-			shouldMatch:   false,
-		},
-		{
-			route:         subrouter2.Path(""/baz/{v2}""),
-			request:       newRequest(""GET"", ""http://localhost/foo/bar/baz/ding""),
-			vars:          map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
-			host:          """",
-			path:          ""/foo/bar/baz/ding"",
-			path_template: `/foo/{v1}/baz/{v2}`,
-			shouldMatch:   true,
-		},
-		{
-			route:         subrouter2.Path(""/baz/{v2}""),
-			request:       newRequest(""GET"", ""http://localhost/foo/bar""),
-			vars:          map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
-			host:          """",
-			path:          ""/foo/bar/baz/ding"",
-			path_template: `/foo/{v1}/baz/{v2}`,
-			shouldMatch:   false,
+			route:        subrouter1.Path(""/{v2:[a-z]+}""),
+			request:      newRequest(""GET"", ""http://aaa.google.com/bbb""),
+			vars:         map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:         ""aaa.google.com"",
+			path:         ""/bbb"",
+			pathTemplate: `/{v2:[a-z]+}`,
+			hostTemplate: `{v1:[a-z]+}.google.com`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter1.Path(""/{v2:[a-z]+}""),
+			request:      newRequest(""GET"", ""http://111.google.com/111""),
+			vars:         map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:         ""aaa.google.com"",
+			path:         ""/bbb"",
+			pathTemplate: `/{v2:[a-z]+}`,
+			hostTemplate: `{v1:[a-z]+}.google.com`,
+			shouldMatch:  false,
+		},
+		{
+			route:        subrouter2.Path(""/baz/{v2}""),
+			request:      newRequest(""GET"", ""http://localhost/foo/bar/baz/ding""),
+			vars:         map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:         """",
+			path:         ""/foo/bar/baz/ding"",
+			pathTemplate: `/foo/{v1}/baz/{v2}`,
+			shouldMatch:  true,
+		},
+		{
+			route:        subrouter2.Path(""/baz/{v2}""),
+			request:      newRequest(""GET"", ""http://localhost/foo/bar""),
+			vars:         map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:         """",
+			path:         ""/foo/bar/baz/ding"",
+			pathTemplate: `/foo/{v1}/baz/{v2}`,
+			shouldMatch:  false,
 		},
 	}
 
@@ -1331,23 +1331,23 @@ func testRoute(t *testing.T, test routeTest) {
 
 func testTemplate(t *testing.T, test routeTest) {
 	route := test.route
-	path_template := test.path_template
-	if len(path_template) == 0 {
-		path_template = test.path
+	pathTemplate := test.pathTemplate
+	if len(pathTemplate) == 0 {
+		pathTemplate = test.path
 	}
-	host_template := test.host_template
-	if len(host_template) == 0 {
-		host_template = test.host
+	hostTemplate := test.hostTemplate
+	if len(hostTemplate) == 0 {
+		hostTemplate = test.host
 	}
 
-	path_tmpl, path_err := route.GetPathTemplate()
-	if path_err == nil && path_tmpl != path_template {
-		t.Errorf(""(%v) GetPathTemplate not equal: expected %v, got %v"", test.title, path_template, path_tmpl)
+	routePathTemplate, pathErr := route.GetPathTemplate()
+	if pathErr == nil && routePathTemplate != pathTemplate {
+		t.Errorf(""(%v) GetPathTemplate not equal: expected %v, got %v"", test.title, pathTemplate, routePathTemplate)
 	}
 
-	host_tmpl, host_err := route.GetHostTemplate()
-	if host_err == nil && host_tmpl != host_template {
-		t.Errorf(""(%v) GetHostTemplate not equal: expected %v, got %v"", test.title, host_template, host_tmpl)
+	routeHostTemplate, hostErr := route.GetHostTemplate()
+	if hostErr == nil && routeHostTemplate != hostTemplate {
+		t.Errorf(""(%v) GetHostTemplate not equal: expected %v, got %v"", test.title, hostTemplate, routeHostTemplate)
 	}
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=327d4b684c13f926b0984fff1087fb8305368948,https://github.com/gorilla/mux/blob/327d4b684c13f926b0984fff1087fb8305368948/mux_test.go
a49d62f618e6dc4a7a7d1f0ad69744a158c21f23,5e0dd69ad163b95818685a73a79f693b72e2d2fd,mux.go,,"Wed, 27 Jul 2016 01:54:17 GMT",modified,3,0,3,"@@ -285,6 +285,9 @@ func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
 		if err == SkipRouter {
 			continue
 		}
+		if err != nil {
+			return err
+		}
 		for _, sr := range t.matchers {
 			if h, ok := sr.(*Router); ok {
 				err := h.walk(walkFn, ancestors)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=a49d62f618e6dc4a7a7d1f0ad69744a158c21f23,https://github.com/gorilla/mux/blob/a49d62f618e6dc4a7a7d1f0ad69744a158c21f23/mux.go
a49d62f618e6dc4a7a7d1f0ad69744a158c21f23,dd684cf2dcb3d28e49f662fb91993f99d1d4f7db,mux_test.go,,"Wed, 27 Jul 2016 01:54:17 GMT",modified,37,0,37,"@@ -5,6 +5,7 @@
 package mux
 
 import (
+	""errors""
 	""fmt""
 	""net/http""
 	""strings""
@@ -1195,6 +1196,42 @@ func TestWalkNested(t *testing.T) {
 	}
 }
 
+func TestWalkErrorRoute(t *testing.T) {
+	router := NewRouter()
+	router.Path(""/g"")
+	expectedError := errors.New(""error"")
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		return expectedError
+	})
+	if err != expectedError {
+		t.Errorf(""Expected %v routes, found %v"", expectedError, err)
+	}
+}
+
+func TestWalkErrorMatcher(t *testing.T) {
+	router := NewRouter()
+	expectedError := router.Path(""/g"").Subrouter().Path("""").GetError()
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		return route.GetError()
+	})
+	if err != expectedError {
+		t.Errorf(""Expected %v routes, found %v"", expectedError, err)
+	}
+}
+
+func TestWalkErrorHandler(t *testing.T) {
+	handler := NewRouter()
+	expectedError := handler.Path(""/path"").Subrouter().Path("""").GetError()
+	router := NewRouter()
+	router.Path(""/g"").Handler(handler)
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		return route.GetError()
+	})
+	if err != expectedError {
+		t.Errorf(""Expected %v routes, found %v"", expectedError, err)
+	}
+}
+
 func TestSubrouterErrorHandling(t *testing.T) {
 	superRouterCalled := false
 	subRouterCalled := false",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a49d62f618e6dc4a7a7d1f0ad69744a158c21f23,https://github.com/gorilla/mux/blob/a49d62f618e6dc4a7a7d1f0ad69744a158c21f23/mux_test.go
cf57124f1d4afc95248c663c559ef789ee099087,5e0dd69ad163b95818685a73a79f693b72e2d2fd,mux.go,,"Mon, 25 Jul 2016 16:05:24 GMT",modified,3,0,3,"@@ -285,6 +285,9 @@ func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
 		if err == SkipRouter {
 			continue
 		}
+		if err != nil {
+			return err
+		}
 		for _, sr := range t.matchers {
 			if h, ok := sr.(*Router); ok {
 				err := h.walk(walkFn, ancestors)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=cf57124f1d4afc95248c663c559ef789ee099087,https://github.com/gorilla/mux/blob/cf57124f1d4afc95248c663c559ef789ee099087/mux.go
cf57124f1d4afc95248c663c559ef789ee099087,dd684cf2dcb3d28e49f662fb91993f99d1d4f7db,mux_test.go,,"Mon, 25 Jul 2016 16:05:24 GMT",modified,37,0,37,"@@ -5,6 +5,7 @@
 package mux
 
 import (
+	""errors""
 	""fmt""
 	""net/http""
 	""strings""
@@ -1195,6 +1196,42 @@ func TestWalkNested(t *testing.T) {
 	}
 }
 
+func TestWalkErrorRoute(t *testing.T) {
+	router := NewRouter()
+	router.Path(""/g"")
+	expectedError := errors.New(""error"")
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		return expectedError
+	})
+	if err != expectedError {
+		t.Errorf(""Expected %v routes, found %v"", expectedError, err)
+	}
+}
+
+func TestWalkErrorMatcher(t *testing.T) {
+	router := NewRouter()
+	expectedError := router.Path(""/g"").Subrouter().Path("""").GetError()
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		return route.GetError()
+	})
+	if err != expectedError {
+		t.Errorf(""Expected %v routes, found %v"", expectedError, err)
+	}
+}
+
+func TestWalkErrorHandler(t *testing.T) {
+	handler := NewRouter()
+	expectedError := handler.Path(""/path"").Subrouter().Path("""").GetError()
+	router := NewRouter()
+	router.Path(""/g"").Handler(handler)
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		return route.GetError()
+	})
+	if err != expectedError {
+		t.Errorf(""Expected %v routes, found %v"", expectedError, err)
+	}
+}
+
 func TestSubrouterErrorHandling(t *testing.T) {
 	superRouterCalled := false
 	subRouterCalled := false",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=cf57124f1d4afc95248c663c559ef789ee099087,https://github.com/gorilla/mux/blob/cf57124f1d4afc95248c663c559ef789ee099087/mux_test.go
d391bea3118c9fc17a88d62c9189bb791255e0ef,93091e4501323de2b301420abe983fe5fbd07542,README.md,,"Mon, 18 Jul 2016 15:11:58 GMT",modified,1,1,2,"@@ -118,7 +118,7 @@ Then register routes in the subrouter:
 ```go
 s.HandleFunc(""/products/"", ProductsHandler)
 s.HandleFunc(""/products/{key}"", ProductHandler)
-s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+s.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
 ```
 
 The three URL paths we registered above will only be tested if the domain is `www.example.com`, because the subrouter is tested first. This is not only convenient, but also optimizes request matching. You can create subrouters combining any attribute matchers accepted by a route.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=d391bea3118c9fc17a88d62c9189bb791255e0ef,https://github.com/gorilla/mux/blob/d391bea3118c9fc17a88d62c9189bb791255e0ef/README.md
198f95d82475f2355940a96859f8b51a140ff86f,93091e4501323de2b301420abe983fe5fbd07542,README.md,,"Mon, 18 Jul 2016 05:28:55 GMT",modified,1,1,2,"@@ -118,7 +118,7 @@ Then register routes in the subrouter:
 ```go
 s.HandleFunc(""/products/"", ProductsHandler)
 s.HandleFunc(""/products/{key}"", ProductHandler)
-s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+s.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
 ```
 
 The three URL paths we registered above will only be tested if the domain is `www.example.com`, because the subrouter is tested first. This is not only convenient, but also optimizes request matching. You can create subrouters combining any attribute matchers accepted by a route.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=198f95d82475f2355940a96859f8b51a140ff86f,https://github.com/gorilla/mux/blob/198f95d82475f2355940a96859f8b51a140ff86f/README.md
9fa818a44c2bf1396a17f9d5a3c0f6dd39d2ff8e,fcbc42c41f4643b6daf359c69e51ebfb1d85f732,.travis.yml,,"Sun, 05 Jun 2016 23:35:21 GMT",modified,3,0,3,"@@ -10,6 +10,9 @@ matrix:
     - go: 1.6
     - go: tip
 
+install:
+  - # Skip
+
 script:
   - go get -t -v ./...
   - diff -u <(echo -n) <(gofmt -d .)",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=9fa818a44c2bf1396a17f9d5a3c0f6dd39d2ff8e,https://github.com/gorilla/mux/blob/9fa818a44c2bf1396a17f9d5a3c0f6dd39d2ff8e/.travis.yml
e84fac997f7f9015ca0c5a35bf0e7922070c98cb,d7adaa8fad4fa8ce62d18a7058d10723ff2288af,context_gorilla.go,,"Sat, 04 Jun 2016 16:35:56 GMT",added,26,0,26,"@@ -0,0 +1,26 @@
+// +build !go1.7
+
+package mux
+
+import (
+	""net/http""
+
+	""github.com/gorilla/context""
+)
+
+func contextGet(r *http.Request, key interface{}) interface{} {
+	return context.Get(r, key)
+}
+
+func contextSet(r *http.Request, key, val interface{}) *http.Request {
+	if val == nil {
+		return r
+	}
+
+	context.Set(r, key, val)
+	return r
+}
+
+func contextClear(r *http.Request) {
+	context.Clear(r)
+}",https://api.github.com/repos/gorilla/mux/contents/context_gorilla.go?ref=e84fac997f7f9015ca0c5a35bf0e7922070c98cb,https://github.com/gorilla/mux/blob/e84fac997f7f9015ca0c5a35bf0e7922070c98cb/context_gorilla.go
e84fac997f7f9015ca0c5a35bf0e7922070c98cb,ffaf384c0441a6f86d8e927f060c2255301242ce,context_gorilla_test.go,,"Sat, 04 Jun 2016 16:35:56 GMT",added,40,0,40,"@@ -0,0 +1,40 @@
+// +build !go1.7
+
+package mux
+
+import (
+	""net/http""
+	""testing""
+
+	""github.com/gorilla/context""
+)
+
+// Tests that the context is cleared or not cleared properly depending on
+// the configuration of the router
+func TestKeepContext(t *testing.T) {
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/"", func1).Name(""func1"")
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
+	context.Set(req, ""t"", 1)
+
+	res := new(http.ResponseWriter)
+	r.ServeHTTP(*res, req)
+
+	if _, ok := context.GetOk(req, ""t""); ok {
+		t.Error(""Context should have been cleared at end of request"")
+	}
+
+	r.KeepContext = true
+
+	req, _ = http.NewRequest(""GET"", ""http://localhost/"", nil)
+	context.Set(req, ""t"", 1)
+
+	r.ServeHTTP(*res, req)
+	if _, ok := context.GetOk(req, ""t""); !ok {
+		t.Error(""Context should NOT have been cleared at end of request"")
+	}
+
+}",https://api.github.com/repos/gorilla/mux/contents/context_gorilla_test.go?ref=e84fac997f7f9015ca0c5a35bf0e7922070c98cb,https://github.com/gorilla/mux/blob/e84fac997f7f9015ca0c5a35bf0e7922070c98cb/context_gorilla_test.go
e84fac997f7f9015ca0c5a35bf0e7922070c98cb,209cbea7d66170098a4c743f6e8746595e59f60f,context_native.go,,"Sat, 04 Jun 2016 16:35:56 GMT",added,24,0,24,"@@ -0,0 +1,24 @@
+// +build go1.7
+
+package mux
+
+import (
+	""context""
+	""net/http""
+)
+
+func contextGet(r *http.Request, key interface{}) interface{} {
+	return r.Context().Value(key)
+}
+
+func contextSet(r *http.Request, key, val interface{}) *http.Request {
+	if val == nil {
+		return r
+	}
+
+	return r.WithContext(context.WithValue(r.Context(), key, val))
+}
+
+func contextClear(r *http.Request) {
+	return
+}",https://api.github.com/repos/gorilla/mux/contents/context_native.go?ref=e84fac997f7f9015ca0c5a35bf0e7922070c98cb,https://github.com/gorilla/mux/blob/e84fac997f7f9015ca0c5a35bf0e7922070c98cb/context_native.go
e84fac997f7f9015ca0c5a35bf0e7922070c98cb,c150edf0166ffe6dcd43f001f75d73997071c1dd,context_native_test.go,,"Sat, 04 Jun 2016 16:35:56 GMT",added,32,0,32,"@@ -0,0 +1,32 @@
+// +build go1.7
+
+package mux
+
+import (
+	""context""
+	""net/http""
+	""testing""
+	""time""
+)
+
+func TestNativeContextMiddleware(t *testing.T) {
+	withTimeout := func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			ctx, cancel := context.WithTimeout(r.Context(), time.Minute)
+			defer cancel()
+			h.ServeHTTP(w, r.WithContext(ctx))
+		})
+	}
+
+	r := NewRouter()
+	r.Handle(""/path/{foo}"", withTimeout(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		vars := Vars(r)
+		if vars[""foo""] != ""bar"" {
+			t.Fatal(""Expected foo var to be set"")
+		}
+	})))
+
+	rec := NewRecorder()
+	req := newRequest(""GET"", ""/path/bar"")
+	r.ServeHTTP(rec, req)
+}",https://api.github.com/repos/gorilla/mux/contents/context_native_test.go?ref=e84fac997f7f9015ca0c5a35bf0e7922070c98cb,https://github.com/gorilla/mux/blob/e84fac997f7f9015ca0c5a35bf0e7922070c98cb/context_native_test.go
e84fac997f7f9015ca0c5a35bf0e7922070c98cb,f8c10f3bb815d7b828679cce8b8f088b5ec7eb44,mux.go,,"Sat, 04 Jun 2016 16:35:56 GMT",modified,12,16,28,"@@ -10,8 +10,6 @@ import (
 	""net/http""
 	""path""
 	""regexp""
-
-	""github.com/gorilla/context""
 )
 
 // NewRouter returns a new router instance.
@@ -50,7 +48,9 @@ type Router struct {
 	strictSlash bool
 	// See Router.SkipClean(). This defines the flag for new routes.
 	skipClean bool
-	// If true, do not clear the request context after handling the request
+	// If true, do not clear the request context after handling the request.
+	// This has no effect when go1.7+ is used, since the context is stored
+	// on the request itself.
 	KeepContext bool
 }
 
@@ -95,14 +95,14 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	var handler http.Handler
 	if r.Match(req, &match) {
 		handler = match.Handler
-		setVars(req, match.Vars)
-		setCurrentRoute(req, match.Route)
+		req = setVars(req, match.Vars)
+		req = setCurrentRoute(req, match.Route)
 	}
 	if handler == nil {
 		handler = http.NotFoundHandler()
 	}
 	if !r.KeepContext {
-		defer context.Clear(req)
+		defer contextClear(req)
 	}
 	handler.ServeHTTP(w, req)
 }
@@ -325,7 +325,7 @@ const (
 
 // Vars returns the route variables for the current request, if any.
 func Vars(r *http.Request) map[string]string {
-	if rv := context.Get(r, varsKey); rv != nil {
+	if rv := contextGet(r, varsKey); rv != nil {
 		return rv.(map[string]string)
 	}
 	return nil
@@ -337,22 +337,18 @@ func Vars(r *http.Request) map[string]string {
 // after the handler returns, unless the KeepContext option is set on the
 // Router.
 func CurrentRoute(r *http.Request) *Route {
-	if rv := context.Get(r, routeKey); rv != nil {
+	if rv := contextGet(r, routeKey); rv != nil {
 		return rv.(*Route)
 	}
 	return nil
 }
 
-func setVars(r *http.Request, val interface{}) {
-	if val != nil {
-		context.Set(r, varsKey, val)
-	}
+func setVars(r *http.Request, val interface{}) *http.Request {
+	return contextSet(r, varsKey, val)
 }
 
-func setCurrentRoute(r *http.Request, val interface{}) {
-	if val != nil {
-		context.Set(r, routeKey, val)
-	}
+func setCurrentRoute(r *http.Request, val interface{}) *http.Request {
+	return contextSet(r, routeKey, val)
 }
 
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=e84fac997f7f9015ca0c5a35bf0e7922070c98cb,https://github.com/gorilla/mux/blob/e84fac997f7f9015ca0c5a35bf0e7922070c98cb/mux.go
e84fac997f7f9015ca0c5a35bf0e7922070c98cb,98ac82d87e9accf52ec4c7aef8d05abddf77d188,mux_test.go,,"Sat, 04 Jun 2016 16:35:56 GMT",modified,0,32,32,"@@ -9,8 +9,6 @@ import (
 	""net/http""
 	""strings""
 	""testing""
-
-	""github.com/gorilla/context""
 )
 
 func (r *Route) GoString() string {
@@ -1316,36 +1314,6 @@ func testTemplate(t *testing.T, test routeTest) {
 	}
 }
 
-// Tests that the context is cleared or not cleared properly depending on
-// the configuration of the router
-func TestKeepContext(t *testing.T) {
-	func1 := func(w http.ResponseWriter, r *http.Request) {}
-
-	r := NewRouter()
-	r.HandleFunc(""/"", func1).Name(""func1"")
-
-	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
-	context.Set(req, ""t"", 1)
-
-	res := new(http.ResponseWriter)
-	r.ServeHTTP(*res, req)
-
-	if _, ok := context.GetOk(req, ""t""); ok {
-		t.Error(""Context should have been cleared at end of request"")
-	}
-
-	r.KeepContext = true
-
-	req, _ = http.NewRequest(""GET"", ""http://localhost/"", nil)
-	context.Set(req, ""t"", 1)
-
-	r.ServeHTTP(*res, req)
-	if _, ok := context.GetOk(req, ""t""); !ok {
-		t.Error(""Context should NOT have been cleared at end of request"")
-	}
-
-}
-
 type TestA301ResponseWriter struct {
 	hh     http.Header
 	status int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e84fac997f7f9015ca0c5a35bf0e7922070c98cb,https://github.com/gorilla/mux/blob/e84fac997f7f9015ca0c5a35bf0e7922070c98cb/mux_test.go
fdfca9f9173962ed22bc63adc02a1589e43c1405,d7adaa8fad4fa8ce62d18a7058d10723ff2288af,context_gorilla.go,,"Sat, 04 Jun 2016 08:38:01 GMT",added,26,0,26,"@@ -0,0 +1,26 @@
+// +build !go1.7
+
+package mux
+
+import (
+	""net/http""
+
+	""github.com/gorilla/context""
+)
+
+func contextGet(r *http.Request, key interface{}) interface{} {
+	return context.Get(r, key)
+}
+
+func contextSet(r *http.Request, key, val interface{}) *http.Request {
+	if val == nil {
+		return r
+	}
+
+	context.Set(r, key, val)
+	return r
+}
+
+func contextClear(r *http.Request) {
+	context.Clear(r)
+}",https://api.github.com/repos/gorilla/mux/contents/context_gorilla.go?ref=fdfca9f9173962ed22bc63adc02a1589e43c1405,https://github.com/gorilla/mux/blob/fdfca9f9173962ed22bc63adc02a1589e43c1405/context_gorilla.go
fdfca9f9173962ed22bc63adc02a1589e43c1405,ffaf384c0441a6f86d8e927f060c2255301242ce,context_gorilla_test.go,,"Sat, 04 Jun 2016 08:38:01 GMT",added,40,0,40,"@@ -0,0 +1,40 @@
+// +build !go1.7
+
+package mux
+
+import (
+	""net/http""
+	""testing""
+
+	""github.com/gorilla/context""
+)
+
+// Tests that the context is cleared or not cleared properly depending on
+// the configuration of the router
+func TestKeepContext(t *testing.T) {
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/"", func1).Name(""func1"")
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
+	context.Set(req, ""t"", 1)
+
+	res := new(http.ResponseWriter)
+	r.ServeHTTP(*res, req)
+
+	if _, ok := context.GetOk(req, ""t""); ok {
+		t.Error(""Context should have been cleared at end of request"")
+	}
+
+	r.KeepContext = true
+
+	req, _ = http.NewRequest(""GET"", ""http://localhost/"", nil)
+	context.Set(req, ""t"", 1)
+
+	r.ServeHTTP(*res, req)
+	if _, ok := context.GetOk(req, ""t""); !ok {
+		t.Error(""Context should NOT have been cleared at end of request"")
+	}
+
+}",https://api.github.com/repos/gorilla/mux/contents/context_gorilla_test.go?ref=fdfca9f9173962ed22bc63adc02a1589e43c1405,https://github.com/gorilla/mux/blob/fdfca9f9173962ed22bc63adc02a1589e43c1405/context_gorilla_test.go
fdfca9f9173962ed22bc63adc02a1589e43c1405,209cbea7d66170098a4c743f6e8746595e59f60f,context_native.go,,"Sat, 04 Jun 2016 08:38:01 GMT",added,24,0,24,"@@ -0,0 +1,24 @@
+// +build go1.7
+
+package mux
+
+import (
+	""context""
+	""net/http""
+)
+
+func contextGet(r *http.Request, key interface{}) interface{} {
+	return r.Context().Value(key)
+}
+
+func contextSet(r *http.Request, key, val interface{}) *http.Request {
+	if val == nil {
+		return r
+	}
+
+	return r.WithContext(context.WithValue(r.Context(), key, val))
+}
+
+func contextClear(r *http.Request) {
+	return
+}",https://api.github.com/repos/gorilla/mux/contents/context_native.go?ref=fdfca9f9173962ed22bc63adc02a1589e43c1405,https://github.com/gorilla/mux/blob/fdfca9f9173962ed22bc63adc02a1589e43c1405/context_native.go
fdfca9f9173962ed22bc63adc02a1589e43c1405,c150edf0166ffe6dcd43f001f75d73997071c1dd,context_native_test.go,context_test.go,"Sat, 04 Jun 2016 08:38:01 GMT",renamed,0,0,0,,https://api.github.com/repos/gorilla/mux/contents/context_native_test.go?ref=fdfca9f9173962ed22bc63adc02a1589e43c1405,https://github.com/gorilla/mux/blob/fdfca9f9173962ed22bc63adc02a1589e43c1405/context_native_test.go
fdfca9f9173962ed22bc63adc02a1589e43c1405,f8c10f3bb815d7b828679cce8b8f088b5ec7eb44,mux.go,,"Sat, 04 Jun 2016 08:38:01 GMT",modified,12,16,28,"@@ -10,8 +10,6 @@ import (
 	""net/http""
 	""path""
 	""regexp""
-
-	""github.com/gorilla/context""
 )
 
 // NewRouter returns a new router instance.
@@ -50,7 +48,9 @@ type Router struct {
 	strictSlash bool
 	// See Router.SkipClean(). This defines the flag for new routes.
 	skipClean bool
-	// If true, do not clear the request context after handling the request
+	// If true, do not clear the request context after handling the request.
+	// This has no effect when go1.7+ is used, since the context is stored
+	// on the request itself.
 	KeepContext bool
 }
 
@@ -95,14 +95,14 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	var handler http.Handler
 	if r.Match(req, &match) {
 		handler = match.Handler
-		setVars(req, match.Vars)
-		setCurrentRoute(req, match.Route)
+		req = setVars(req, match.Vars)
+		req = setCurrentRoute(req, match.Route)
 	}
 	if handler == nil {
 		handler = http.NotFoundHandler()
 	}
 	if !r.KeepContext {
-		defer context.Clear(req)
+		defer contextClear(req)
 	}
 	handler.ServeHTTP(w, req)
 }
@@ -325,7 +325,7 @@ const (
 
 // Vars returns the route variables for the current request, if any.
 func Vars(r *http.Request) map[string]string {
-	if rv := context.Get(r, varsKey); rv != nil {
+	if rv := contextGet(r, varsKey); rv != nil {
 		return rv.(map[string]string)
 	}
 	return nil
@@ -337,22 +337,18 @@ func Vars(r *http.Request) map[string]string {
 // after the handler returns, unless the KeepContext option is set on the
 // Router.
 func CurrentRoute(r *http.Request) *Route {
-	if rv := context.Get(r, routeKey); rv != nil {
+	if rv := contextGet(r, routeKey); rv != nil {
 		return rv.(*Route)
 	}
 	return nil
 }
 
-func setVars(r *http.Request, val interface{}) {
-	if val != nil {
-		context.Set(r, varsKey, val)
-	}
+func setVars(r *http.Request, val interface{}) *http.Request {
+	return contextSet(r, varsKey, val)
 }
 
-func setCurrentRoute(r *http.Request, val interface{}) {
-	if val != nil {
-		context.Set(r, routeKey, val)
-	}
+func setCurrentRoute(r *http.Request, val interface{}) *http.Request {
+	return contextSet(r, routeKey, val)
 }
 
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=fdfca9f9173962ed22bc63adc02a1589e43c1405,https://github.com/gorilla/mux/blob/fdfca9f9173962ed22bc63adc02a1589e43c1405/mux.go
fdfca9f9173962ed22bc63adc02a1589e43c1405,98ac82d87e9accf52ec4c7aef8d05abddf77d188,mux_test.go,,"Sat, 04 Jun 2016 08:38:01 GMT",modified,0,32,32,"@@ -9,8 +9,6 @@ import (
 	""net/http""
 	""strings""
 	""testing""
-
-	""github.com/gorilla/context""
 )
 
 func (r *Route) GoString() string {
@@ -1316,36 +1314,6 @@ func testTemplate(t *testing.T, test routeTest) {
 	}
 }
 
-// Tests that the context is cleared or not cleared properly depending on
-// the configuration of the router
-func TestKeepContext(t *testing.T) {
-	func1 := func(w http.ResponseWriter, r *http.Request) {}
-
-	r := NewRouter()
-	r.HandleFunc(""/"", func1).Name(""func1"")
-
-	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
-	context.Set(req, ""t"", 1)
-
-	res := new(http.ResponseWriter)
-	r.ServeHTTP(*res, req)
-
-	if _, ok := context.GetOk(req, ""t""); ok {
-		t.Error(""Context should have been cleared at end of request"")
-	}
-
-	r.KeepContext = true
-
-	req, _ = http.NewRequest(""GET"", ""http://localhost/"", nil)
-	context.Set(req, ""t"", 1)
-
-	r.ServeHTTP(*res, req)
-	if _, ok := context.GetOk(req, ""t""); !ok {
-		t.Error(""Context should NOT have been cleared at end of request"")
-	}
-
-}
-
 type TestA301ResponseWriter struct {
 	hh     http.Header
 	status int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=fdfca9f9173962ed22bc63adc02a1589e43c1405,https://github.com/gorilla/mux/blob/fdfca9f9173962ed22bc63adc02a1589e43c1405/mux_test.go
5dd56998c22c824ad2e13c50bc3213e85b125134,c150edf0166ffe6dcd43f001f75d73997071c1dd,context_test.go,,"Sat, 04 Jun 2016 08:21:55 GMT",added,32,0,32,"@@ -0,0 +1,32 @@
+// +build go1.7
+
+package mux
+
+import (
+	""context""
+	""net/http""
+	""testing""
+	""time""
+)
+
+func TestNativeContextMiddleware(t *testing.T) {
+	withTimeout := func(h http.Handler) http.Handler {
+		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+			ctx, cancel := context.WithTimeout(r.Context(), time.Minute)
+			defer cancel()
+			h.ServeHTTP(w, r.WithContext(ctx))
+		})
+	}
+
+	r := NewRouter()
+	r.Handle(""/path/{foo}"", withTimeout(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		vars := Vars(r)
+		if vars[""foo""] != ""bar"" {
+			t.Fatal(""Expected foo var to be set"")
+		}
+	})))
+
+	rec := NewRecorder()
+	req := newRequest(""GET"", ""/path/bar"")
+	r.ServeHTTP(rec, req)
+}",https://api.github.com/repos/gorilla/mux/contents/context_test.go?ref=5dd56998c22c824ad2e13c50bc3213e85b125134,https://github.com/gorilla/mux/blob/5dd56998c22c824ad2e13c50bc3213e85b125134/context_test.go
bd09be08ed4377796d312df0a45314e11b8f5dc1,960ef7c1514d9b82c7dd1077f7554c351d50021c,README.md,,"Wed, 25 May 2016 14:09:13 GMT",modified,2,2,4,"@@ -219,7 +219,7 @@ package main
 
 import (
 	""net/http""
-
+	""log""
 	""github.com/gorilla/mux""
 )
 
@@ -233,7 +233,7 @@ func main() {
 	r.HandleFunc(""/"", YourHandler)
 
 	// Bind to a port and pass our router in
-	http.ListenAndServe("":8000"", r)
+	log.Fatal(http.ListenAndServe("":8000"", r))
 }
 ```
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=bd09be08ed4377796d312df0a45314e11b8f5dc1,https://github.com/gorilla/mux/blob/bd09be08ed4377796d312df0a45314e11b8f5dc1/README.md
0d753bb8ca03e2ff6017f7a82e3dd56187cd28d6,960ef7c1514d9b82c7dd1077f7554c351d50021c,README.md,,"Wed, 25 May 2016 13:44:10 GMT",modified,2,2,4,"@@ -219,7 +219,7 @@ package main
 
 import (
 	""net/http""
-
+	""log""
 	""github.com/gorilla/mux""
 )
 
@@ -233,7 +233,7 @@ func main() {
 	r.HandleFunc(""/"", YourHandler)
 
 	// Bind to a port and pass our router in
-	http.ListenAndServe("":8000"", r)
+	log.Fatal(http.ListenAndServe("":8000"", r))
 }
 ```
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=0d753bb8ca03e2ff6017f7a82e3dd56187cd28d6,https://github.com/gorilla/mux/blob/0d753bb8ca03e2ff6017f7a82e3dd56187cd28d6/README.md
9c19ed558d5df4da88e2ade9c8940d742aef0e7e,f4084bd816c874e20ab512eb882ca843bb7f1565,.travis.yml,,"Mon, 02 May 2016 17:56:24 GMT",modified,0,3,3,"@@ -10,9 +10,6 @@ matrix:
     - go: 1.6
     - go: tip
 
-install:
-  - go get golang.org/x/tools/cmd/vet
-
 script:
   - go get -t -v ./...
   - diff -u <(echo -n) <(gofmt -d .)",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=9c19ed558d5df4da88e2ade9c8940d742aef0e7e,https://github.com/gorilla/mux/blob/9c19ed558d5df4da88e2ade9c8940d742aef0e7e/.travis.yml
9c19ed558d5df4da88e2ade9c8940d742aef0e7e,94f5ddd9c76b6843ac4340db2a3a7cc9b12336bc,mux.go,,"Mon, 02 May 2016 17:56:24 GMT",modified,32,14,46,"@@ -48,6 +48,8 @@ type Router struct {
 	namedRoutes map[string]*Route
 	// See Router.StrictSlash(). This defines the flag for new routes.
 	strictSlash bool
+	// See Router.SkipClean(). This defines the flag for new routes.
+	skipClean bool
 	// If true, do not clear the request context after handling the request
 	KeepContext bool
 }
@@ -73,19 +75,21 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 // When there is a match, the route variables can be retrieved calling
 // mux.Vars(request).
 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
-	// Clean path to canonical form and redirect.
-	if p := cleanPath(req.URL.Path); p != req.URL.Path {
-
-		// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
-		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
-		// http://code.google.com/p/go/issues/detail?id=5252
-		url := *req.URL
-		url.Path = p
-		p = url.String()
-
-		w.Header().Set(""Location"", p)
-		w.WriteHeader(http.StatusMovedPermanently)
-		return
+	if !r.skipClean {
+		// Clean path to canonical form and redirect.
+		if p := cleanPath(req.URL.Path); p != req.URL.Path {
+
+			// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
+			// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
+			// http://code.google.com/p/go/issues/detail?id=5252
+			url := *req.URL
+			url.Path = p
+			p = url.String()
+
+			w.Header().Set(""Location"", p)
+			w.WriteHeader(http.StatusMovedPermanently)
+			return
+		}
 	}
 	var match RouteMatch
 	var handler http.Handler
@@ -133,6 +137,19 @@ func (r *Router) StrictSlash(value bool) *Router {
 	return r
 }
 
+// SkipClean defines the path cleaning behaviour for new routes. The initial
+// value is false. Users should be careful about which routes are not cleaned
+//
+// When true, if the route path is ""/path//to"", it will remain with the double
+// slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/
+//
+// When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will
+// become /fetch/http/xkcd.com/534
+func (r *Router) SkipClean(value bool) *Router {
+	r.skipClean = value
+	return r
+}
+
 // ----------------------------------------------------------------------------
 // parentRoute
 // ----------------------------------------------------------------------------
@@ -170,7 +187,7 @@ func (r *Router) buildVars(m map[string]string) map[string]string {
 
 // NewRoute registers an empty route.
 func (r *Router) NewRoute() *Route {
-	route := &Route{parent: r, strictSlash: r.strictSlash}
+	route := &Route{parent: r, strictSlash: r.strictSlash, skipClean: r.skipClean}
 	r.routes = append(r.routes, route)
 	return route
 }
@@ -357,6 +374,7 @@ func cleanPath(p string) string {
 	if p[len(p)-1] == '/' && np != ""/"" {
 		np += ""/""
 	}
+
 	return np
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=9c19ed558d5df4da88e2ade9c8940d742aef0e7e,https://github.com/gorilla/mux/blob/9c19ed558d5df4da88e2ade9c8940d742aef0e7e/mux.go
9c19ed558d5df4da88e2ade9c8940d742aef0e7e,777d063c0509fe64c3e0531cfddafa6dc15b1401,mux_test.go,,"Mon, 02 May 2016 17:56:24 GMT",modified,18,0,18,"@@ -1386,6 +1386,24 @@ func Test301Redirect(t *testing.T) {
 	}
 }
 
+func TestSkipClean(t *testing.T) {
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+	func2 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.SkipClean(true)
+	r.HandleFunc(""/api/"", func2).Name(""func2"")
+	r.HandleFunc(""/"", func1).Name(""func1"")
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost//api/?abc=def"", nil)
+	res := NewRecorder()
+	r.ServeHTTP(res, req)
+
+	if len(res.HeaderMap[""Location""]) != 0 {
+		t.Errorf(""Shouldn't redirect since skip clean is disabled"")
+	}
+}
+
 // https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
 func TestSubrouterHeader(t *testing.T) {
 	expected := ""func1 response""",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=9c19ed558d5df4da88e2ade9c8940d742aef0e7e,https://github.com/gorilla/mux/blob/9c19ed558d5df4da88e2ade9c8940d742aef0e7e/mux_test.go
9c19ed558d5df4da88e2ade9c8940d742aef0e7e,6c53f9f1de2304e9cda30510df1f2551f4b2da57,route.go,,"Mon, 02 May 2016 17:56:24 GMT",modified,7,0,7,"@@ -26,6 +26,9 @@ type Route struct {
 	// If true, when the path pattern is ""/path/"", accessing ""/path"" will
 	// redirect to the former and vice versa.
 	strictSlash bool
+	// If true, when the path pattern is ""/path//to"", accessing ""/path//to""
+	// will not redirect
+	skipClean bool
 	// If true, this route never matches: it is only used to build URLs.
 	buildOnly bool
 	// The name used to build URLs.
@@ -36,6 +39,10 @@ type Route struct {
 	buildVarsFunc BuildVarsFunc
 }
 
+func (r *Route) SkipClean() bool {
+	return r.skipClean
+}
+
 // Match matches the route against the request.
 func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if r.buildOnly || r.err != nil {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=9c19ed558d5df4da88e2ade9c8940d742aef0e7e,https://github.com/gorilla/mux/blob/9c19ed558d5df4da88e2ade9c8940d742aef0e7e/route.go
12a13f34e4fd6f7c8cbd499c446bded8d09ad8ad,f4084bd816c874e20ab512eb882ca843bb7f1565,.travis.yml,,"Mon, 02 May 2016 17:30:24 GMT",modified,0,3,3,"@@ -10,9 +10,6 @@ matrix:
     - go: 1.6
     - go: tip
 
-install:
-  - go get golang.org/x/tools/cmd/vet
-
 script:
   - go get -t -v ./...
   - diff -u <(echo -n) <(gofmt -d .)",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=12a13f34e4fd6f7c8cbd499c446bded8d09ad8ad,https://github.com/gorilla/mux/blob/12a13f34e4fd6f7c8cbd499c446bded8d09ad8ad/.travis.yml
05d9d908e791c45f6deff3ea85fd6fd3a340a4c7,6c53f9f1de2304e9cda30510df1f2551f4b2da57,route.go,,"Mon, 02 May 2016 17:24:47 GMT",modified,4,0,4,"@@ -39,6 +39,10 @@ type Route struct {
 	buildVarsFunc BuildVarsFunc
 }
 
+func (r *Route) SkipClean() bool {
+	return r.skipClean
+}
+
 // Match matches the route against the request.
 func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if r.buildOnly || r.err != nil {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=05d9d908e791c45f6deff3ea85fd6fd3a340a4c7,https://github.com/gorilla/mux/blob/05d9d908e791c45f6deff3ea85fd6fd3a340a4c7/route.go
9935257381196ec7a0d4fd92fa0f61f24cd014bc,f147bb68ddb9beb0089f98f87b72ff67c25af033,mux_test.go,,"Mon, 02 May 2016 17:24:18 GMT",modified,18,0,18,"@@ -1376,6 +1376,24 @@ func Test301Redirect(t *testing.T) {
 	}
 }
 
+func TestSkipClean(t *testing.T) {
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+	func2 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.SkipClean(true)
+	r.HandleFunc(""/api/"", func2).Name(""func2"")
+	r.HandleFunc(""/"", func1).Name(""func1"")
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost//api/?abc=def"", nil)
+	res := NewRecorder()
+	r.ServeHTTP(res, req)
+
+	if len(res.HeaderMap[""Location""]) != 0 {
+		t.Errorf(""Shouldn't redirect since skip clean is disabled"")
+	}
+}
+
 // https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
 func TestSubrouterHeader(t *testing.T) {
 	expected := ""func1 response""",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=9935257381196ec7a0d4fd92fa0f61f24cd014bc,https://github.com/gorilla/mux/blob/9935257381196ec7a0d4fd92fa0f61f24cd014bc/mux_test.go
a41434aac388acdf2aa28ba41cde5cd998feedd3,94f5ddd9c76b6843ac4340db2a3a7cc9b12336bc,mux.go,,"Mon, 02 May 2016 17:24:09 GMT",modified,1,1,2,"@@ -138,7 +138,7 @@ func (r *Router) StrictSlash(value bool) *Router {
 }
 
 // SkipClean defines the path cleaning behaviour for new routes. The initial
-// value is false.
+// value is false. Users should be careful about which routes are not cleaned
 //
 // When true, if the route path is ""/path//to"", it will remain with the double
 // slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=a41434aac388acdf2aa28ba41cde5cd998feedd3,https://github.com/gorilla/mux/blob/a41434aac388acdf2aa28ba41cde5cd998feedd3/mux.go
0eeaf8392f5b04950925b8a69fe70f110fa7cbfc,c385a25191dd118ef6c5d594ef60d103f433546d,old_test.go,,"Thu, 17 Mar 2016 21:34:30 GMT",modified,0,4,4,"@@ -36,10 +36,6 @@ func NewRecorder() *ResponseRecorder {
 	}
 }
 
-// DefaultRemoteAddr is the default remote address to return in RemoteAddr if
-// an explicit DefaultRemoteAddr isn't set on ResponseRecorder.
-const DefaultRemoteAddr = ""1.2.3.4""
-
 // Header returns the response headers.
 func (rw *ResponseRecorder) Header() http.Header {
 	return rw.HeaderMap",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=0eeaf8392f5b04950925b8a69fe70f110fa7cbfc,https://github.com/gorilla/mux/blob/0eeaf8392f5b04950925b8a69fe70f110fa7cbfc/old_test.go
8e05c69b5a3a77a2eafb48df5f230250d2752718,c385a25191dd118ef6c5d594ef60d103f433546d,old_test.go,,"Thu, 17 Mar 2016 21:23:30 GMT",modified,0,4,4,"@@ -36,10 +36,6 @@ func NewRecorder() *ResponseRecorder {
 	}
 }
 
-// DefaultRemoteAddr is the default remote address to return in RemoteAddr if
-// an explicit DefaultRemoteAddr isn't set on ResponseRecorder.
-const DefaultRemoteAddr = ""1.2.3.4""
-
 // Header returns the response headers.
 func (rw *ResponseRecorder) Header() http.Header {
 	return rw.HeaderMap",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=8e05c69b5a3a77a2eafb48df5f230250d2752718,https://github.com/gorilla/mux/blob/8e05c69b5a3a77a2eafb48df5f230250d2752718/old_test.go
acf3be1b335c8ce30b2c8d51300984666f0ceefa,a44d03f8050833bd6197c882ba0c0c96ab38c4c6,mux_test.go,,"Mon, 07 Mar 2016 22:01:44 GMT",modified,10,0,10,"@@ -370,6 +370,16 @@ func TestPath(t *testing.T) {
 			path_template: `/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}`,
 			shouldMatch:   true,
 		},
+		{
+			title:         ""Path route with multiple hyphenated names and patterns with pipe and case insensitive, match"",
+			route:         new(Route).Path(""/{type:(?i:daily|mini|variety)}-{date:\\d{4,4}-\\d{2,2}-\\d{2,2}}""),
+			request:       newRequest(""GET"", ""http://localhost/daily-2016-01-01""),
+			vars:          map[string]string{""type"": ""daily"", ""date"": ""2016-01-01""},
+			host:          """",
+			path:          ""/daily-2016-01-01"",
+			path_template: `/{type:(?i:daily|mini|variety)}-{date:\d{4,4}-\d{2,2}-\d{2,2}}`,
+			shouldMatch:   true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=acf3be1b335c8ce30b2c8d51300984666f0ceefa,https://github.com/gorilla/mux/blob/acf3be1b335c8ce30b2c8d51300984666f0ceefa/mux_test.go
acf3be1b335c8ce30b2c8d51300984666f0ceefa,08710bc984712aa6badbc16776bcf1ac87ad0125,regexp.go,,"Mon, 07 Mar 2016 22:01:44 GMT",modified,2,5,7,"@@ -73,11 +73,8 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		if patt[0] == '(' && patt[len(patt)-1] == ')' {
-			fmt.Fprintf(pattern, ""%s%s"", regexp.QuoteMeta(raw), patt)
-		} else {
-			fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
-		}
+		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), varGroupName(i/2), patt)
+
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 ",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=acf3be1b335c8ce30b2c8d51300984666f0ceefa,https://github.com/gorilla/mux/blob/acf3be1b335c8ce30b2c8d51300984666f0ceefa/regexp.go
65c2651643a9eb5438d10f1c492ba892fe96244f,a44d03f8050833bd6197c882ba0c0c96ab38c4c6,mux_test.go,,"Mon, 07 Mar 2016 21:38:03 GMT",modified,10,0,10,"@@ -370,6 +370,16 @@ func TestPath(t *testing.T) {
 			path_template: `/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}`,
 			shouldMatch:   true,
 		},
+		{
+			title:         ""Path route with multiple hyphenated names and patterns with pipe and case insensitive, match"",
+			route:         new(Route).Path(""/{type:(?i:daily|mini|variety)}-{date:\\d{4,4}-\\d{2,2}-\\d{2,2}}""),
+			request:       newRequest(""GET"", ""http://localhost/daily-2016-01-01""),
+			vars:          map[string]string{""type"": ""daily"", ""date"": ""2016-01-01""},
+			host:          """",
+			path:          ""/daily-2016-01-01"",
+			path_template: `/{type:(?i:daily|mini|variety)}-{date:\d{4,4}-\d{2,2}-\d{2,2}}`,
+			shouldMatch:   true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=65c2651643a9eb5438d10f1c492ba892fe96244f,https://github.com/gorilla/mux/blob/65c2651643a9eb5438d10f1c492ba892fe96244f/mux_test.go
65c2651643a9eb5438d10f1c492ba892fe96244f,08710bc984712aa6badbc16776bcf1ac87ad0125,regexp.go,,"Mon, 07 Mar 2016 21:38:03 GMT",modified,2,5,7,"@@ -73,11 +73,8 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		if patt[0] == '(' && patt[len(patt)-1] == ')' {
-			fmt.Fprintf(pattern, ""%s%s"", regexp.QuoteMeta(raw), patt)
-		} else {
-			fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
-		}
+		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), varGroupName(i/2), patt)
+
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 ",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=65c2651643a9eb5438d10f1c492ba892fe96244f,https://github.com/gorilla/mux/blob/65c2651643a9eb5438d10f1c492ba892fe96244f/regexp.go
786d36e5ab042d67efe94022439cf6c91ee711dc,c982c13cf1ac3de3cbc7796e497ce9c76e438171,mux.go,,"Mon, 07 Mar 2016 19:43:49 GMT",modified,6,6,12,"@@ -79,12 +79,12 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		// Clean path to canonical form and redirect.
 		if p := cleanPath(req.URL.Path); p != req.URL.Path {
 
-		// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
-		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
-		// http://code.google.com/p/go/issues/detail?id=5252
-		url := *req.URL
-		url.Path = p
-		p = url.String()
+			// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
+			// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
+			// http://code.google.com/p/go/issues/detail?id=5252
+			url := *req.URL
+			url.Path = p
+			p = url.String()
 
 			w.Header().Set(""Location"", p)
 			w.WriteHeader(http.StatusMovedPermanently)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=786d36e5ab042d67efe94022439cf6c91ee711dc,https://github.com/gorilla/mux/blob/786d36e5ab042d67efe94022439cf6c91ee711dc/mux.go
786d36e5ab042d67efe94022439cf6c91ee711dc,ca54610bfb8eed26a68e193b43d561717f72034d,route.go,,"Mon, 07 Mar 2016 19:43:49 GMT",modified,6,6,12,"@@ -23,12 +23,12 @@ type Route struct {
 	matchers []matcher
 	// Manager for the variables from host and path.
 	regexp *routeRegexpGroup
-    // If true, when the path pattern is ""/path/"", accessing ""/path"" will
-    // redirect to the former and vice versa.
-    strictSlash bool
-    // If true, when the path pattern is ""/path//to"", accessing ""/path//to""
-    // will not redirect
-    skipClean bool
+	// If true, when the path pattern is ""/path/"", accessing ""/path"" will
+	// redirect to the former and vice versa.
+	strictSlash bool
+	// If true, when the path pattern is ""/path//to"", accessing ""/path//to""
+	// will not redirect
+	skipClean bool
 	// If true, this route never matches: it is only used to build URLs.
 	buildOnly bool
 	// The name used to build URLs.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=786d36e5ab042d67efe94022439cf6c91ee711dc,https://github.com/gorilla/mux/blob/786d36e5ab042d67efe94022439cf6c91ee711dc/route.go
8ac5cf967fbadf2522625826070379e0fd6e2f98,b3996991ebd39f93061dfe25cd0df500af9d31a5,mux.go,,"Mon, 07 Mar 2016 19:41:38 GMT",modified,24,6,30,"@@ -48,6 +48,8 @@ type Router struct {
 	namedRoutes map[string]*Route
 	// See Router.StrictSlash(). This defines the flag for new routes.
 	strictSlash bool
+	// See Router.SkipClean(). This defines the flag for new routes.
+	skipClean bool
 	// If true, do not clear the request context after handling the request
 	KeepContext bool
 }
@@ -73,8 +75,9 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 // When there is a match, the route variables can be retrieved calling
 // mux.Vars(request).
 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
-	// Clean path to canonical form and redirect.
-	if p := cleanPath(req.URL.Path); p != req.URL.Path {
+	if !r.skipClean {
+		// Clean path to canonical form and redirect.
+		if p := cleanPath(req.URL.Path); p != req.URL.Path {
 
 		// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
 		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
@@ -83,9 +86,10 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		url.Path = p
 		p = url.String()
 
-		w.Header().Set(""Location"", p)
-		w.WriteHeader(http.StatusMovedPermanently)
-		return
+			w.Header().Set(""Location"", p)
+			w.WriteHeader(http.StatusMovedPermanently)
+			return
+		}
 	}
 	var match RouteMatch
 	var handler http.Handler
@@ -133,6 +137,19 @@ func (r *Router) StrictSlash(value bool) *Router {
 	return r
 }
 
+// SkipClean defines the path cleaning behaviour for new routes. The initial
+// value is false.
+//
+// When true, if the route path is ""/path//to"", it will remain with the double
+// slash. This is helpful if you have a route like: /fetch/http://xkcd.com/534/
+//
+// When false, the path will be cleaned, so /fetch/http://xkcd.com/534/ will
+// become /fetch/http/xkcd.com/534
+func (r *Router) SkipClean(value bool) *Router {
+	r.skipClean = value
+	return r
+}
+
 // ----------------------------------------------------------------------------
 // parentRoute
 // ----------------------------------------------------------------------------
@@ -170,7 +187,7 @@ func (r *Router) buildVars(m map[string]string) map[string]string {
 
 // NewRoute registers an empty route.
 func (r *Router) NewRoute() *Route {
-	route := &Route{parent: r, strictSlash: r.strictSlash}
+	route := &Route{parent: r, strictSlash: r.strictSlash, skipClean: r.skipClean}
 	r.routes = append(r.routes, route)
 	return route
 }
@@ -357,6 +374,7 @@ func cleanPath(p string) string {
 	if p[len(p)-1] == '/' && np != ""/"" {
 		np += ""/""
 	}
+
 	return np
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=8ac5cf967fbadf2522625826070379e0fd6e2f98,https://github.com/gorilla/mux/blob/8ac5cf967fbadf2522625826070379e0fd6e2f98/mux.go
8ac5cf967fbadf2522625826070379e0fd6e2f98,6f1ef38da5f688de2a33d7bb703fc96a9e5c6928,route.go,,"Mon, 07 Mar 2016 19:41:38 GMT",modified,6,3,9,"@@ -23,9 +23,12 @@ type Route struct {
 	matchers []matcher
 	// Manager for the variables from host and path.
 	regexp *routeRegexpGroup
-	// If true, when the path pattern is ""/path/"", accessing ""/path"" will
-	// redirect to the former and vice versa.
-	strictSlash bool
+    // If true, when the path pattern is ""/path/"", accessing ""/path"" will
+    // redirect to the former and vice versa.
+    strictSlash bool
+    // If true, when the path pattern is ""/path//to"", accessing ""/path//to""
+    // will not redirect
+    skipClean bool
 	// If true, this route never matches: it is only used to build URLs.
 	buildOnly bool
 	// The name used to build URLs.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=8ac5cf967fbadf2522625826070379e0fd6e2f98,https://github.com/gorilla/mux/blob/8ac5cf967fbadf2522625826070379e0fd6e2f98/route.go
147a95f5e36a65f1c7b29440b9b0283aab154693,8912d09511a71562870756a1c91fe61b1d1e7223,mux_test.go,,"Sat, 05 Mar 2016 13:56:38 GMT",modified,419,334,753,"@@ -32,6 +32,8 @@ type routeTest struct {
 	vars           map[string]string // the expected vars of the match
 	host           string            // the expected host of the match
 	path           string            // the expected path of the match
+	path_template  string            // the expected path template to match
+	host_template  string            // the expected host template to match
 	shouldMatch    bool              // whether the request is expected to match the route at all
 	shouldRedirect bool              // whether the request should result in a redirect
 }
@@ -113,116 +115,129 @@ func TestHost(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:       ""Host route with pattern, match"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Host route with pattern, additional capturing group, match"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Host route with pattern, wrong host in request URL"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Host route with multiple patterns, match"",
-			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Host route with multiple patterns, wrong host in request URL"",
-			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Host route with hyphenated name and pattern, match"",
-			route:       new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v-1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Host route with hyphenated name and pattern, additional capturing group, match"",
-			route:       new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v-1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Host route with multiple hyphenated names and patterns, match"",
-			route:       new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with single pattern with pipe, match"",
-			route:       new(Route).Path(""/{category:a|b/c}""),
-			request:     newRequest(""GET"", ""http://localhost/a""),
-			vars:        map[string]string{""category"": ""a""},
-			host:        """",
-			path:        ""/a"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with single pattern with pipe, match"",
-			route:       new(Route).Path(""/{category:a|b/c}""),
-			request:     newRequest(""GET"", ""http://localhost/b/c""),
-			vars:        map[string]string{""category"": ""b/c""},
-			host:        """",
-			path:        ""/b/c"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with multiple patterns with pipe, match"",
-			route:       new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
-			host:        """",
-			path:        ""/a/product_name/1"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with multiple patterns with pipe, match"",
-			route:       new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
-			vars:        map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
-			host:        """",
-			path:        ""/b/c/product_name/1"",
-			shouldMatch: true,
+			title:         ""Host route with pattern, match"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
+			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Host route with pattern, additional capturing group, match"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
+			host_template: `aaa.{v1:[a-z]{2}(b|c)}.ccc`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Host route with pattern, wrong host in request URL"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
+			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:   false,
+		},
+		{
+			title:         ""Host route with multiple patterns, match"",
+			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
+			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Host route with multiple patterns, wrong host in request URL"",
+			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
+			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
+			shouldMatch:   false,
+		},
+		{
+			title:         ""Host route with hyphenated name and pattern, match"",
+			route:         new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v-1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
+			host_template: `aaa.{v-1:[a-z]{3}}.ccc`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Host route with hyphenated name and pattern, additional capturing group, match"",
+			route:         new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v-1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
+			host_template: `aaa.{v-1:[a-z]{2}(b|c)}.ccc`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Host route with multiple hyphenated names and patterns, match"",
+			route:         new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
+			host_template: `{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with single pattern with pipe, match"",
+			route:         new(Route).Path(""/{category:a|b/c}""),
+			request:       newRequest(""GET"", ""http://localhost/a""),
+			vars:          map[string]string{""category"": ""a""},
+			host:          """",
+			path:          ""/a"",
+			path_template: `/{category:a|b/c}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with single pattern with pipe, match"",
+			route:         new(Route).Path(""/{category:a|b/c}""),
+			request:       newRequest(""GET"", ""http://localhost/b/c""),
+			vars:          map[string]string{""category"": ""b/c""},
+			host:          """",
+			path:          ""/b/c"",
+			path_template: `/{category:a|b/c}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with multiple patterns with pipe, match"",
+			route:         new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:          map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:          """",
+			path:          ""/a/product_name/1"",
+			path_template: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with multiple patterns with pipe, match"",
+			route:         new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:       newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
+			vars:          map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
+			host:          """",
+			path:          ""/b/c/product_name/1"",
+			path_template: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
+			shouldMatch:   true,
 		},
 	}
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -247,22 +262,24 @@ func TestPath(t *testing.T) {
 			shouldMatch: true,
 		},
 		{
-			title:       ""Path route, do not match with trailing slash in path"",
-			route:       new(Route).Path(""/111/""),
-			request:     newRequest(""GET"", ""http://localhost/111""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        ""/111"",
-			shouldMatch: false,
+			title:         ""Path route, do not match with trailing slash in path"",
+			route:         new(Route).Path(""/111/""),
+			request:       newRequest(""GET"", ""http://localhost/111""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          ""/111"",
+			path_template: `/111/`,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""Path route, do not match with trailing slash in request"",
-			route:       new(Route).Path(""/111""),
-			request:     newRequest(""GET"", ""http://localhost/111/""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        ""/111/"",
-			shouldMatch: false,
+			title:         ""Path route, do not match with trailing slash in request"",
+			route:         new(Route).Path(""/111""),
+			request:       newRequest(""GET"", ""http://localhost/111/""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          ""/111/"",
+			path_template: `/111`,
+			shouldMatch:   false,
 		},
 		{
 			title:       ""Path route, wrong path in request in request URL"",
@@ -274,81 +291,90 @@ func TestPath(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:       ""Path route with pattern, match"",
-			route:       new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v1"": ""222""},
-			host:        """",
-			path:        ""/111/222/333"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with pattern, URL in request does not match"",
-			route:       new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:        map[string]string{""v1"": ""222""},
-			host:        """",
-			path:        ""/111/222/333"",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Path route with multiple patterns, match"",
-			route:       new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:        """",
-			path:        ""/111/222/333"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with multiple patterns, URL in request does not match"",
-			route:       new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:        """",
-			path:        ""/111/222/333"",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Path route with multiple patterns with pipe, match"",
-			route:       new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
-			host:        """",
-			path:        ""/a/product_name/1"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with hyphenated name and pattern, match"",
-			route:       new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v-1"": ""222""},
-			host:        """",
-			path:        ""/111/222/333"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with multiple hyphenated names and patterns, match"",
-			route:       new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
-			host:        """",
-			path:        ""/111/222/333"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Path route with multiple hyphenated names and patterns with pipe, match"",
-			route:       new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:        map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
-			host:        """",
-			path:        ""/a/product_name/1"",
-			shouldMatch: true,
+			title:         ""Path route with pattern, match"",
+			route:         new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v1"": ""222""},
+			host:          """",
+			path:          ""/111/222/333"",
+			path_template: `/111/{v1:[0-9]{3}}/333`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with pattern, URL in request does not match"",
+			route:         new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:          map[string]string{""v1"": ""222""},
+			host:          """",
+			path:          ""/111/222/333"",
+			path_template: `/111/{v1:[0-9]{3}}/333`,
+			shouldMatch:   false,
+		},
+		{
+			title:         ""Path route with multiple patterns, match"",
+			route:         new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:          """",
+			path:          ""/111/222/333"",
+			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with multiple patterns, URL in request does not match"",
+			route:         new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:          """",
+			path:          ""/111/222/333"",
+			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
+			shouldMatch:   false,
+		},
+		{
+			title:         ""Path route with multiple patterns with pipe, match"",
+			route:         new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
+			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:          map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:          """",
+			path:          ""/a/product_name/1"",
+			path_template: `/{category:a|(b/c)}/{product}/{id:[0-9]+}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with hyphenated name and pattern, match"",
+			route:         new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v-1"": ""222""},
+			host:          """",
+			path:          ""/111/222/333"",
+			path_template: `/111/{v-1:[0-9]{3}}/333`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with multiple hyphenated names and patterns, match"",
+			route:         new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
+			host:          """",
+			path:          ""/111/222/333"",
+			path_template: `/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Path route with multiple hyphenated names and patterns with pipe, match"",
+			route:         new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
+			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:          map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
+			host:          """",
+			path:          ""/a/product_name/1"",
+			path_template: `/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}`,
+			shouldMatch:   true,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -382,108 +408,126 @@ func TestPathPrefix(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:       ""PathPrefix route with pattern, match"",
-			route:       new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v1"": ""222""},
-			host:        """",
-			path:        ""/111/222"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""PathPrefix route with pattern, URL prefix in request does not match"",
-			route:       new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:        map[string]string{""v1"": ""222""},
-			host:        """",
-			path:        ""/111/222"",
-			shouldMatch: false,
-		},
-		{
-			title:       ""PathPrefix route with multiple patterns, match"",
-			route:       new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:        """",
-			path:        ""/111/222"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
-			route:       new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:        """",
-			path:        ""/111/222"",
-			shouldMatch: false,
+			title:         ""PathPrefix route with pattern, match"",
+			route:         new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v1"": ""222""},
+			host:          """",
+			path:          ""/111/222"",
+			path_template: `/111/{v1:[0-9]{3}}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""PathPrefix route with pattern, URL prefix in request does not match"",
+			route:         new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:          map[string]string{""v1"": ""222""},
+			host:          """",
+			path:          ""/111/222"",
+			path_template: `/111/{v1:[0-9]{3}}`,
+			shouldMatch:   false,
+		},
+		{
+			title:         ""PathPrefix route with multiple patterns, match"",
+			route:         new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:          """",
+			path:          ""/111/222"",
+			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
+			route:         new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:          """",
+			path:          ""/111/222"",
+			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
+			shouldMatch:   false,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
 func TestHostPath(t *testing.T) {
 	tests := []routeTest{
 		{
-			title:       ""Host and Path route, match"",
-			route:       new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Host and Path route, wrong host in request URL"",
-			route:       new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Host and Path route with pattern, match"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:        ""aaa.bbb.ccc"",
-			path:        ""/111/222/333"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Host and Path route with pattern, URL in request does not match"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:        ""aaa.bbb.ccc"",
-			path:        ""/111/222/333"",
-			shouldMatch: false,
-		},
-		{
-			title:       ""Host and Path route with multiple patterns, match"",
-			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:        ""aaa.bbb.ccc"",
-			path:        ""/111/222/333"",
-			shouldMatch: true,
-		},
-		{
-			title:       ""Host and Path route with multiple patterns, URL in request does not match"",
-			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:        ""aaa.bbb.ccc"",
-			path:        ""/111/222/333"",
-			shouldMatch: false,
+			title:         ""Host and Path route, match"",
+			route:         new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          """",
+			path_template: `/111/222/333`,
+			host_template: `aaa.bbb.ccc`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Host and Path route, wrong host in request URL"",
+			route:         new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          """",
+			path_template: `/111/222/333`,
+			host_template: `aaa.bbb.ccc`,
+			shouldMatch:   false,
+		},
+		{
+			title:         ""Host and Path route with pattern, match"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:          ""aaa.bbb.ccc"",
+			path:          ""/111/222/333"",
+			path_template: `/111/{v2:[0-9]{3}}/333`,
+			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Host and Path route with pattern, URL in request does not match"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:          ""aaa.bbb.ccc"",
+			path:          ""/111/222/333"",
+			path_template: `/111/{v2:[0-9]{3}}/333`,
+			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
+			shouldMatch:   false,
+		},
+		{
+			title:         ""Host and Path route with multiple patterns, match"",
+			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:          ""aaa.bbb.ccc"",
+			path:          ""/111/222/333"",
+			path_template: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
+			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
+			shouldMatch:   true,
+		},
+		{
+			title:         ""Host and Path route with multiple patterns, URL in request does not match"",
+			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:          ""aaa.bbb.ccc"",
+			path:          ""/111/222/333"",
+			path_template: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
+			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
+			shouldMatch:   false,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -541,6 +585,7 @@ func TestHeaders(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 
 }
@@ -578,6 +623,7 @@ func TestMethods(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -593,22 +639,26 @@ func TestQueries(t *testing.T) {
 			shouldMatch: true,
 		},
 		{
-			title:       ""Queries route, match with a query string"",
-			route:       new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:     newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: true,
+			title:         ""Queries route, match with a query string"",
+			route:         new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:       newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          """",
+			path_template: `/api`,
+			host_template: `www.example.com`,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Queries route, match with a query string out of order"",
-			route:       new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:     newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
-			shouldMatch: true,
+			title:         ""Queries route, match with a query string out of order"",
+			route:         new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:       newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          """",
+			path_template: `/api`,
+			host_template: `www.example.com`,
+			shouldMatch:   true,
 		},
 		{
 			title:       ""Queries route, bad query"",
@@ -803,6 +853,7 @@ func TestQueries(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -839,6 +890,7 @@ func TestSchemes(t *testing.T) {
 	}
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -873,6 +925,7 @@ func TestMatcherFunc(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -885,9 +938,10 @@ func TestBuildVarsFunc(t *testing.T) {
 				vars[""v2""] = ""a""
 				return vars
 			}),
-			request:     newRequest(""GET"", ""http://localhost/111/2""),
-			path:        ""/111/3a"",
-			shouldMatch: true,
+			request:       newRequest(""GET"", ""http://localhost/111/2""),
+			path:          ""/111/3a"",
+			path_template: `/111/{v1:\d}{v2:.*}`,
+			shouldMatch:   true,
 		},
 		{
 			title: ""BuildVarsFunc set on route and parent route"",
@@ -898,14 +952,16 @@ func TestBuildVarsFunc(t *testing.T) {
 				vars[""v2""] = ""b""
 				return vars
 			}),
-			request:     newRequest(""GET"", ""http://localhost/1/a""),
-			path:        ""/2/b"",
-			shouldMatch: true,
+			request:       newRequest(""GET"", ""http://localhost/1/a""),
+			path:          ""/2/b"",
+			path_template: `/{v1:\d}/{v2:\w}`,
+			shouldMatch:   true,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -915,41 +971,48 @@ func TestSubRouter(t *testing.T) {
 
 	tests := []routeTest{
 		{
-			route:       subrouter1.Path(""/{v2:[a-z]+}""),
-			request:     newRequest(""GET"", ""http://aaa.google.com/bbb""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
-			host:        ""aaa.google.com"",
-			path:        ""/bbb"",
-			shouldMatch: true,
-		},
-		{
-			route:       subrouter1.Path(""/{v2:[a-z]+}""),
-			request:     newRequest(""GET"", ""http://111.google.com/111""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
-			host:        ""aaa.google.com"",
-			path:        ""/bbb"",
-			shouldMatch: false,
-		},
-		{
-			route:       subrouter2.Path(""/baz/{v2}""),
-			request:     newRequest(""GET"", ""http://localhost/foo/bar/baz/ding""),
-			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
-			host:        """",
-			path:        ""/foo/bar/baz/ding"",
-			shouldMatch: true,
-		},
-		{
-			route:       subrouter2.Path(""/baz/{v2}""),
-			request:     newRequest(""GET"", ""http://localhost/foo/bar""),
-			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
-			host:        """",
-			path:        ""/foo/bar/baz/ding"",
-			shouldMatch: false,
+			route:         subrouter1.Path(""/{v2:[a-z]+}""),
+			request:       newRequest(""GET"", ""http://aaa.google.com/bbb""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:          ""aaa.google.com"",
+			path:          ""/bbb"",
+			path_template: `/{v2:[a-z]+}`,
+			host_template: `{v1:[a-z]+}.google.com`,
+			shouldMatch:   true,
+		},
+		{
+			route:         subrouter1.Path(""/{v2:[a-z]+}""),
+			request:       newRequest(""GET"", ""http://111.google.com/111""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:          ""aaa.google.com"",
+			path:          ""/bbb"",
+			path_template: `/{v2:[a-z]+}`,
+			host_template: `{v1:[a-z]+}.google.com`,
+			shouldMatch:   false,
+		},
+		{
+			route:         subrouter2.Path(""/baz/{v2}""),
+			request:       newRequest(""GET"", ""http://localhost/foo/bar/baz/ding""),
+			vars:          map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:          """",
+			path:          ""/foo/bar/baz/ding"",
+			path_template: `/foo/{v1}/baz/{v2}`,
+			shouldMatch:   true,
+		},
+		{
+			route:         subrouter2.Path(""/baz/{v2}""),
+			request:       newRequest(""GET"", ""http://localhost/foo/bar""),
+			vars:          map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:          """",
+			path:          ""/foo/bar/baz/ding"",
+			path_template: `/foo/{v1}/baz/{v2}`,
+			shouldMatch:   false,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -1045,6 +1108,7 @@ func TestStrictSlash(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -1152,14 +1216,13 @@ func TestSubrouterErrorHandling(t *testing.T) {
 // ----------------------------------------------------------------------------
 
 func getRouteTemplate(route *Route) string {
-	host, path := ""none"", ""none""
-	if route.regexp != nil {
-		if route.regexp.host != nil {
-			host = route.regexp.host.template
-		}
-		if route.regexp.path != nil {
-			path = route.regexp.path.template
-		}
+	host, err := route.GetHostTemplate()
+	if err != nil {
+		host = ""none""
+	}
+	path, err := route.GetPathTemplate()
+	if err != nil {
+		path = ""none""
 	}
 	return fmt.Sprintf(""Host: %v, Path: %v"", host, path)
 }
@@ -1221,6 +1284,28 @@ func testRoute(t *testing.T, test routeTest) {
 	}
 }
 
+func testTemplate(t *testing.T, test routeTest) {
+	route := test.route
+	path_template := test.path_template
+	if len(path_template) == 0 {
+		path_template = test.path
+	}
+	host_template := test.host_template
+	if len(host_template) == 0 {
+		host_template = test.host
+	}
+
+	path_tmpl, path_err := route.GetPathTemplate()
+	if path_err == nil && path_tmpl != path_template {
+		t.Errorf(""(%v) GetPathTemplate not equal: expected %v, got %v"", test.title, path_template, path_tmpl)
+	}
+
+	host_tmpl, host_err := route.GetHostTemplate()
+	if host_err == nil && host_tmpl != host_template {
+		t.Errorf(""(%v) GetHostTemplate not equal: expected %v, got %v"", test.title, host_template, host_tmpl)
+	}
+}
+
 // Tests that the context is cleared or not cleared properly depending on
 // the configuration of the router
 func TestKeepContext(t *testing.T) {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=147a95f5e36a65f1c7b29440b9b0283aab154693,https://github.com/gorilla/mux/blob/147a95f5e36a65f1c7b29440b9b0283aab154693/mux_test.go
147a95f5e36a65f1c7b29440b9b0283aab154693,bf92af261052687076771844140beecdbdfd913a,route.go,,"Sat, 05 Mar 2016 13:56:38 GMT",modified,30,0,30,"@@ -534,6 +534,36 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	}, nil
 }
 
+// GetPathTemplate returns the template used to build the
+// route match.
+// This is useful for building simple REST API documentation and for instrumentation
+// against third-party services.
+// An error will be returned if the route does not define a path.
+func (r *Route) GetPathTemplate() (string, error) {
+	if r.err != nil {
+		return """", r.err
+	}
+	if r.regexp == nil || r.regexp.path == nil {
+		return """", errors.New(""mux: route doesn't have a path"")
+	}
+	return r.regexp.path.template, nil
+}
+
+// GetHostTemplate returns the template used to build the
+// route match.
+// This is useful for building simple REST API documentation and for instrumentation
+// against third-party services.
+// An error will be returned if the route does not define a host.
+func (r *Route) GetHostTemplate() (string, error) {
+	if r.err != nil {
+		return """", r.err
+	}
+	if r.regexp == nil || r.regexp.host == nil {
+		return """", errors.New(""mux: route doesn't have a host"")
+	}
+	return r.regexp.host.template, nil
+}
+
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=147a95f5e36a65f1c7b29440b9b0283aab154693,https://github.com/gorilla/mux/blob/147a95f5e36a65f1c7b29440b9b0283aab154693/route.go
f7ac7251e3b615c63207d481413aab0726812499,6e633893e7b9e3b7bdcb5c592da07c8317d2e800,route.go,,"Mon, 29 Feb 2016 15:54:15 GMT",modified,10,4,14,"@@ -532,10 +532,11 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	}, nil
 }
 
-// GetPathTemplate and GetHostTemplate returns the template used to match against for the route
-// This is userful for building simple REST API documentation,
-// and instrumentation for services like New Relic to ensure consistent reporting
-// The route must have a path defined.
+// GetPathTemplate returns the template used to build the
+// route match.
+// This is useful for building simple REST API documentation and for instrumentation
+// against third-party services.
+// An error will be returned if the route does not define a path.
 func (r *Route) GetPathTemplate() (string, error) {
 	if r.err != nil {
 		return """", r.err
@@ -546,6 +547,11 @@ func (r *Route) GetPathTemplate() (string, error) {
 	return r.regexp.path.template, nil
 }
 
+// GetHostTemplate returns the template used to build the
+// route match.
+// This is useful for building simple REST API documentation and for instrumentation
+// against third-party services.
+// An error will be returned if the route does not define a host.
 func (r *Route) GetHostTemplate() (string, error) {
 	if r.err != nil {
 		return """", r.err",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=f7ac7251e3b615c63207d481413aab0726812499,https://github.com/gorilla/mux/blob/f7ac7251e3b615c63207d481413aab0726812499/route.go
c9e326e2bdec29039a3761c07bece13133863e1e,835f5342eb97d45bac7b8aa489d56302280f82bc,doc.go,,"Mon, 29 Feb 2016 03:40:56 GMT",modified,1,1,2,"@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 /*
-Package gorilla/mux implements a request router and dispatcher.
+Package mux implements a request router and dispatcher.
 
 The name mux stands for ""HTTP request multiplexer"". Like the standard
 http.ServeMux, mux.Router matches incoming requests against a list of",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=c9e326e2bdec29039a3761c07bece13133863e1e,https://github.com/gorilla/mux/blob/c9e326e2bdec29039a3761c07bece13133863e1e/doc.go
c9e326e2bdec29039a3761c07bece13133863e1e,fbb7f19adfc1e6ebe390fbba702ada84805f7105,mux.go,,"Mon, 29 Feb 2016 03:40:56 GMT",modified,1,1,2,"@@ -236,7 +236,7 @@ func (r *Router) Schemes(schemes ...string) *Route {
 	return r.NewRoute().Schemes(schemes...)
 }
 
-// BuildVars registers a new route with a custom function for modifying
+// BuildVarsFunc registers a new route with a custom function for modifying
 // route variables before building a URL.
 func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
 	return r.NewRoute().BuildVarsFunc(f)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=c9e326e2bdec29039a3761c07bece13133863e1e,https://github.com/gorilla/mux/blob/c9e326e2bdec29039a3761c07bece13133863e1e/mux.go
c9e326e2bdec29039a3761c07bece13133863e1e,25ccd49212257ae14dfc61fa7e695deab0bcf3b2,old_test.go,,"Mon, 29 Feb 2016 03:40:56 GMT",modified,3,3,6,"@@ -576,10 +576,10 @@ func TestSubRouting(t *testing.T) {
 	}
 
 	u, _ := router.Get(""products"").URL()
-	builtUrl := u.String()
+	builtURL := u.String()
 	// Yay, subroute aware of the domain when building!
-	if builtUrl != url {
-		t.Errorf(""Expected %q, got %q."", url, builtUrl)
+	if builtURL != url {
+		t.Errorf(""Expected %q, got %q."", url, builtURL)
 	}
 }
 ",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=c9e326e2bdec29039a3761c07bece13133863e1e,https://github.com/gorilla/mux/blob/c9e326e2bdec29039a3761c07bece13133863e1e/old_test.go
c9e326e2bdec29039a3761c07bece13133863e1e,16d5338c8b48e4099366e768dbcf913034e70674,regexp.go,,"Mon, 29 Feb 2016 03:40:56 GMT",modified,10,9,19,"@@ -151,10 +151,11 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 	if !r.matchHost {
 		if r.matchQuery {
 			return r.matchQueryString(req)
-		} else {
-			return r.regexp.MatchString(req.URL.Path)
 		}
+
+		return r.regexp.MatchString(req.URL.Path)
 	}
+
 	return r.regexp.MatchString(getHost(req))
 }
 
@@ -184,10 +185,10 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 	return rv, nil
 }
 
-// getUrlQuery returns a single query parameter from a request URL.
+// getURLQuery returns a single query parameter from a request URL.
 // For a URL with foo=bar&baz=ding, we return only the relevant key
 // value pair for the routeRegexp.
-func (r *routeRegexp) getUrlQuery(req *http.Request) string {
+func (r *routeRegexp) getURLQuery(req *http.Request) string {
 	if !r.matchQuery {
 		return """"
 	}
@@ -201,14 +202,14 @@ func (r *routeRegexp) getUrlQuery(req *http.Request) string {
 }
 
 func (r *routeRegexp) matchQueryString(req *http.Request) bool {
-	return r.regexp.MatchString(r.getUrlQuery(req))
+	return r.regexp.MatchString(r.getURLQuery(req))
 }
 
 // braceIndices returns the first level curly brace indices from a string.
 // It returns an error in case of unbalanced braces.
 func braceIndices(s string) ([]int, error) {
 	var level, idx int
-	idxs := make([]int, 0)
+	var idxs []int
 	for i := 0; i < len(s); i++ {
 		switch s[i] {
 		case '{':
@@ -278,10 +279,10 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	}
 	// Store query string variables.
 	for _, q := range v.queries {
-		queryUrl := q.getUrlQuery(req)
-		matches := q.regexp.FindStringSubmatchIndex(queryUrl)
+		queryURL := q.getURLQuery(req)
+		matches := q.regexp.FindStringSubmatchIndex(queryURL)
 		if len(matches) > 0 {
-			extractVars(queryUrl, matches, q.varsN, m.Vars)
+			extractVars(queryURL, matches, q.varsN, m.Vars)
 		}
 	}
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=c9e326e2bdec29039a3761c07bece13133863e1e,https://github.com/gorilla/mux/blob/c9e326e2bdec29039a3761c07bece13133863e1e/regexp.go
c9e326e2bdec29039a3761c07bece13133863e1e,224949d7272ce4fe7dd6aba7e012ae24dd79721d,route.go,,"Mon, 29 Feb 2016 03:40:56 GMT",modified,4,2,6,"@@ -217,8 +217,9 @@ func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
 	return matchMapWithRegex(m, r.Header, true)
 }
 
-// Regular expressions can be used with headers as well.
-// It accepts a sequence of key/value pairs, where the value has regex support. For example
+// HeadersRegexp accepts a sequence of key/value pairs, where the value has regex
+// support. For example:
+//
 //     r := mux.NewRouter()
 //     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
 //               ""X-Requested-With"", ""XMLHttpRequest"")
@@ -263,6 +264,7 @@ func (r *Route) Host(tpl string) *Route {
 // MatcherFunc is the function signature used by custom matchers.
 type MatcherFunc func(*http.Request, *RouteMatch) bool
 
+// Match returns the match for a given request.
 func (m MatcherFunc) Match(r *http.Request, match *RouteMatch) bool {
 	return m(r, match)
 }",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=c9e326e2bdec29039a3761c07bece13133863e1e,https://github.com/gorilla/mux/blob/c9e326e2bdec29039a3761c07bece13133863e1e/route.go
02c98b3f736c94c45d11bef7b60023f752c2d21d,835f5342eb97d45bac7b8aa489d56302280f82bc,doc.go,,"Mon, 29 Feb 2016 03:32:22 GMT",modified,1,1,2,"@@ -3,7 +3,7 @@
 // license that can be found in the LICENSE file.
 
 /*
-Package gorilla/mux implements a request router and dispatcher.
+Package mux implements a request router and dispatcher.
 
 The name mux stands for ""HTTP request multiplexer"". Like the standard
 http.ServeMux, mux.Router matches incoming requests against a list of",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=02c98b3f736c94c45d11bef7b60023f752c2d21d,https://github.com/gorilla/mux/blob/02c98b3f736c94c45d11bef7b60023f752c2d21d/doc.go
02c98b3f736c94c45d11bef7b60023f752c2d21d,fbb7f19adfc1e6ebe390fbba702ada84805f7105,mux.go,,"Mon, 29 Feb 2016 03:32:22 GMT",modified,1,1,2,"@@ -236,7 +236,7 @@ func (r *Router) Schemes(schemes ...string) *Route {
 	return r.NewRoute().Schemes(schemes...)
 }
 
-// BuildVars registers a new route with a custom function for modifying
+// BuildVarsFunc registers a new route with a custom function for modifying
 // route variables before building a URL.
 func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
 	return r.NewRoute().BuildVarsFunc(f)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=02c98b3f736c94c45d11bef7b60023f752c2d21d,https://github.com/gorilla/mux/blob/02c98b3f736c94c45d11bef7b60023f752c2d21d/mux.go
02c98b3f736c94c45d11bef7b60023f752c2d21d,25ccd49212257ae14dfc61fa7e695deab0bcf3b2,old_test.go,,"Mon, 29 Feb 2016 03:32:22 GMT",modified,3,3,6,"@@ -576,10 +576,10 @@ func TestSubRouting(t *testing.T) {
 	}
 
 	u, _ := router.Get(""products"").URL()
-	builtUrl := u.String()
+	builtURL := u.String()
 	// Yay, subroute aware of the domain when building!
-	if builtUrl != url {
-		t.Errorf(""Expected %q, got %q."", url, builtUrl)
+	if builtURL != url {
+		t.Errorf(""Expected %q, got %q."", url, builtURL)
 	}
 }
 ",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=02c98b3f736c94c45d11bef7b60023f752c2d21d,https://github.com/gorilla/mux/blob/02c98b3f736c94c45d11bef7b60023f752c2d21d/old_test.go
02c98b3f736c94c45d11bef7b60023f752c2d21d,16d5338c8b48e4099366e768dbcf913034e70674,regexp.go,,"Mon, 29 Feb 2016 03:32:22 GMT",modified,10,9,19,"@@ -151,10 +151,11 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 	if !r.matchHost {
 		if r.matchQuery {
 			return r.matchQueryString(req)
-		} else {
-			return r.regexp.MatchString(req.URL.Path)
 		}
+
+		return r.regexp.MatchString(req.URL.Path)
 	}
+
 	return r.regexp.MatchString(getHost(req))
 }
 
@@ -184,10 +185,10 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 	return rv, nil
 }
 
-// getUrlQuery returns a single query parameter from a request URL.
+// getURLQuery returns a single query parameter from a request URL.
 // For a URL with foo=bar&baz=ding, we return only the relevant key
 // value pair for the routeRegexp.
-func (r *routeRegexp) getUrlQuery(req *http.Request) string {
+func (r *routeRegexp) getURLQuery(req *http.Request) string {
 	if !r.matchQuery {
 		return """"
 	}
@@ -201,14 +202,14 @@ func (r *routeRegexp) getUrlQuery(req *http.Request) string {
 }
 
 func (r *routeRegexp) matchQueryString(req *http.Request) bool {
-	return r.regexp.MatchString(r.getUrlQuery(req))
+	return r.regexp.MatchString(r.getURLQuery(req))
 }
 
 // braceIndices returns the first level curly brace indices from a string.
 // It returns an error in case of unbalanced braces.
 func braceIndices(s string) ([]int, error) {
 	var level, idx int
-	idxs := make([]int, 0)
+	var idxs []int
 	for i := 0; i < len(s); i++ {
 		switch s[i] {
 		case '{':
@@ -278,10 +279,10 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	}
 	// Store query string variables.
 	for _, q := range v.queries {
-		queryUrl := q.getUrlQuery(req)
-		matches := q.regexp.FindStringSubmatchIndex(queryUrl)
+		queryURL := q.getURLQuery(req)
+		matches := q.regexp.FindStringSubmatchIndex(queryURL)
 		if len(matches) > 0 {
-			extractVars(queryUrl, matches, q.varsN, m.Vars)
+			extractVars(queryURL, matches, q.varsN, m.Vars)
 		}
 	}
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=02c98b3f736c94c45d11bef7b60023f752c2d21d,https://github.com/gorilla/mux/blob/02c98b3f736c94c45d11bef7b60023f752c2d21d/regexp.go
02c98b3f736c94c45d11bef7b60023f752c2d21d,224949d7272ce4fe7dd6aba7e012ae24dd79721d,route.go,,"Mon, 29 Feb 2016 03:32:22 GMT",modified,4,2,6,"@@ -217,8 +217,9 @@ func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
 	return matchMapWithRegex(m, r.Header, true)
 }
 
-// Regular expressions can be used with headers as well.
-// It accepts a sequence of key/value pairs, where the value has regex support. For example
+// HeadersRegexp accepts a sequence of key/value pairs, where the value has regex
+// support. For example:
+//
 //     r := mux.NewRouter()
 //     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
 //               ""X-Requested-With"", ""XMLHttpRequest"")
@@ -263,6 +264,7 @@ func (r *Route) Host(tpl string) *Route {
 // MatcherFunc is the function signature used by custom matchers.
 type MatcherFunc func(*http.Request, *RouteMatch) bool
 
+// Match returns the match for a given request.
 func (m MatcherFunc) Match(r *http.Request, match *RouteMatch) bool {
 	return m(r, match)
 }",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=02c98b3f736c94c45d11bef7b60023f752c2d21d,https://github.com/gorilla/mux/blob/02c98b3f736c94c45d11bef7b60023f752c2d21d/route.go
f84ab9ab620f5ac2d587d5688b7b0820b5bdf9bf,8912d09511a71562870756a1c91fe61b1d1e7223,mux_test.go,,"Sun, 28 Feb 2016 22:46:18 GMT",modified,272,273,545,"@@ -32,8 +32,8 @@ type routeTest struct {
 	vars           map[string]string // the expected vars of the match
 	host           string            // the expected host of the match
 	path           string            // the expected path of the match
-	path_template  string 			 // the expected path template to match
-	host_template  string 			 // the expected host template to match
+	path_template  string            // the expected path template to match
+	host_template  string            // the expected host template to match
 	shouldMatch    bool              // whether the request is expected to match the route at all
 	shouldRedirect bool              // whether the request should result in a redirect
 }
@@ -115,124 +115,124 @@ func TestHost(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:       ""Host route with pattern, match"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
+			title:         ""Host route with pattern, match"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
 			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Host route with pattern, additional capturing group, match"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
+			title:         ""Host route with pattern, additional capturing group, match"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
 			host_template: `aaa.{v1:[a-z]{2}(b|c)}.ccc`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Host route with pattern, wrong host in request URL"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
+			title:         ""Host route with pattern, wrong host in request URL"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
 			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""Host route with multiple patterns, match"",
-			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
+			title:         ""Host route with multiple patterns, match"",
+			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
 			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Host route with multiple patterns, wrong host in request URL"",
-			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
+			title:         ""Host route with multiple patterns, wrong host in request URL"",
+			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
 			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""Host route with hyphenated name and pattern, match"",
-			route:       new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v-1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
+			title:         ""Host route with hyphenated name and pattern, match"",
+			route:         new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v-1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
 			host_template: `aaa.{v-1:[a-z]{3}}.ccc`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Host route with hyphenated name and pattern, additional capturing group, match"",
-			route:       new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v-1"": ""bbb""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
+			title:         ""Host route with hyphenated name and pattern, additional capturing group, match"",
+			route:         new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v-1"": ""bbb""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
 			host_template: `aaa.{v-1:[a-z]{2}(b|c)}.ccc`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Host route with multiple hyphenated names and patterns, match"",
-			route:       new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
-			host:        ""aaa.bbb.ccc"",
-			path:        """",
+			title:         ""Host route with multiple hyphenated names and patterns, match"",
+			route:         new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
+			host:          ""aaa.bbb.ccc"",
+			path:          """",
 			host_template: `{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with single pattern with pipe, match"",
-			route:       new(Route).Path(""/{category:a|b/c}""),
-			request:     newRequest(""GET"", ""http://localhost/a""),
-			vars:        map[string]string{""category"": ""a""},
-			host:        """",
-			path:        ""/a"",
+			title:         ""Path route with single pattern with pipe, match"",
+			route:         new(Route).Path(""/{category:a|b/c}""),
+			request:       newRequest(""GET"", ""http://localhost/a""),
+			vars:          map[string]string{""category"": ""a""},
+			host:          """",
+			path:          ""/a"",
 			path_template: `/{category:a|b/c}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with single pattern with pipe, match"",
-			route:       new(Route).Path(""/{category:a|b/c}""),
-			request:     newRequest(""GET"", ""http://localhost/b/c""),
-			vars:        map[string]string{""category"": ""b/c""},
-			host:        """",
-			path:        ""/b/c"",
+			title:         ""Path route with single pattern with pipe, match"",
+			route:         new(Route).Path(""/{category:a|b/c}""),
+			request:       newRequest(""GET"", ""http://localhost/b/c""),
+			vars:          map[string]string{""category"": ""b/c""},
+			host:          """",
+			path:          ""/b/c"",
 			path_template: `/{category:a|b/c}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with multiple patterns with pipe, match"",
-			route:       new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
-			host:        """",
-			path:        ""/a/product_name/1"",
+			title:         ""Path route with multiple patterns with pipe, match"",
+			route:         new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:          map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:          """",
+			path:          ""/a/product_name/1"",
 			path_template: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with multiple patterns with pipe, match"",
-			route:       new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
-			vars:        map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
-			host:        """",
-			path:        ""/b/c/product_name/1"",
+			title:         ""Path route with multiple patterns with pipe, match"",
+			route:         new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:       newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
+			vars:          map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
+			host:          """",
+			path:          ""/b/c/product_name/1"",
 			path_template: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 	}
 	for _, test := range tests {
@@ -262,24 +262,24 @@ func TestPath(t *testing.T) {
 			shouldMatch: true,
 		},
 		{
-			title:       ""Path route, do not match with trailing slash in path"",
-			route:       new(Route).Path(""/111/""),
-			request:     newRequest(""GET"", ""http://localhost/111""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        ""/111"",
+			title:         ""Path route, do not match with trailing slash in path"",
+			route:         new(Route).Path(""/111/""),
+			request:       newRequest(""GET"", ""http://localhost/111""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          ""/111"",
 			path_template: `/111/`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""Path route, do not match with trailing slash in request"",
-			route:       new(Route).Path(""/111""),
-			request:     newRequest(""GET"", ""http://localhost/111/""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        ""/111/"",
+			title:         ""Path route, do not match with trailing slash in request"",
+			route:         new(Route).Path(""/111""),
+			request:       newRequest(""GET"", ""http://localhost/111/""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          ""/111/"",
 			path_template: `/111`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
 			title:       ""Path route, wrong path in request in request URL"",
@@ -291,84 +291,84 @@ func TestPath(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:       ""Path route with pattern, match"",
-			route:       new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v1"": ""222""},
-			host:        """",
-			path:        ""/111/222/333"",
+			title:         ""Path route with pattern, match"",
+			route:         new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v1"": ""222""},
+			host:          """",
+			path:          ""/111/222/333"",
 			path_template: `/111/{v1:[0-9]{3}}/333`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with pattern, URL in request does not match"",
-			route:       new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:        map[string]string{""v1"": ""222""},
-			host:        """",
-			path:        ""/111/222/333"",
+			title:         ""Path route with pattern, URL in request does not match"",
+			route:         new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:          map[string]string{""v1"": ""222""},
+			host:          """",
+			path:          ""/111/222/333"",
 			path_template: `/111/{v1:[0-9]{3}}/333`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""Path route with multiple patterns, match"",
-			route:       new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:        """",
-			path:        ""/111/222/333"",
+			title:         ""Path route with multiple patterns, match"",
+			route:         new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:          """",
+			path:          ""/111/222/333"",
 			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with multiple patterns, URL in request does not match"",
-			route:       new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:        """",
-			path:        ""/111/222/333"",
+			title:         ""Path route with multiple patterns, URL in request does not match"",
+			route:         new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:          """",
+			path:          ""/111/222/333"",
 			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""Path route with multiple patterns with pipe, match"",
-			route:       new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
-			host:        """",
-			path:        ""/a/product_name/1"",
+			title:         ""Path route with multiple patterns with pipe, match"",
+			route:         new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
+			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:          map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:          """",
+			path:          ""/a/product_name/1"",
 			path_template: `/{category:a|(b/c)}/{product}/{id:[0-9]+}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with hyphenated name and pattern, match"",
-			route:       new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v-1"": ""222""},
-			host:        """",
-			path:        ""/111/222/333"",
+			title:         ""Path route with hyphenated name and pattern, match"",
+			route:         new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v-1"": ""222""},
+			host:          """",
+			path:          ""/111/222/333"",
 			path_template: `/111/{v-1:[0-9]{3}}/333`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with multiple hyphenated names and patterns, match"",
-			route:       new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
-			host:        """",
-			path:        ""/111/222/333"",
+			title:         ""Path route with multiple hyphenated names and patterns, match"",
+			route:         new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
+			host:          """",
+			path:          ""/111/222/333"",
 			path_template: `/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Path route with multiple hyphenated names and patterns with pipe, match"",
-			route:       new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
-			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
-			vars:        map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
-			host:        """",
-			path:        ""/a/product_name/1"",
+			title:         ""Path route with multiple hyphenated names and patterns with pipe, match"",
+			route:         new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
+			request:       newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:          map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
+			host:          """",
+			path:          ""/a/product_name/1"",
 			path_template: `/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 	}
 
@@ -408,44 +408,44 @@ func TestPathPrefix(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:       ""PathPrefix route with pattern, match"",
-			route:       new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v1"": ""222""},
-			host:        """",
-			path:        ""/111/222"",
+			title:         ""PathPrefix route with pattern, match"",
+			route:         new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v1"": ""222""},
+			host:          """",
+			path:          ""/111/222"",
 			path_template: `/111/{v1:[0-9]{3}}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""PathPrefix route with pattern, URL prefix in request does not match"",
-			route:       new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:        map[string]string{""v1"": ""222""},
-			host:        """",
-			path:        ""/111/222"",
+			title:         ""PathPrefix route with pattern, URL prefix in request does not match"",
+			route:         new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:          map[string]string{""v1"": ""222""},
+			host:          """",
+			path:          ""/111/222"",
 			path_template: `/111/{v1:[0-9]{3}}`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""PathPrefix route with multiple patterns, match"",
-			route:       new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:        """",
-			path:        ""/111/222"",
+			title:         ""PathPrefix route with multiple patterns, match"",
+			route:         new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:          """",
+			path:          ""/111/222"",
 			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
-			route:       new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:        """",
-			path:        ""/111/222"",
+			title:         ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
+			route:         new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:          map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:          """",
+			path:          ""/111/222"",
 			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 	}
 
@@ -458,70 +458,70 @@ func TestPathPrefix(t *testing.T) {
 func TestHostPath(t *testing.T) {
 	tests := []routeTest{
 		{
-			title:       ""Host and Path route, match"",
-			route:       new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
+			title:         ""Host and Path route, match"",
+			route:         new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          """",
 			path_template: `/111/222/333`,
 			host_template: `aaa.bbb.ccc`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Host and Path route, wrong host in request URL"",
-			route:       new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
+			title:         ""Host and Path route, wrong host in request URL"",
+			route:         new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          """",
 			path_template: `/111/222/333`,
 			host_template: `aaa.bbb.ccc`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""Host and Path route with pattern, match"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:        ""aaa.bbb.ccc"",
-			path:        ""/111/222/333"",
+			title:         ""Host and Path route with pattern, match"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:          ""aaa.bbb.ccc"",
+			path:          ""/111/222/333"",
 			path_template: `/111/{v2:[0-9]{3}}/333`,
 			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Host and Path route with pattern, URL in request does not match"",
-			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:        ""aaa.bbb.ccc"",
-			path:        ""/111/222/333"",
+			title:         ""Host and Path route with pattern, URL in request does not match"",
+			route:         new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:          ""aaa.bbb.ccc"",
+			path:          ""/111/222/333"",
 			path_template: `/111/{v2:[0-9]{3}}/333`,
 			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			title:       ""Host and Path route with multiple patterns, match"",
-			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:        ""aaa.bbb.ccc"",
-			path:        ""/111/222/333"",
+			title:         ""Host and Path route with multiple patterns, match"",
+			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:          ""aaa.bbb.ccc"",
+			path:          ""/111/222/333"",
 			path_template: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
 			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Host and Path route with multiple patterns, URL in request does not match"",
-			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:        ""aaa.bbb.ccc"",
-			path:        ""/111/222/333"",
+			title:         ""Host and Path route with multiple patterns, URL in request does not match"",
+			route:         new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:       newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:          ""aaa.bbb.ccc"",
+			path:          ""/111/222/333"",
 			path_template: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
 			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 	}
 
@@ -639,26 +639,26 @@ func TestQueries(t *testing.T) {
 			shouldMatch: true,
 		},
 		{
-			title:       ""Queries route, match with a query string"",
-			route:       new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:     newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
+			title:         ""Queries route, match with a query string"",
+			route:         new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:       newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          """",
 			path_template: `/api`,
 			host_template: `www.example.com`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			title:       ""Queries route, match with a query string out of order"",
-			route:       new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:     newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
-			vars:        map[string]string{},
-			host:        """",
-			path:        """",
+			title:         ""Queries route, match with a query string out of order"",
+			route:         new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:       newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
+			vars:          map[string]string{},
+			host:          """",
+			path:          """",
 			path_template: `/api`,
 			host_template: `www.example.com`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
 			title:       ""Queries route, bad query"",
@@ -938,10 +938,10 @@ func TestBuildVarsFunc(t *testing.T) {
 				vars[""v2""] = ""a""
 				return vars
 			}),
-			request:     newRequest(""GET"", ""http://localhost/111/2""),
-			path:        ""/111/3a"",
+			request:       newRequest(""GET"", ""http://localhost/111/2""),
+			path:          ""/111/3a"",
 			path_template: `/111/{v1:\d}{v2:.*}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
 			title: ""BuildVarsFunc set on route and parent route"",
@@ -952,10 +952,10 @@ func TestBuildVarsFunc(t *testing.T) {
 				vars[""v2""] = ""b""
 				return vars
 			}),
-			request:     newRequest(""GET"", ""http://localhost/1/a""),
-			path:        ""/2/b"",
+			request:       newRequest(""GET"", ""http://localhost/1/a""),
+			path:          ""/2/b"",
 			path_template: `/{v1:\d}/{v2:\w}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 	}
 
@@ -971,42 +971,42 @@ func TestSubRouter(t *testing.T) {
 
 	tests := []routeTest{
 		{
-			route:       subrouter1.Path(""/{v2:[a-z]+}""),
-			request:     newRequest(""GET"", ""http://aaa.google.com/bbb""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
-			host:        ""aaa.google.com"",
-			path:        ""/bbb"",
+			route:         subrouter1.Path(""/{v2:[a-z]+}""),
+			request:       newRequest(""GET"", ""http://aaa.google.com/bbb""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:          ""aaa.google.com"",
+			path:          ""/bbb"",
 			path_template: `/{v2:[a-z]+}`,
 			host_template: `{v1:[a-z]+}.google.com`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			route:       subrouter1.Path(""/{v2:[a-z]+}""),
-			request:     newRequest(""GET"", ""http://111.google.com/111""),
-			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
-			host:        ""aaa.google.com"",
-			path:        ""/bbb"",
+			route:         subrouter1.Path(""/{v2:[a-z]+}""),
+			request:       newRequest(""GET"", ""http://111.google.com/111""),
+			vars:          map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:          ""aaa.google.com"",
+			path:          ""/bbb"",
 			path_template: `/{v2:[a-z]+}`,
 			host_template: `{v1:[a-z]+}.google.com`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 		{
-			route:       subrouter2.Path(""/baz/{v2}""),
-			request:     newRequest(""GET"", ""http://localhost/foo/bar/baz/ding""),
-			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
-			host:        """",
-			path:        ""/foo/bar/baz/ding"",
+			route:         subrouter2.Path(""/baz/{v2}""),
+			request:       newRequest(""GET"", ""http://localhost/foo/bar/baz/ding""),
+			vars:          map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:          """",
+			path:          ""/foo/bar/baz/ding"",
 			path_template: `/foo/{v1}/baz/{v2}`,
-			shouldMatch: true,
+			shouldMatch:   true,
 		},
 		{
-			route:       subrouter2.Path(""/baz/{v2}""),
-			request:     newRequest(""GET"", ""http://localhost/foo/bar""),
-			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
-			host:        """",
-			path:        ""/foo/bar/baz/ding"",
+			route:         subrouter2.Path(""/baz/{v2}""),
+			request:       newRequest(""GET"", ""http://localhost/foo/bar""),
+			vars:          map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:          """",
+			path:          ""/foo/bar/baz/ding"",
 			path_template: `/foo/{v1}/baz/{v2}`,
-			shouldMatch: false,
+			shouldMatch:   false,
 		},
 	}
 
@@ -1296,13 +1296,12 @@ func testTemplate(t *testing.T, test routeTest) {
 	}
 
 	path_tmpl, path_err := route.GetPathTemplate()
-	if path_err == nil  && path_tmpl != path_template {
+	if path_err == nil && path_tmpl != path_template {
 		t.Errorf(""(%v) GetPathTemplate not equal: expected %v, got %v"", test.title, path_template, path_tmpl)
 	}
 
-
 	host_tmpl, host_err := route.GetHostTemplate()
-	if host_err == nil  && host_tmpl != host_template {
+	if host_err == nil && host_tmpl != host_template {
 		t.Errorf(""(%v) GetHostTemplate not equal: expected %v, got %v"", test.title, host_template, host_tmpl)
 	}
 }",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=f84ab9ab620f5ac2d587d5688b7b0820b5bdf9bf,https://github.com/gorilla/mux/blob/f84ab9ab620f5ac2d587d5688b7b0820b5bdf9bf/mux_test.go
0d60c4bfebed9448afb78ab65727a497cc2d9f3d,6fe249ae4f9e4551aa660f40d4b5e1afdbb960e0,mux_test.go,,"Sun, 28 Feb 2016 22:42:09 GMT",modified,94,8,102,"@@ -32,6 +32,8 @@ type routeTest struct {
 	vars           map[string]string // the expected vars of the match
 	host           string            // the expected host of the match
 	path           string            // the expected path of the match
+	path_template  string 			 // the expected path template to match
+	host_template  string 			 // the expected host template to match
 	shouldMatch    bool              // whether the request is expected to match the route at all
 	shouldRedirect bool              // whether the request should result in a redirect
 }
@@ -119,6 +121,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bbb""},
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
+			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
 			shouldMatch: true,
 		},
 		{
@@ -128,6 +131,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bbb""},
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
+			host_template: `aaa.{v1:[a-z]{2}(b|c)}.ccc`,
 			shouldMatch: true,
 		},
 		{
@@ -137,6 +141,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bbb""},
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
+			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
 			shouldMatch: false,
 		},
 		{
@@ -146,6 +151,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
+			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
 			shouldMatch: true,
 		},
 		{
@@ -155,6 +161,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
+			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
 			shouldMatch: false,
 		},
 		{
@@ -164,6 +171,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""bbb""},
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
+			host_template: `aaa.{v-1:[a-z]{3}}.ccc`,
 			shouldMatch: true,
 		},
 		{
@@ -173,6 +181,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""bbb""},
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
+			host_template: `aaa.{v-1:[a-z]{2}(b|c)}.ccc`,
 			shouldMatch: true,
 		},
 		{
@@ -182,6 +191,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
+			host_template: `{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}`,
 			shouldMatch: true,
 		},
 		{
@@ -191,6 +201,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""category"": ""a""},
 			host:        """",
 			path:        ""/a"",
+			path_template: `/{category:a|b/c}`,
 			shouldMatch: true,
 		},
 		{
@@ -200,6 +211,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""category"": ""b/c""},
 			host:        """",
 			path:        ""/b/c"",
+			path_template: `/{category:a|b/c}`,
 			shouldMatch: true,
 		},
 		{
@@ -209,6 +221,7 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
 			host:        """",
 			path:        ""/a/product_name/1"",
+			path_template: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
 			shouldMatch: true,
 		},
 		{
@@ -218,11 +231,13 @@ func TestHost(t *testing.T) {
 			vars:        map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
 			host:        """",
 			path:        ""/b/c/product_name/1"",
+			path_template: `/{category:a|b/c}/{product}/{id:[0-9]+}`,
 			shouldMatch: true,
 		},
 	}
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -253,6 +268,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        ""/111"",
+			path_template: `/111/`,
 			shouldMatch: false,
 		},
 		{
@@ -262,6 +278,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        ""/111/"",
+			path_template: `/111`,
 			shouldMatch: false,
 		},
 		{
@@ -280,6 +297,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{""v1"": ""222""},
 			host:        """",
 			path:        ""/111/222/333"",
+			path_template: `/111/{v1:[0-9]{3}}/333`,
 			shouldMatch: true,
 		},
 		{
@@ -289,6 +307,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{""v1"": ""222""},
 			host:        """",
 			path:        ""/111/222/333"",
+			path_template: `/111/{v1:[0-9]{3}}/333`,
 			shouldMatch: false,
 		},
 		{
@@ -298,6 +317,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
 			host:        """",
 			path:        ""/111/222/333"",
+			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
 			shouldMatch: true,
 		},
 		{
@@ -307,6 +327,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
 			host:        """",
 			path:        ""/111/222/333"",
+			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}`,
 			shouldMatch: false,
 		},
 		{
@@ -316,6 +337,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
 			host:        """",
 			path:        ""/a/product_name/1"",
+			path_template: `/{category:a|(b/c)}/{product}/{id:[0-9]+}`,
 			shouldMatch: true,
 		},
 		{
@@ -325,6 +347,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""222""},
 			host:        """",
 			path:        ""/111/222/333"",
+			path_template: `/111/{v-1:[0-9]{3}}/333`,
 			shouldMatch: true,
 		},
 		{
@@ -334,6 +357,7 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
 			host:        """",
 			path:        ""/111/222/333"",
+			path_template: `/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}`,
 			shouldMatch: true,
 		},
 		{
@@ -343,12 +367,14 @@ func TestPath(t *testing.T) {
 			vars:        map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
 			host:        """",
 			path:        ""/a/product_name/1"",
+			path_template: `/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}`,
 			shouldMatch: true,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -388,6 +414,7 @@ func TestPathPrefix(t *testing.T) {
 			vars:        map[string]string{""v1"": ""222""},
 			host:        """",
 			path:        ""/111/222"",
+			path_template: `/111/{v1:[0-9]{3}}`,
 			shouldMatch: true,
 		},
 		{
@@ -397,6 +424,7 @@ func TestPathPrefix(t *testing.T) {
 			vars:        map[string]string{""v1"": ""222""},
 			host:        """",
 			path:        ""/111/222"",
+			path_template: `/111/{v1:[0-9]{3}}`,
 			shouldMatch: false,
 		},
 		{
@@ -406,6 +434,7 @@ func TestPathPrefix(t *testing.T) {
 			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
 			host:        """",
 			path:        ""/111/222"",
+			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
 			shouldMatch: true,
 		},
 		{
@@ -415,12 +444,14 @@ func TestPathPrefix(t *testing.T) {
 			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
 			host:        """",
 			path:        ""/111/222"",
+			path_template: `/{v1:[0-9]{3}}/{v2:[0-9]{3}}`,
 			shouldMatch: false,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -433,6 +464,8 @@ func TestHostPath(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			path_template: `/111/222/333`,
+			host_template: `aaa.bbb.ccc`,
 			shouldMatch: true,
 		},
 		{
@@ -442,6 +475,8 @@ func TestHostPath(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			path_template: `/111/222/333`,
+			host_template: `aaa.bbb.ccc`,
 			shouldMatch: false,
 		},
 		{
@@ -451,6 +486,8 @@ func TestHostPath(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
 			host:        ""aaa.bbb.ccc"",
 			path:        ""/111/222/333"",
+			path_template: `/111/{v2:[0-9]{3}}/333`,
+			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
 			shouldMatch: true,
 		},
 		{
@@ -460,6 +497,8 @@ func TestHostPath(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
 			host:        ""aaa.bbb.ccc"",
 			path:        ""/111/222/333"",
+			path_template: `/111/{v2:[0-9]{3}}/333`,
+			host_template: `aaa.{v1:[a-z]{3}}.ccc`,
 			shouldMatch: false,
 		},
 		{
@@ -469,6 +508,8 @@ func TestHostPath(t *testing.T) {
 			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
 			host:        ""aaa.bbb.ccc"",
 			path:        ""/111/222/333"",
+			path_template: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
+			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
 			shouldMatch: true,
 		},
 		{
@@ -478,12 +519,15 @@ func TestHostPath(t *testing.T) {
 			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
 			host:        ""aaa.bbb.ccc"",
 			path:        ""/111/222/333"",
+			path_template: `/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}`,
+			host_template: `{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}`,
 			shouldMatch: false,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -541,6 +585,7 @@ func TestHeaders(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 
 }
@@ -578,6 +623,7 @@ func TestMethods(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -599,6 +645,8 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			path_template: `/api`,
+			host_template: `www.example.com`,
 			shouldMatch: true,
 		},
 		{
@@ -608,6 +656,8 @@ func TestQueries(t *testing.T) {
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
+			path_template: `/api`,
+			host_template: `www.example.com`,
 			shouldMatch: true,
 		},
 		{
@@ -803,6 +853,7 @@ func TestQueries(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -839,6 +890,7 @@ func TestSchemes(t *testing.T) {
 	}
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -873,6 +925,7 @@ func TestMatcherFunc(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -887,6 +940,7 @@ func TestBuildVarsFunc(t *testing.T) {
 			}),
 			request:     newRequest(""GET"", ""http://localhost/111/2""),
 			path:        ""/111/3a"",
+			path_template: `/111/{v1:\d}{v2:.*}`,
 			shouldMatch: true,
 		},
 		{
@@ -900,12 +954,14 @@ func TestBuildVarsFunc(t *testing.T) {
 			}),
 			request:     newRequest(""GET"", ""http://localhost/1/a""),
 			path:        ""/2/b"",
+			path_template: `/{v1:\d}/{v2:\w}`,
 			shouldMatch: true,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -920,6 +976,8 @@ func TestSubRouter(t *testing.T) {
 			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
 			host:        ""aaa.google.com"",
 			path:        ""/bbb"",
+			path_template: `/{v2:[a-z]+}`,
+			host_template: `{v1:[a-z]+}.google.com`,
 			shouldMatch: true,
 		},
 		{
@@ -928,6 +986,8 @@ func TestSubRouter(t *testing.T) {
 			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
 			host:        ""aaa.google.com"",
 			path:        ""/bbb"",
+			path_template: `/{v2:[a-z]+}`,
+			host_template: `{v1:[a-z]+}.google.com`,
 			shouldMatch: false,
 		},
 		{
@@ -936,6 +996,7 @@ func TestSubRouter(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
 			host:        """",
 			path:        ""/foo/bar/baz/ding"",
+			path_template: `/foo/{v1}/baz/{v2}`,
 			shouldMatch: true,
 		},
 		{
@@ -944,12 +1005,14 @@ func TestSubRouter(t *testing.T) {
 			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
 			host:        """",
 			path:        ""/foo/bar/baz/ding"",
+			path_template: `/foo/{v1}/baz/{v2}`,
 			shouldMatch: false,
 		},
 	}
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -1045,6 +1108,7 @@ func TestStrictSlash(t *testing.T) {
 
 	for _, test := range tests {
 		testRoute(t, test)
+		testTemplate(t, test)
 	}
 }
 
@@ -1152,14 +1216,13 @@ func TestSubrouterErrorHandling(t *testing.T) {
 // ----------------------------------------------------------------------------
 
 func getRouteTemplate(route *Route) string {
-	host, path := ""none"", ""none""
-	if route.regexp != nil {
-		if route.regexp.host != nil {
-			host = route.regexp.host.template
-		}
-		if route.regexp.path != nil {
-			path = route.regexp.path.template
-		}
+	host, err := route.GetHostTemplate()
+	if err != nil {
+		host = ""none""
+	}
+	path, err := route.GetPathTemplate()
+	if err != nil {
+		path = ""none""
 	}
 	return fmt.Sprintf(""Host: %v, Path: %v"", host, path)
 }
@@ -1221,6 +1284,29 @@ func testRoute(t *testing.T, test routeTest) {
 	}
 }
 
+func testTemplate(t *testing.T, test routeTest) {
+	route := test.route
+	path_template := test.path_template
+	if len(path_template) == 0 {
+		path_template = test.path
+	}
+	host_template := test.host_template
+	if len(host_template) == 0 {
+		host_template = test.host
+	}
+
+	path_tmpl, path_err := route.GetPathTemplate()
+	if path_err == nil  && path_tmpl != path_template {
+		t.Errorf(""(%v) GetPathTemplate not equal: expected %v, got %v"", test.title, path_template, path_tmpl)
+	}
+
+
+	host_tmpl, host_err := route.GetHostTemplate()
+	if host_err == nil  && host_tmpl != host_template {
+		t.Errorf(""(%v) GetHostTemplate not equal: expected %v, got %v"", test.title, host_template, host_tmpl)
+	}
+}
+
 // Tests that the context is cleared or not cleared properly depending on
 // the configuration of the router
 func TestKeepContext(t *testing.T) {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=0d60c4bfebed9448afb78ab65727a497cc2d9f3d,https://github.com/gorilla/mux/blob/0d60c4bfebed9448afb78ab65727a497cc2d9f3d/mux_test.go
0d60c4bfebed9448afb78ab65727a497cc2d9f3d,37d0336a03fafb65483b8afde37db12d10718036,route.go,,"Sun, 28 Feb 2016 22:42:09 GMT",modified,14,3,17,"@@ -532,10 +532,11 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	}, nil
 }
 
-// URLPathTemplate returns the template used to match against for the route
-//
+// GetPathTemplate and GetHostTemplate returns the template used to match against for the route
+// This is userful for building simple REST API documentation,
+// and instrumentation for services like New Relic to ensure consistent reporting
 // The route must have a path defined.
-func (r *Route) URLPathTemplate() (string, error) {
+func (r *Route) GetPathTemplate() (string, error) {
 	if r.err != nil {
 		return """", r.err
 	}
@@ -545,6 +546,16 @@ func (r *Route) URLPathTemplate() (string, error) {
 	return r.regexp.path.template, nil
 }
 
+func (r *Route) GetHostTemplate() (string, error) {
+	if r.err != nil {
+		return """", r.err
+	}
+	if r.regexp == nil || r.regexp.host == nil {
+		return """", errors.New(""mux: route doesn't have a host"")
+	}
+	return r.regexp.host.template, nil
+}
+
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=0d60c4bfebed9448afb78ab65727a497cc2d9f3d,https://github.com/gorilla/mux/blob/0d60c4bfebed9448afb78ab65727a497cc2d9f3d/route.go
16507e2c476babc0abccdb1ed84165067c492361,4dcdacb65fec19b4dd508fe64b91b2d23dafcdf6,.travis.yml,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,18,5,23,"@@ -1,7 +1,20 @@
 language: go
+sudo: false
 
-go:
-  - 1.0
-  - 1.1
-  - 1.2
-  - tip
+matrix:
+  include:
+    - go: 1.2
+    - go: 1.3
+    - go: 1.4
+    - go: 1.5
+    - go: 1.6
+    - go: tip
+
+install:
+  - go get golang.org/x/tools/cmd/vet
+
+script:
+  - go get -t -v ./...
+  - diff -u <(echo -n) <(gofmt -d .)
+  - go tool vet .
+  - go test -v -race ./...",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/.travis.yml
16507e2c476babc0abccdb1ed84165067c492361,9516c519163089db11e592c6a3df2aa8b3b9ae47,README.md,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,238,3,241,"@@ -1,7 +1,242 @@
 mux
 ===
-[![Build Status](https://travis-ci.org/gorilla/mux.png?branch=master)](https://travis-ci.org/gorilla/mux)
+[![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
+[![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
 
-gorilla/mux is a powerful URL router and dispatcher.
+http://www.gorillatoolkit.org/pkg/mux
 
-Read the full documentation here: http://www.gorillatoolkit.org/pkg/mux
+Package `gorilla/mux` implements a request router and dispatcher.
+
+The name mux stands for ""HTTP request multiplexer"". Like the standard `http.ServeMux`, `mux.Router` matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:
+
+* Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers.
+* URL hosts and paths can have variables with an optional regular expression.
+* Registered URLs can be built, or ""reversed"", which helps maintaining references to resources.
+* Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching.
+* It implements the `http.Handler` interface so it is compatible with the standard `http.ServeMux`.
+
+Let's start registering a couple of URL paths and handlers:
+
+```go
+func main() {
+	r := mux.NewRouter()
+	r.HandleFunc(""/"", HomeHandler)
+	r.HandleFunc(""/products"", ProductsHandler)
+	r.HandleFunc(""/articles"", ArticlesHandler)
+	http.Handle(""/"", r)
+}
+```
+
+Here we register three routes mapping URL paths to handlers. This is equivalent to how `http.HandleFunc()` works: if an incoming request URL matches one of the paths, the corresponding handler is called passing (`http.ResponseWriter`, `*http.Request`) as parameters.
+
+Paths can have variables. They are defined using the format `{name}` or `{name:pattern}`. If a regular expression pattern is not defined, the matched variable will be anything until the next slash. For example:
+
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/products/{key}"", ProductHandler)
+r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
+r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
+```
+
+The names are used to create a map of route variables which can be retrieved calling `mux.Vars()`:
+
+```go
+vars := mux.Vars(request)
+category := vars[""category""]
+```
+
+And this is all you need to know about the basic usage. More advanced options are explained below.
+
+Routes can also be restricted to a domain or subdomain. Just define a host pattern to be matched. They can also have variables:
+
+```go
+r := mux.NewRouter()
+// Only matches if domain is ""www.example.com"".
+r.Host(""www.example.com"")
+// Matches a dynamic subdomain.
+r.Host(""{subdomain:[a-z]+}.domain.com"")
+```
+
+There are several other matchers that can be added. To match path prefixes:
+
+```go
+r.PathPrefix(""/products/"")
+```
+
+...or HTTP methods:
+
+```go
+r.Methods(""GET"", ""POST"")
+```
+
+...or URL schemes:
+
+```go
+r.Schemes(""https"")
+```
+
+...or header values:
+
+```go
+r.Headers(""X-Requested-With"", ""XMLHttpRequest"")
+```
+
+...or query values:
+
+```go
+r.Queries(""key"", ""value"")
+```
+
+...or to use a custom matcher function:
+
+```go
+r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
+	return r.ProtoMajor == 0
+})
+```
+
+...and finally, it is possible to combine several matchers in a single route:
+
+```go
+r.HandleFunc(""/products"", ProductsHandler).
+  Host(""www.example.com"").
+  Methods(""GET"").
+  Schemes(""http"")
+```
+
+Setting the same matching conditions again and again can be boring, so we have a way to group several routes that share the same requirements. We call it ""subrouting"".
+
+For example, let's say we have several URLs that should only match when the host is `www.example.com`. Create a route for that host and get a ""subrouter"" from it:
+
+```go
+r := mux.NewRouter()
+s := r.Host(""www.example.com"").Subrouter()
+```
+
+Then register routes in the subrouter:
+
+```go
+s.HandleFunc(""/products/"", ProductsHandler)
+s.HandleFunc(""/products/{key}"", ProductHandler)
+s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+```
+
+The three URL paths we registered above will only be tested if the domain is `www.example.com`, because the subrouter is tested first. This is not only convenient, but also optimizes request matching. You can create subrouters combining any attribute matchers accepted by a route.
+
+Subrouters can be used to create domain or path ""namespaces"": you define subrouters in a central place and then parts of the app can register its paths relatively to a given subrouter.
+
+There's one more thing about subroutes. When a subrouter has a path prefix, the inner routes use it as base for their paths:
+
+```go
+r := mux.NewRouter()
+s := r.PathPrefix(""/products"").Subrouter()
+// ""/products/""
+s.HandleFunc(""/"", ProductsHandler)
+// ""/products/{key}/""
+s.HandleFunc(""/{key}/"", ProductHandler)
+// ""/products/{key}/details""
+s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
+```
+
+Now let's see how to build registered URLs.
+
+Routes can be named. All routes that define a name can have their URLs built, or ""reversed"". We define a name calling `Name()` on a route. For example:
+
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+  Name(""article"")
+```
+
+To build a URL, get the route and call the `URL()` method, passing a sequence of key/value pairs for the route variables. For the previous route, we would do:
+
+```go
+url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+```
+
+...and the result will be a `url.URL` with the following path:
+
+```
+""/articles/technology/42""
+```
+
+This also works for host variables:
+
+```go
+r := mux.NewRouter()
+r.Host(""{subdomain}.domain.com"").
+  Path(""/articles/{category}/{id:[0-9]+}"").
+  HandlerFunc(ArticleHandler).
+  Name(""article"")
+
+// url.String() will be ""http://news.domain.com/articles/technology/42""
+url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+                                 ""category"", ""technology"",
+                                 ""id"", ""42"")
+```
+
+All variables defined in the route are required, and their values must conform to the corresponding patterns. These requirements guarantee that a generated URL will always match a registered route -- the only exception is for explicitly defined ""build-only"" routes which never match.
+
+Regex support also exists for matching Headers within a route. For example, we could do:
+
+```go
+r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
+```
+
+...and the route will match both requests with a Content-Type of `application/json` as well as `application/text`
+
+There's also a way to build only the URL host or path for a route: use the methods `URLHost()` or `URLPath()` instead. For the previous route, we would do:
+
+```go
+// ""http://news.domain.com/""
+host, err := r.Get(""article"").URLHost(""subdomain"", ""news"")
+
+// ""/articles/technology/42""
+path, err := r.Get(""article"").URLPath(""category"", ""technology"", ""id"", ""42"")
+```
+
+And if you use subrouters, host and path defined separately can be built as well:
+
+```go
+r := mux.NewRouter()
+s := r.Host(""{subdomain}.domain.com"").Subrouter()
+s.Path(""/articles/{category}/{id:[0-9]+}"").
+  HandlerFunc(ArticleHandler).
+  Name(""article"")
+
+// ""http://news.domain.com/articles/technology/42""
+url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+                                 ""category"", ""technology"",
+                                 ""id"", ""42"")
+```
+
+## Full Example
+
+Here's a complete, runnable example of a small `mux` based server:
+
+```go
+package main
+
+import (
+	""net/http""
+
+	""github.com/gorilla/mux""
+)
+
+func YourHandler(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte(""Gorilla!\n""))
+}
+
+func main() {
+	r := mux.NewRouter()
+	// Routes consist of a path and a handler function.
+	r.HandleFunc(""/"", YourHandler)
+
+	// Bind to a port and pass our router in
+	http.ListenAndServe("":8000"", r)
+}
+```
+
+## License
+
+BSD licensed. See the LICENSE file for details.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/README.md
16507e2c476babc0abccdb1ed84165067c492361,946289b92b5b4f3ce41395b6e9e26c1a0c824790,bench_test.go,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,28,0,28,"@@ -6,6 +6,7 @@ package mux
 
 import (
 	""net/http""
+	""net/http/httptest""
 	""testing""
 )
 
@@ -19,3 +20,30 @@ func BenchmarkMux(b *testing.B) {
 		router.ServeHTTP(nil, request)
 	}
 }
+
+func BenchmarkMuxAlternativeInRegexp(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/v1/{v1:(a|b)}"", handler)
+
+	requestA, _ := http.NewRequest(""GET"", ""/v1/a"", nil)
+	requestB, _ := http.NewRequest(""GET"", ""/v1/b"", nil)
+	for i := 0; i < b.N; i++ {
+		router.ServeHTTP(nil, requestA)
+		router.ServeHTTP(nil, requestB)
+	}
+}
+
+func BenchmarkManyPathVariables(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/v1/{v1}/{v2}/{v3}/{v4}/{v5}"", handler)
+
+	matchingRequest, _ := http.NewRequest(""GET"", ""/v1/1/2/3/4/5"", nil)
+	notMatchingRequest, _ := http.NewRequest(""GET"", ""/v1/1/2/3/4"", nil)
+	recorder := httptest.NewRecorder()
+	for i := 0; i < b.N; i++ {
+		router.ServeHTTP(nil, matchingRequest)
+		router.ServeHTTP(recorder, notMatchingRequest)
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/bench_test.go
16507e2c476babc0abccdb1ed84165067c492361,49798cb5cf5291db6bc3eee2ad4d168c647b4166,doc.go,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,13,6,19,"@@ -60,8 +60,8 @@ Routes can also be restricted to a domain or subdomain. Just define a host
 pattern to be matched. They can also have variables:
 
 	r := mux.NewRouter()
-	// Only matches if domain is ""www.domain.com"".
-	r.Host(""www.domain.com"")
+	// Only matches if domain is ""www.example.com"".
+	r.Host(""www.example.com"")
 	// Matches a dynamic subdomain.
 	r.Host(""{subdomain:[a-z]+}.domain.com"")
 
@@ -94,7 +94,7 @@ There are several other matchers that can be added. To match path prefixes:
 ...and finally, it is possible to combine several matchers in a single route:
 
 	r.HandleFunc(""/products"", ProductsHandler).
-	  Host(""www.domain.com"").
+	  Host(""www.example.com"").
 	  Methods(""GET"").
 	  Schemes(""http"")
 
@@ -103,11 +103,11 @@ a way to group several routes that share the same requirements.
 We call it ""subrouting"".
 
 For example, let's say we have several URLs that should only match when the
-host is ""www.domain.com"". Create a route for that host and get a ""subrouter""
+host is ""www.example.com"". Create a route for that host and get a ""subrouter""
 from it:
 
 	r := mux.NewRouter()
-	s := r.Host(""www.domain.com"").Subrouter()
+	s := r.Host(""www.example.com"").Subrouter()
 
 Then register routes in the subrouter:
 
@@ -116,7 +116,7 @@ Then register routes in the subrouter:
 	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
 
 The three URL paths we registered above will only be tested if the domain is
-""www.domain.com"", because the subrouter is tested first. This is not
+""www.example.com"", because the subrouter is tested first. This is not
 only convenient, but also optimizes request matching. You can create
 subrouters combining any attribute matchers accepted by a route.
 
@@ -172,6 +172,13 @@ conform to the corresponding patterns. These requirements guarantee that a
 generated URL will always match a registered route -- the only exception is
 for explicitly defined ""build-only"" routes which never match.
 
+Regex support also exists for matching Headers within a route. For example, we could do:
+
+	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
+
+...and the route will match both requests with a Content-Type of `application/json` as well as
+`application/text`
+
 There's also a way to build only the URL host or path for a route:
 use the methods URLHost() or URLPath() instead. For the previous route,
 we would do:",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/doc.go
16507e2c476babc0abccdb1ed84165067c492361,aabe9958f2097f7f19ced28d59a9592fd1274d2a,mux.go,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,128,13,141,"@@ -5,9 +5,11 @@
 package mux
 
 import (
+	""errors""
 	""fmt""
 	""net/http""
 	""path""
+	""regexp""
 
 	""github.com/gorilla/context""
 )
@@ -57,6 +59,12 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 			return true
 		}
 	}
+
+	// Closest match for a router (includes sub-routers)
+	if r.NotFoundHandler != nil {
+		match.Handler = r.NotFoundHandler
+		return true
+	}
 	return false
 }
 
@@ -68,7 +76,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	// Clean path to canonical form and redirect.
 	if p := cleanPath(req.URL.Path); p != req.URL.Path {
 
-		// Added 3 lines (Philip Schlump) - It was droping the query string and #whatever from query.
+		// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
 		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
 		// http://code.google.com/p/go/issues/detail?id=5252
 		url := *req.URL
@@ -87,10 +95,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		setCurrentRoute(req, match.Route)
 	}
 	if handler == nil {
-		handler = r.NotFoundHandler
-		if handler == nil {
-			handler = http.NotFoundHandler()
-		}
+		handler = http.NotFoundHandler()
 	}
 	if !r.KeepContext {
 		defer context.Clear(req)
@@ -237,6 +242,52 @@ func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
 	return r.NewRoute().BuildVarsFunc(f)
 }
 
+// Walk walks the router and all its sub-routers, calling walkFn for each route
+// in the tree. The routes are walked in the order they were added. Sub-routers
+// are explored depth-first.
+func (r *Router) Walk(walkFn WalkFunc) error {
+	return r.walk(walkFn, []*Route{})
+}
+
+// SkipRouter is used as a return value from WalkFuncs to indicate that the
+// router that walk is about to descend down to should be skipped.
+var SkipRouter = errors.New(""skip this router"")
+
+// WalkFunc is the type of the function called for each route visited by Walk.
+// At every invocation, it is given the current route, and the current router,
+// and a list of ancestor routes that lead to the current route.
+type WalkFunc func(route *Route, router *Router, ancestors []*Route) error
+
+func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
+	for _, t := range r.routes {
+		if t.regexp == nil || t.regexp.path == nil || t.regexp.path.template == """" {
+			continue
+		}
+
+		err := walkFn(t, r, ancestors)
+		if err == SkipRouter {
+			continue
+		}
+		for _, sr := range t.matchers {
+			if h, ok := sr.(*Router); ok {
+				err := h.walk(walkFn, ancestors)
+				if err != nil {
+					return err
+				}
+			}
+		}
+		if h, ok := t.handler.(*Router); ok {
+			ancestors = append(ancestors, t)
+			err := h.walk(walkFn, ancestors)
+			if err != nil {
+				return err
+			}
+			ancestors = ancestors[:len(ancestors)-1]
+		}
+	}
+	return nil
+}
+
 // ----------------------------------------------------------------------------
 // Context
 // ----------------------------------------------------------------------------
@@ -264,6 +315,10 @@ func Vars(r *http.Request) map[string]string {
 }
 
 // CurrentRoute returns the matched route for the current request, if any.
+// This only works when called inside the handler of the matched route
+// because the matched route is stored in the request context which is cleared
+// after the handler returns, unless the KeepContext option is set on the
+// Router.
 func CurrentRoute(r *http.Request) *Route {
 	if rv := context.Get(r, routeKey); rv != nil {
 		return rv.(*Route)
@@ -272,11 +327,15 @@ func CurrentRoute(r *http.Request) *Route {
 }
 
 func setVars(r *http.Request, val interface{}) {
-	context.Set(r, varsKey, val)
+	if val != nil {
+		context.Set(r, varsKey, val)
+	}
 }
 
 func setCurrentRoute(r *http.Request, val interface{}) {
-	context.Set(r, routeKey, val)
+	if val != nil {
+		context.Set(r, routeKey, val)
+	}
 }
 
 // ----------------------------------------------------------------------------
@@ -313,20 +372,49 @@ func uniqueVars(s1, s2 []string) error {
 	return nil
 }
 
-// mapFromPairs converts variadic string parameters to a string map.
-func mapFromPairs(pairs ...string) (map[string]string, error) {
+// checkPairs returns the count of strings passed in, and an error if
+// the count is not an even number.
+func checkPairs(pairs ...string) (int, error) {
 	length := len(pairs)
 	if length%2 != 0 {
-		return nil, fmt.Errorf(
+		return length, fmt.Errorf(
 			""mux: number of parameters must be multiple of 2, got %v"", pairs)
 	}
+	return length, nil
+}
+
+// mapFromPairsToString converts variadic string parameters to a
+// string to string map.
+func mapFromPairsToString(pairs ...string) (map[string]string, error) {
+	length, err := checkPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
 	m := make(map[string]string, length/2)
 	for i := 0; i < length; i += 2 {
 		m[pairs[i]] = pairs[i+1]
 	}
 	return m, nil
 }
 
+// mapFromPairsToRegex converts variadic string paramers to a
+// string to regex map.
+func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
+	length, err := checkPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	m := make(map[string]*regexp.Regexp, length/2)
+	for i := 0; i < length; i += 2 {
+		regex, err := regexp.Compile(pairs[i+1])
+		if err != nil {
+			return nil, err
+		}
+		m[pairs[i]] = regex
+	}
+	return m, nil
+}
+
 // matchInArray returns true if the given string value is in the array.
 func matchInArray(arr []string, value string) bool {
 	for _, v := range arr {
@@ -337,9 +425,8 @@ func matchInArray(arr []string, value string) bool {
 	return false
 }
 
-// matchMap returns true if the given key/value pairs exist in a given map.
-func matchMap(toCheck map[string]string, toMatch map[string][]string,
-	canonicalKey bool) bool {
+// matchMapWithString returns true if the given key/value pairs exist in a given map.
+func matchMapWithString(toCheck map[string]string, toMatch map[string][]string, canonicalKey bool) bool {
 	for k, v := range toCheck {
 		// Check if key exists.
 		if canonicalKey {
@@ -364,3 +451,31 @@ func matchMap(toCheck map[string]string, toMatch map[string][]string,
 	}
 	return true
 }
+
+// matchMapWithRegex returns true if the given key/value pairs exist in a given map compiled against
+// the given regex
+func matchMapWithRegex(toCheck map[string]*regexp.Regexp, toMatch map[string][]string, canonicalKey bool) bool {
+	for k, v := range toCheck {
+		// Check if key exists.
+		if canonicalKey {
+			k = http.CanonicalHeaderKey(k)
+		}
+		if values := toMatch[k]; values == nil {
+			return false
+		} else if v != nil {
+			// If value was defined as an empty string we only check that the
+			// key exists. Otherwise we also check for equality.
+			valueExists := false
+			for _, value := range values {
+				if v.MatchString(value) {
+					valueExists = true
+					break
+				}
+			}
+			if !valueExists {
+				return false
+			}
+		}
+	}
+	return true
+}",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/mux.go
16507e2c476babc0abccdb1ed84165067c492361,1ea439ad131204ff00a7cdf985338be91a119b0b,mux_test.go,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,310,0,310,"@@ -7,11 +7,24 @@ package mux
 import (
 	""fmt""
 	""net/http""
+	""strings""
 	""testing""
 
 	""github.com/gorilla/context""
 )
 
+func (r *Route) GoString() string {
+	matchers := make([]string, len(r.matchers))
+	for i, m := range r.matchers {
+		matchers[i] = fmt.Sprintf(""%#v"", m)
+	}
+	return fmt.Sprintf(""&Route{matchers:[]matcher{%s}}"", strings.Join(matchers, "", ""))
+}
+
+func (r *routeRegexp) GoString() string {
+	return fmt.Sprintf(""&routeRegexp{template: %q, matchHost: %t, matchQuery: %t, strictSlash: %t, regexp: regexp.MustCompile(%q), reverse: %q, varsN: %v, varsR: %v"", r.template, r.matchHost, r.matchQuery, r.strictSlash, r.regexp.String(), r.reverse, r.varsN, r.varsR)
+}
+
 type routeTest struct {
 	title          string            // title of the test
 	route          *Route            // the route being tested
@@ -108,6 +121,15 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Host route with pattern, additional capturing group, match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Host route with pattern, wrong host in request URL"",
 			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
@@ -135,6 +157,33 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Host route with hyphenated name and pattern, match"",
+			route:       new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with hyphenated name and pattern, additional capturing group, match"",
+			route:       new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with multiple hyphenated names and patterns, match"",
+			route:       new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Path route with single pattern with pipe, match"",
 			route:       new(Route).Path(""/{category:a|b/c}""),
@@ -260,6 +309,42 @@ func TestPath(t *testing.T) {
 			path:        ""/111/222/333"",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Path route with multiple patterns with pipe, match"",
+			route:       new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:        """",
+			path:        ""/a/product_name/1"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with hyphenated name and pattern, match"",
+			route:       new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v-1"": ""222""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple hyphenated names and patterns, match"",
+			route:       new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple hyphenated names and patterns with pipe, match"",
+			route:       new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:        map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
+			host:        """",
+			path:        ""/a/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {
@@ -434,6 +519,24 @@ func TestHeaders(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Headers route, regex header values to match"",
+			route:       new(Route).Headers(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Headers route, regex header values to match"",
+			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baz""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {
@@ -579,6 +682,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with regexp pattern with quantifier, additional capturing group"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}(a|b)}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
+			vars:        map[string]string{""v1"": ""1a""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
 			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
@@ -588,6 +700,105 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with hyphenated name, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:        map[string]string{""v-1"": ""bar""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with multiple hyphenated names, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1}"", ""baz"", ""{v-2}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:        map[string]string{""v-1"": ""bar"", ""v-2"": ""ding""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with hyphenate name and pattern, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=10""),
+			vars:        map[string]string{""v-1"": ""10""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with hyphenated name and pattern with quantifier, additional capturing group"",
+			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]{1}(a|b)}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
+			vars:        map[string]string{""v-1"": ""1a""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with empty value, should match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with empty value and no parameter in request, should not match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Queries route with empty value and empty parameter in request, should match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost?foo=""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with overlapping value, should not match"",
+			route:       new(Route).Queries(""foo"", ""bar""),
+			request:     newRequest(""GET"", ""http://localhost?foo=barfoo""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Queries route with no parameter in request, should not match"",
+			route:       new(Route).Queries(""foo"", ""{bar}""),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Queries route with empty parameter in request, should match"",
+			route:       new(Route).Queries(""foo"", ""{bar}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=""),
+			vars:        map[string]string{""foo"": """"},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route, bad submatch"",
+			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://localhost?fffoo=bar&baz=dingggg""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {
@@ -837,6 +1048,105 @@ func TestStrictSlash(t *testing.T) {
 	}
 }
 
+func TestWalkSingleDepth(t *testing.T) {
+	r0 := NewRouter()
+	r1 := NewRouter()
+	r2 := NewRouter()
+
+	r0.Path(""/g"")
+	r0.Path(""/o"")
+	r0.Path(""/d"").Handler(r1)
+	r0.Path(""/r"").Handler(r2)
+	r0.Path(""/a"")
+
+	r1.Path(""/z"")
+	r1.Path(""/i"")
+	r1.Path(""/l"")
+	r1.Path(""/l"")
+
+	r2.Path(""/i"")
+	r2.Path(""/l"")
+	r2.Path(""/l"")
+
+	paths := []string{""g"", ""o"", ""r"", ""i"", ""l"", ""l"", ""a""}
+	depths := []int{0, 0, 0, 1, 1, 1, 0}
+	i := 0
+	err := r0.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		matcher := route.matchers[0].(*routeRegexp)
+		if matcher.template == ""/d"" {
+			return SkipRouter
+		}
+		if len(ancestors) != depths[i] {
+			t.Errorf(`Expected depth of %d at i = %d; got ""%d""`, depths[i], i, len(ancestors))
+		}
+		if matcher.template != ""/""+paths[i] {
+			t.Errorf(`Expected ""/%s"" at i = %d; got ""%s""`, paths[i], i, matcher.template)
+		}
+		i++
+		return nil
+	})
+	if err != nil {
+		panic(err)
+	}
+	if i != len(paths) {
+		t.Errorf(""Expected %d routes, found %d"", len(paths), i)
+	}
+}
+
+func TestWalkNested(t *testing.T) {
+	router := NewRouter()
+
+	g := router.Path(""/g"").Subrouter()
+	o := g.PathPrefix(""/o"").Subrouter()
+	r := o.PathPrefix(""/r"").Subrouter()
+	i := r.PathPrefix(""/i"").Subrouter()
+	l1 := i.PathPrefix(""/l"").Subrouter()
+	l2 := l1.PathPrefix(""/l"").Subrouter()
+	l2.Path(""/a"")
+
+	paths := []string{""/g"", ""/g/o"", ""/g/o/r"", ""/g/o/r/i"", ""/g/o/r/i/l"", ""/g/o/r/i/l/l"", ""/g/o/r/i/l/l/a""}
+	idx := 0
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		path := paths[idx]
+		tpl := route.regexp.path.template
+		if tpl != path {
+			t.Errorf(`Expected %s got %s`, path, tpl)
+		}
+		idx++
+		return nil
+	})
+	if err != nil {
+		panic(err)
+	}
+	if idx != len(paths) {
+		t.Errorf(""Expected %d routes, found %d"", len(paths), idx)
+	}
+}
+
+func TestSubrouterErrorHandling(t *testing.T) {
+	superRouterCalled := false
+	subRouterCalled := false
+
+	router := NewRouter()
+	router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		superRouterCalled = true
+	})
+	subRouter := router.PathPrefix(""/bign8"").Subrouter()
+	subRouter.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		subRouterCalled = true
+	})
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost/bign8/was/here"", nil)
+	router.ServeHTTP(NewRecorder(), req)
+
+	if superRouterCalled {
+		t.Error(""Super router 404 handler called when sub-router 404 handler is available."")
+	}
+	if !subRouterCalled {
+		t.Error(""Sub-router 404 handler was not called."")
+	}
+}
+
 // ----------------------------------------------------------------------------
 // Helpers
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/mux_test.go
16507e2c476babc0abccdb1ed84165067c492361,755db483e8f387040c98487c9e577e20703eaa51,old_test.go,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,3,3,6,"@@ -545,7 +545,7 @@ func TestMatchedRouteName(t *testing.T) {
 	router := NewRouter()
 	route := router.NewRoute().Path(""/products/"").Name(routeName)
 
-	url := ""http://www.domain.com/products/""
+	url := ""http://www.example.com/products/""
 	request, _ := http.NewRequest(""GET"", url, nil)
 	var rv RouteMatch
 	ok := router.Match(request, &rv)
@@ -563,10 +563,10 @@ func TestMatchedRouteName(t *testing.T) {
 func TestSubRouting(t *testing.T) {
 	// Example from docs.
 	router := NewRouter()
-	subrouter := router.NewRoute().Host(""www.domain.com"").Subrouter()
+	subrouter := router.NewRoute().Host(""www.example.com"").Subrouter()
 	route := subrouter.NewRoute().Path(""/products/"").Name(""products"")
 
-	url := ""http://www.domain.com/products/""
+	url := ""http://www.example.com/products/""
 	request, _ := http.NewRequest(""GET"", url, nil)
 	var rv RouteMatch
 	ok := router.Match(request, &rv)",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/old_test.go
16507e2c476babc0abccdb1ed84165067c492361,3c3a31bfa7ea0b0555e5ea855ffadf08fa6c4e70,regexp.go,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,49,20,69,"@@ -10,6 +10,7 @@ import (
 	""net/http""
 	""net/url""
 	""regexp""
+	""strconv""
 	""strings""
 )
 
@@ -34,7 +35,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
 	if matchQuery {
-		defaultPattern = ""[^?&]+""
+		defaultPattern = ""[^?&]*""
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
 		matchPrefix = false
@@ -72,7 +73,11 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
+		if patt[0] == '(' && patt[len(patt)-1] == ')' {
+			fmt.Fprintf(pattern, ""%s%s"", regexp.QuoteMeta(raw), patt)
+		} else {
+			fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
+		}
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 
@@ -89,6 +94,12 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	if strictSlash {
 		pattern.WriteString(""[/]?"")
 	}
+	if matchQuery {
+		// Add the default pattern if the query value is empty
+		if queryVal := strings.SplitN(template, ""="", 2)[1]; queryVal == """" {
+			pattern.WriteString(defaultPattern)
+		}
+	}
 	if !matchPrefix {
 		pattern.WriteByte('$')
 	}
@@ -180,9 +191,13 @@ func (r *routeRegexp) getUrlQuery(req *http.Request) string {
 	if !r.matchQuery {
 		return """"
 	}
-	key := strings.Split(r.template, ""="")[0]
-	val := req.URL.Query().Get(key)
-	return key + ""="" + val
+	templateKey := strings.SplitN(r.template, ""="", 2)[0]
+	for key, vals := range req.URL.Query() {
+		if key == templateKey && len(vals) > 0 {
+			return key + ""="" + vals[0]
+		}
+	}
+	return """"
 }
 
 func (r *routeRegexp) matchQueryString(req *http.Request) bool {
@@ -214,6 +229,11 @@ func braceIndices(s string) ([]int, error) {
 	return idxs, nil
 }
 
+// varGroupName builds a capturing group name for the indexed variable.
+func varGroupName(idx int) string {
+	return ""v"" + strconv.Itoa(idx)
+}
+
 // ----------------------------------------------------------------------------
 // routeRegexpGroup
 // ----------------------------------------------------------------------------
@@ -229,20 +249,17 @@ type routeRegexpGroup struct {
 func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
-		hostVars := v.host.regexp.FindStringSubmatch(getHost(req))
-		if hostVars != nil {
-			for k, v := range v.host.varsN {
-				m.Vars[v] = hostVars[k+1]
-			}
+		host := getHost(req)
+		matches := v.host.regexp.FindStringSubmatchIndex(host)
+		if len(matches) > 0 {
+			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
 	// Store path variables.
 	if v.path != nil {
-		pathVars := v.path.regexp.FindStringSubmatch(req.URL.Path)
-		if pathVars != nil {
-			for k, v := range v.path.varsN {
-				m.Vars[v] = pathVars[k+1]
-			}
+		matches := v.path.regexp.FindStringSubmatchIndex(req.URL.Path)
+		if len(matches) > 0 {
+			extractVars(req.URL.Path, matches, v.path.varsN, m.Vars)
 			// Check if we should redirect.
 			if v.path.strictSlash {
 				p1 := strings.HasSuffix(req.URL.Path, ""/"")
@@ -261,11 +278,10 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	}
 	// Store query string variables.
 	for _, q := range v.queries {
-		queryVars := q.regexp.FindStringSubmatch(q.getUrlQuery(req))
-		if queryVars != nil {
-			for k, v := range q.varsN {
-				m.Vars[v] = queryVars[k+1]
-			}
+		queryUrl := q.getUrlQuery(req)
+		matches := q.regexp.FindStringSubmatchIndex(queryUrl)
+		if len(matches) > 0 {
+			extractVars(queryUrl, matches, q.varsN, m.Vars)
 		}
 	}
 }
@@ -283,3 +299,16 @@ func getHost(r *http.Request) string {
 	return host
 
 }
+
+func extractVars(input string, matches []int, names []string, output map[string]string) {
+	matchesCount := 0
+	prevEnd := -1
+	for i := 2; i < len(matches) && matchesCount < len(names); i += 2 {
+		if prevEnd < matches[i+1] {
+			value := input[matches[i]:matches[i+1]]
+			output[names[matchesCount]] = value
+			prevEnd = matches[i+1]
+			matchesCount++
+		}
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/regexp.go
16507e2c476babc0abccdb1ed84165067c492361,cb0e57d943d9970bbce03b72087e5e0723570b8f,route.go,,"Sun, 28 Feb 2016 21:16:25 GMT",modified,31,7,38,"@@ -9,6 +9,7 @@ import (
 	""fmt""
 	""net/http""
 	""net/url""
+	""regexp""
 	""strings""
 )
 
@@ -188,7 +189,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 type headerMatcher map[string]string
 
 func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
-	return matchMap(m, r.Header, true)
+	return matchMapWithString(m, r.Header, true)
 }
 
 // Headers adds a matcher for request header values.
@@ -199,17 +200,40 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 //               ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both request header values match.
-//
-// It the value is an empty string, it will match any value if the key is set.
+// If the value is an empty string, it will match any value if the key is set.
 func (r *Route) Headers(pairs ...string) *Route {
 	if r.err == nil {
 		var headers map[string]string
-		headers, r.err = mapFromPairs(pairs...)
+		headers, r.err = mapFromPairsToString(pairs...)
 		return r.addMatcher(headerMatcher(headers))
 	}
 	return r
 }
 
+// headerRegexMatcher matches the request against the route given a regex for the header
+type headerRegexMatcher map[string]*regexp.Regexp
+
+func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
+	return matchMapWithRegex(m, r.Header, true)
+}
+
+// Regular expressions can be used with headers as well.
+// It accepts a sequence of key/value pairs, where the value has regex support. For example
+//     r := mux.NewRouter()
+//     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
+//               ""X-Requested-With"", ""XMLHttpRequest"")
+//
+// The above route will only match if both the request header matches both regular expressions.
+// It the value is an empty string, it will match any value if the key is set.
+func (r *Route) HeadersRegexp(pairs ...string) *Route {
+	if r.err == nil {
+		var headers map[string]*regexp.Regexp
+		headers, r.err = mapFromPairsToRegex(pairs...)
+		return r.addMatcher(headerRegexMatcher(headers))
+	}
+	return r
+}
+
 // Host -----------------------------------------------------------------------
 
 // Host adds a matcher for the URL host.
@@ -223,7 +247,7 @@ func (r *Route) Headers(pairs ...string) *Route {
 // For example:
 //
 //     r := mux.NewRouter()
-//     r.Host(""www.domain.com"")
+//     r.Host(""www.example.com"")
 //     r.Host(""{subdomain}.domain.com"")
 //     r.Host(""{subdomain:[a-z]+}.domain.com"")
 //
@@ -382,7 +406,7 @@ func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
 // It will test the inner routes only if the parent route matched. For example:
 //
 //     r := mux.NewRouter()
-//     s := r.Host(""www.domain.com"").Subrouter()
+//     s := r.Host(""www.example.com"").Subrouter()
 //     s.HandleFunc(""/products/"", ProductsHandler)
 //     s.HandleFunc(""/products/{key}"", ProductHandler)
 //     s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
@@ -524,7 +548,7 @@ func (r *Route) URLPathTemplate() (string, error) {
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
-	m, err := mapFromPairs(pairs...)
+	m, err := mapFromPairsToString(pairs...)
 	if err != nil {
 		return nil, err
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=16507e2c476babc0abccdb1ed84165067c492361,https://github.com/gorilla/mux/blob/16507e2c476babc0abccdb1ed84165067c492361/route.go
c582f4facc2ac9c51fa0358015cfb796aaf6d2ed,9516c519163089db11e592c6a3df2aa8b3b9ae47,README.md,,"Sun, 28 Feb 2016 20:29:58 GMT",modified,2,0,2,"@@ -3,6 +3,8 @@ mux
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
 
+http://www.gorillatoolkit.org/pkg/mux
+
 Package `gorilla/mux` implements a request router and dispatcher.
 
 The name mux stands for ""HTTP request multiplexer"". Like the standard `http.ServeMux`, `mux.Router` matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=c582f4facc2ac9c51fa0358015cfb796aaf6d2ed,https://github.com/gorilla/mux/blob/c582f4facc2ac9c51fa0358015cfb796aaf6d2ed/README.md
5f42f0f524cc51ac5f74cdedf0298bed528981f2,9516c519163089db11e592c6a3df2aa8b3b9ae47,README.md,,"Sun, 28 Feb 2016 20:25:42 GMT",modified,2,0,2,"@@ -3,6 +3,8 @@ mux
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
 
+http://www.gorillatoolkit.org/pkg/mux
+
 Package `gorilla/mux` implements a request router and dispatcher.
 
 The name mux stands for ""HTTP request multiplexer"". Like the standard `http.ServeMux`, `mux.Router` matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=5f42f0f524cc51ac5f74cdedf0298bed528981f2,https://github.com/gorilla/mux/blob/5f42f0f524cc51ac5f74cdedf0298bed528981f2/README.md
d067e8732964fef44811013d178bd8962a9c0a46,946289b92b5b4f3ce41395b6e9e26c1a0c824790,bench_test.go,,"Sun, 28 Feb 2016 20:22:47 GMT",modified,28,0,28,"@@ -6,6 +6,7 @@ package mux
 
 import (
 	""net/http""
+	""net/http/httptest""
 	""testing""
 )
 
@@ -19,3 +20,30 @@ func BenchmarkMux(b *testing.B) {
 		router.ServeHTTP(nil, request)
 	}
 }
+
+func BenchmarkMuxAlternativeInRegexp(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/v1/{v1:(a|b)}"", handler)
+
+	requestA, _ := http.NewRequest(""GET"", ""/v1/a"", nil)
+	requestB, _ := http.NewRequest(""GET"", ""/v1/b"", nil)
+	for i := 0; i < b.N; i++ {
+		router.ServeHTTP(nil, requestA)
+		router.ServeHTTP(nil, requestB)
+	}
+}
+
+func BenchmarkManyPathVariables(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/v1/{v1}/{v2}/{v3}/{v4}/{v5}"", handler)
+
+	matchingRequest, _ := http.NewRequest(""GET"", ""/v1/1/2/3/4/5"", nil)
+	notMatchingRequest, _ := http.NewRequest(""GET"", ""/v1/1/2/3/4"", nil)
+	recorder := httptest.NewRecorder()
+	for i := 0; i < b.N; i++ {
+		router.ServeHTTP(nil, matchingRequest)
+		router.ServeHTTP(recorder, notMatchingRequest)
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=d067e8732964fef44811013d178bd8962a9c0a46,https://github.com/gorilla/mux/blob/d067e8732964fef44811013d178bd8962a9c0a46/bench_test.go
d067e8732964fef44811013d178bd8962a9c0a46,3c3a31bfa7ea0b0555e5ea855ffadf08fa6c4e70,regexp.go,,"Sun, 28 Feb 2016 20:22:47 GMT",modified,31,34,65,"@@ -73,14 +73,17 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		varIdx := i / 2
-		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), varGroupName(varIdx), patt)
+		if patt[0] == '(' && patt[len(patt)-1] == ')' {
+			fmt.Fprintf(pattern, ""%s%s"", regexp.QuoteMeta(raw), patt)
+		} else {
+			fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
+		}
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 
 		// Append variable name and compiled pattern.
-		varsN[varIdx] = name
-		varsR[varIdx], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
+		varsN[i/2] = name
+		varsR[i/2], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
 		if err != nil {
 			return nil, err
 		}
@@ -246,30 +249,17 @@ type routeRegexpGroup struct {
 func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
-		hostVars := v.host.regexp.FindStringSubmatch(getHost(req))
-		if hostVars != nil {
-			subexpNames := v.host.regexp.SubexpNames()
-			varName := 0
-			for i, name := range subexpNames[1:] {
-				if name != """" && name == varGroupName(varName) {
-					m.Vars[v.host.varsN[varName]] = hostVars[i+1]
-					varName++
-				}
-			}
+		host := getHost(req)
+		matches := v.host.regexp.FindStringSubmatchIndex(host)
+		if len(matches) > 0 {
+			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
 	// Store path variables.
 	if v.path != nil {
-		pathVars := v.path.regexp.FindStringSubmatch(req.URL.Path)
-		if pathVars != nil {
-			subexpNames := v.path.regexp.SubexpNames()
-			varName := 0
-			for i, name := range subexpNames[1:] {
-				if name != """" && name == varGroupName(varName) {
-					m.Vars[v.path.varsN[varName]] = pathVars[i+1]
-					varName++
-				}
-			}
+		matches := v.path.regexp.FindStringSubmatchIndex(req.URL.Path)
+		if len(matches) > 0 {
+			extractVars(req.URL.Path, matches, v.path.varsN, m.Vars)
 			// Check if we should redirect.
 			if v.path.strictSlash {
 				p1 := strings.HasSuffix(req.URL.Path, ""/"")
@@ -288,16 +278,10 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	}
 	// Store query string variables.
 	for _, q := range v.queries {
-		queryVars := q.regexp.FindStringSubmatch(q.getUrlQuery(req))
-		if queryVars != nil {
-			subexpNames := q.regexp.SubexpNames()
-			varName := 0
-			for i, name := range subexpNames[1:] {
-				if name != """" && name == varGroupName(varName) {
-					m.Vars[q.varsN[varName]] = queryVars[i+1]
-					varName++
-				}
-			}
+		queryUrl := q.getUrlQuery(req)
+		matches := q.regexp.FindStringSubmatchIndex(queryUrl)
+		if len(matches) > 0 {
+			extractVars(queryUrl, matches, q.varsN, m.Vars)
 		}
 	}
 }
@@ -315,3 +299,16 @@ func getHost(r *http.Request) string {
 	return host
 
 }
+
+func extractVars(input string, matches []int, names []string, output map[string]string) {
+	matchesCount := 0
+	prevEnd := -1
+	for i := 2; i < len(matches) && matchesCount < len(names); i += 2 {
+		if prevEnd < matches[i+1] {
+			value := input[matches[i]:matches[i+1]]
+			output[names[matchesCount]] = value
+			prevEnd = matches[i+1]
+			matchesCount++
+		}
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=d067e8732964fef44811013d178bd8962a9c0a46,https://github.com/gorilla/mux/blob/d067e8732964fef44811013d178bd8962a9c0a46/regexp.go
dfc482b2558f4151fc8598139a686caf3fb2ef65,4dcdacb65fec19b4dd508fe64b91b2d23dafcdf6,.travis.yml,,"Fri, 26 Feb 2016 21:29:39 GMT",modified,12,6,18,"@@ -1,14 +1,20 @@
 language: go
 sudo: false
-go:
-  - 1.3
-  - 1.4
-  - 1.5
-  - tip
+
+matrix:
+  include:
+    - go: 1.2
+    - go: 1.3
+    - go: 1.4
+    - go: 1.5
+    - go: 1.6
+    - go: tip
+
 install:
   - go get golang.org/x/tools/cmd/vet
+
 script:
   - go get -t -v ./...
-  - diff -u <(echo -n) <(gofmt -d -s .)
+  - diff -u <(echo -n) <(gofmt -d .)
   - go tool vet .
   - go test -v -race ./...",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=dfc482b2558f4151fc8598139a686caf3fb2ef65,https://github.com/gorilla/mux/blob/dfc482b2558f4151fc8598139a686caf3fb2ef65/.travis.yml
7872f90afae404a743afc2e74ef5e21797879951,4dcdacb65fec19b4dd508fe64b91b2d23dafcdf6,.travis.yml,,"Fri, 26 Feb 2016 21:23:39 GMT",modified,12,6,18,"@@ -1,14 +1,20 @@
 language: go
 sudo: false
-go:
-  - 1.3
-  - 1.4
-  - 1.5
-  - tip
+
+matrix:
+  include:
+    - go: 1.2
+    - go: 1.3
+    - go: 1.4
+    - go: 1.5
+    - go: 1.6
+    - go: tip
+
 install:
   - go get golang.org/x/tools/cmd/vet
+
 script:
   - go get -t -v ./...
-  - diff -u <(echo -n) <(gofmt -d -s .)
+  - diff -u <(echo -n) <(gofmt -d .)
   - go tool vet .
   - go test -v -race ./...",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=7872f90afae404a743afc2e74ef5e21797879951,https://github.com/gorilla/mux/blob/7872f90afae404a743afc2e74ef5e21797879951/.travis.yml
78fb8eb962166e2ed581b9e30619fc353d2758b3,946289b92b5b4f3ce41395b6e9e26c1a0c824790,bench_test.go,,"Sat, 23 Jan 2016 17:09:52 GMT",modified,15,0,15,"@@ -6,6 +6,7 @@ package mux
 
 import (
 	""net/http""
+	""net/http/httptest""
 	""testing""
 )
 
@@ -32,3 +33,17 @@ func BenchmarkMuxAlternativeInRegexp(b *testing.B) {
 		router.ServeHTTP(nil, requestB)
 	}
 }
+
+func BenchmarkManyPathVariables(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/v1/{v1}/{v2}/{v3}/{v4}/{v5}"", handler)
+
+	matchingRequest, _ := http.NewRequest(""GET"", ""/v1/1/2/3/4/5"", nil)
+	notMatchingRequest, _ := http.NewRequest(""GET"", ""/v1/1/2/3/4"", nil)
+	recorder := httptest.NewRecorder()
+	for i := 0; i < b.N; i++ {
+		router.ServeHTTP(nil, matchingRequest)
+		router.ServeHTTP(recorder, notMatchingRequest)
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=78fb8eb962166e2ed581b9e30619fc353d2758b3,https://github.com/gorilla/mux/blob/78fb8eb962166e2ed581b9e30619fc353d2758b3/bench_test.go
f48927253fa183f81eda684da508ba9226b87e9f,04409ab53de70d140798830cb9338070f7b2f36b,bench_test.go,,"Sat, 23 Jan 2016 16:42:00 GMT",modified,13,0,13,"@@ -19,3 +19,16 @@ func BenchmarkMux(b *testing.B) {
 		router.ServeHTTP(nil, request)
 	}
 }
+
+func BenchmarkMuxAlternativeInRegexp(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/v1/{v1:(a|b)}"", handler)
+
+	requestA, _ := http.NewRequest(""GET"", ""/v1/a"", nil)
+	requestB, _ := http.NewRequest(""GET"", ""/v1/b"", nil)
+	for i := 0; i < b.N; i++ {
+		router.ServeHTTP(nil, requestA)
+		router.ServeHTTP(nil, requestB)
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=f48927253fa183f81eda684da508ba9226b87e9f,https://github.com/gorilla/mux/blob/f48927253fa183f81eda684da508ba9226b87e9f/bench_test.go
f48927253fa183f81eda684da508ba9226b87e9f,3c3a31bfa7ea0b0555e5ea855ffadf08fa6c4e70,regexp.go,,"Sat, 23 Jan 2016 16:42:00 GMT",modified,31,34,65,"@@ -73,14 +73,17 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		varIdx := i / 2
-		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), varGroupName(varIdx), patt)
+		if patt[0] == '(' && patt[len(patt)-1] == ')' {
+			fmt.Fprintf(pattern, ""%s%s"", regexp.QuoteMeta(raw), patt)
+		} else {
+			fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
+		}
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 
 		// Append variable name and compiled pattern.
-		varsN[varIdx] = name
-		varsR[varIdx], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
+		varsN[i/2] = name
+		varsR[i/2], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
 		if err != nil {
 			return nil, err
 		}
@@ -246,30 +249,17 @@ type routeRegexpGroup struct {
 func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
-		hostVars := v.host.regexp.FindStringSubmatch(getHost(req))
-		if hostVars != nil {
-			subexpNames := v.host.regexp.SubexpNames()
-			varName := 0
-			for i, name := range subexpNames[1:] {
-				if name != """" && name == varGroupName(varName) {
-					m.Vars[v.host.varsN[varName]] = hostVars[i+1]
-					varName++
-				}
-			}
+		host := getHost(req)
+		matches := v.host.regexp.FindStringSubmatchIndex(host)
+		if len(matches) > 0 {
+			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
 	// Store path variables.
 	if v.path != nil {
-		pathVars := v.path.regexp.FindStringSubmatch(req.URL.Path)
-		if pathVars != nil {
-			subexpNames := v.path.regexp.SubexpNames()
-			varName := 0
-			for i, name := range subexpNames[1:] {
-				if name != """" && name == varGroupName(varName) {
-					m.Vars[v.path.varsN[varName]] = pathVars[i+1]
-					varName++
-				}
-			}
+		matches := v.path.regexp.FindStringSubmatchIndex(req.URL.Path)
+		if len(matches) > 0 {
+			extractVars(req.URL.Path, matches, v.path.varsN, m.Vars)
 			// Check if we should redirect.
 			if v.path.strictSlash {
 				p1 := strings.HasSuffix(req.URL.Path, ""/"")
@@ -288,16 +278,10 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	}
 	// Store query string variables.
 	for _, q := range v.queries {
-		queryVars := q.regexp.FindStringSubmatch(q.getUrlQuery(req))
-		if queryVars != nil {
-			subexpNames := q.regexp.SubexpNames()
-			varName := 0
-			for i, name := range subexpNames[1:] {
-				if name != """" && name == varGroupName(varName) {
-					m.Vars[q.varsN[varName]] = queryVars[i+1]
-					varName++
-				}
-			}
+		queryUrl := q.getUrlQuery(req)
+		matches := q.regexp.FindStringSubmatchIndex(queryUrl)
+		if len(matches) > 0 {
+			extractVars(queryUrl, matches, q.varsN, m.Vars)
 		}
 	}
 }
@@ -315,3 +299,16 @@ func getHost(r *http.Request) string {
 	return host
 
 }
+
+func extractVars(input string, matches []int, names []string, output map[string]string) {
+	matchesCount := 0
+	prevEnd := -1
+	for i := 2; i < len(matches) && matchesCount < len(names); i += 2 {
+		if prevEnd < matches[i+1] {
+			value := input[matches[i]:matches[i+1]]
+			output[names[matchesCount]] = value
+			prevEnd = matches[i+1]
+			matchesCount++
+		}
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=f48927253fa183f81eda684da508ba9226b87e9f,https://github.com/gorilla/mux/blob/f48927253fa183f81eda684da508ba9226b87e9f/regexp.go
26a6070f849969ba72b72256e9f14cf519751690,b987c9e5d10e5534287261323af124a6e2653c16,README.md,,"Thu, 31 Dec 2015 16:19:08 GMT",modified,144,139,283,"@@ -1,211 +1,216 @@
 mux
 ===
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
-[![Build Status](https://travis-ci.org/gorilla/mux.png?branch=master)](https://travis-ci.org/gorilla/mux)
-
-Package gorilla/mux implements a request router and dispatcher.
-
-The name mux stands for ""HTTP request multiplexer"". Like the standard
-http.ServeMux, mux.Router matches incoming requests against a list of
-registered routes and calls a handler for the route that matches the URL
-or other conditions. The main features are:
-
-	* Requests can be matched based on URL host, path, path prefix, schemes,
-	  header and query values, HTTP methods or using custom matchers.
-	* URL hosts and paths can have variables with an optional regular
-	  expression.
-	* Registered URLs can be built, or ""reversed"", which helps maintaining
-	  references to resources.
-	* Routes can be used as subrouters: nested routes are only tested if the
-	  parent route matches. This is useful to define groups of routes that
-	  share common conditions like a host, a path prefix or other repeated
-	  attributes. As a bonus, this optimizes request matching.
-	* It implements the http.Handler interface so it is compatible with the
-	  standard http.ServeMux.
+[![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
 
-Let's start registering a couple of URL paths and handlers:
+Package `gorilla/mux` implements a request router and dispatcher.
 
-	func main() {
-		r := mux.NewRouter()
-		r.HandleFunc(""/"", HomeHandler)
-		r.HandleFunc(""/products"", ProductsHandler)
-		r.HandleFunc(""/articles"", ArticlesHandler)
-		http.Handle(""/"", r)
-	}
+The name mux stands for ""HTTP request multiplexer"". Like the standard `http.ServeMux`, `mux.Router` matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:
 
-Here we register three routes mapping URL paths to handlers. This is
-equivalent to how http.HandleFunc() works: if an incoming request URL matches
-one of the paths, the corresponding handler is called passing
-(http.ResponseWriter, *http.Request) as parameters.
+* Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers.
+* URL hosts and paths can have variables with an optional regular expression.
+* Registered URLs can be built, or ""reversed"", which helps maintaining references to resources.
+* Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching.
+* It implements the `http.Handler` interface so it is compatible with the standard `http.ServeMux`.
 
-Paths can have variables. They are defined using the format {name} or
-{name:pattern}. If a regular expression pattern is not defined, the matched
-variable will be anything until the next slash. For example:
+Let's start registering a couple of URL paths and handlers:
 
+```go
+func main() {
 	r := mux.NewRouter()
-	r.HandleFunc(""/products/{key}"", ProductHandler)
-	r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
-	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
+	r.HandleFunc(""/"", HomeHandler)
+	r.HandleFunc(""/products"", ProductsHandler)
+	r.HandleFunc(""/articles"", ArticlesHandler)
+	http.Handle(""/"", r)
+}
+```
 
-The names are used to create a map of route variables which can be retrieved
-calling mux.Vars():
+Here we register three routes mapping URL paths to handlers. This is equivalent to how `http.HandleFunc()` works: if an incoming request URL matches one of the paths, the corresponding handler is called passing (`http.ResponseWriter`, `*http.Request`) as parameters.
 
-	vars := mux.Vars(request)
-	category := vars[""category""]
+Paths can have variables. They are defined using the format `{name}` or `{name:pattern}`. If a regular expression pattern is not defined, the matched variable will be anything until the next slash. For example:
 
-And this is all you need to know about the basic usage. More advanced options
-are explained below.
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/products/{key}"", ProductHandler)
+r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
+r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
+```
 
-Routes can also be restricted to a domain or subdomain. Just define a host
-pattern to be matched. They can also have variables:
+The names are used to create a map of route variables which can be retrieved calling `mux.Vars()`:
 
-	r := mux.NewRouter()
-	// Only matches if domain is ""www.example.com"".
-	r.Host(""www.example.com"")
-	// Matches a dynamic subdomain.
-	r.Host(""{subdomain:[a-z]+}.domain.com"")
+```go
+vars := mux.Vars(request)
+category := vars[""category""]
+```
+
+And this is all you need to know about the basic usage. More advanced options are explained below.
+
+Routes can also be restricted to a domain or subdomain. Just define a host pattern to be matched. They can also have variables:
+
+```go
+r := mux.NewRouter()
+// Only matches if domain is ""www.example.com"".
+r.Host(""www.example.com"")
+// Matches a dynamic subdomain.
+r.Host(""{subdomain:[a-z]+}.domain.com"")
+```
 
 There are several other matchers that can be added. To match path prefixes:
 
-	r.PathPrefix(""/products/"")
+```go
+r.PathPrefix(""/products/"")
+```
 
 ...or HTTP methods:
 
-	r.Methods(""GET"", ""POST"")
+```go
+r.Methods(""GET"", ""POST"")
+```
 
 ...or URL schemes:
 
-	r.Schemes(""https"")
+```go
+r.Schemes(""https"")
+```
 
 ...or header values:
 
-	r.Headers(""X-Requested-With"", ""XMLHttpRequest"")
+```go
+r.Headers(""X-Requested-With"", ""XMLHttpRequest"")
+```
 
 ...or query values:
 
-	r.Queries(""key"", ""value"")
+```go
+r.Queries(""key"", ""value"")
+```
 
 ...or to use a custom matcher function:
 
-	r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
-		return r.ProtoMajor == 0
-	})
+```go
+r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
+	return r.ProtoMajor == 0
+})
+```
 
 ...and finally, it is possible to combine several matchers in a single route:
 
-	r.HandleFunc(""/products"", ProductsHandler).
-	  Host(""www.example.com"").
-	  Methods(""GET"").
-	  Schemes(""http"")
+```go
+r.HandleFunc(""/products"", ProductsHandler).
+  Host(""www.example.com"").
+  Methods(""GET"").
+  Schemes(""http"")
+```
 
-Setting the same matching conditions again and again can be boring, so we have
-a way to group several routes that share the same requirements.
-We call it ""subrouting"".
+Setting the same matching conditions again and again can be boring, so we have a way to group several routes that share the same requirements. We call it ""subrouting"".
 
-For example, let's say we have several URLs that should only match when the
-host is `www.example.com`. Create a route for that host and get a ""subrouter""
-from it:
+For example, let's say we have several URLs that should only match when the host is `www.example.com`. Create a route for that host and get a ""subrouter"" from it:
 
-	r := mux.NewRouter()
-	s := r.Host(""www.example.com"").Subrouter()
+```go
+r := mux.NewRouter()
+s := r.Host(""www.example.com"").Subrouter()
+```
 
 Then register routes in the subrouter:
 
-	s.HandleFunc(""/products/"", ProductsHandler)
-	s.HandleFunc(""/products/{key}"", ProductHandler)
-	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+```go
+s.HandleFunc(""/products/"", ProductsHandler)
+s.HandleFunc(""/products/{key}"", ProductHandler)
+s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+```
 
-The three URL paths we registered above will only be tested if the domain is
-`www.example.com`, because the subrouter is tested first. This is not
-only convenient, but also optimizes request matching. You can create
-subrouters combining any attribute matchers accepted by a route.
+The three URL paths we registered above will only be tested if the domain is `www.example.com`, because the subrouter is tested first. This is not only convenient, but also optimizes request matching. You can create subrouters combining any attribute matchers accepted by a route.
 
-Subrouters can be used to create domain or path ""namespaces"": you define
-subrouters in a central place and then parts of the app can register its
-paths relatively to a given subrouter.
+Subrouters can be used to create domain or path ""namespaces"": you define subrouters in a central place and then parts of the app can register its paths relatively to a given subrouter.
 
-There's one more thing about subroutes. When a subrouter has a path prefix,
-the inner routes use it as base for their paths:
+There's one more thing about subroutes. When a subrouter has a path prefix, the inner routes use it as base for their paths:
 
-	r := mux.NewRouter()
-	s := r.PathPrefix(""/products"").Subrouter()
-	// ""/products/""
-	s.HandleFunc(""/"", ProductsHandler)
-	// ""/products/{key}/""
-	s.HandleFunc(""/{key}/"", ProductHandler)
-	// ""/products/{key}/details""
-	s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
+```go
+r := mux.NewRouter()
+s := r.PathPrefix(""/products"").Subrouter()
+// ""/products/""
+s.HandleFunc(""/"", ProductsHandler)
+// ""/products/{key}/""
+s.HandleFunc(""/{key}/"", ProductHandler)
+// ""/products/{key}/details""
+s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
+```
 
 Now let's see how to build registered URLs.
 
-Routes can be named. All routes that define a name can have their URLs built,
-or ""reversed"". We define a name calling Name() on a route. For example:
+Routes can be named. All routes that define a name can have their URLs built, or ""reversed"". We define a name calling `Name()` on a route. For example:
 
-	r := mux.NewRouter()
-	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
-	  Name(""article"")
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+  Name(""article"")
+```
 
-To build a URL, get the route and call the URL() method, passing a sequence of
-key/value pairs for the route variables. For the previous route, we would do:
+To build a URL, get the route and call the `URL()` method, passing a sequence of key/value pairs for the route variables. For the previous route, we would do:
 
-	url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+```go
+url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+```
 
-...and the result will be a url.URL with the following path:
+...and the result will be a `url.URL` with the following path:
 
-	""/articles/technology/42""
+```
+""/articles/technology/42""
+```
 
 This also works for host variables:
 
-	r := mux.NewRouter()
-	r.Host(""{subdomain}.domain.com"").
-	  Path(""/articles/{category}/{id:[0-9]+}"").
-	  HandlerFunc(ArticleHandler).
-	  Name(""article"")
-
-	// url.String() will be ""http://news.domain.com/articles/technology/42""
-	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-	                                 ""category"", ""technology"",
-	                                 ""id"", ""42"")
+```go
+r := mux.NewRouter()
+r.Host(""{subdomain}.domain.com"").
+  Path(""/articles/{category}/{id:[0-9]+}"").
+  HandlerFunc(ArticleHandler).
+  Name(""article"")
+
+// url.String() will be ""http://news.domain.com/articles/technology/42""
+url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+                                 ""category"", ""technology"",
+                                 ""id"", ""42"")
+```
 
-All variables defined in the route are required, and their values must
-conform to the corresponding patterns. These requirements guarantee that a
-generated URL will always match a registered route -- the only exception is
-for explicitly defined ""build-only"" routes which never match.
+All variables defined in the route are required, and their values must conform to the corresponding patterns. These requirements guarantee that a generated URL will always match a registered route -- the only exception is for explicitly defined ""build-only"" routes which never match.
 
 Regex support also exists for matching Headers within a route. For example, we could do:
 
-	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
-
-...and the route will match both requests with a Content-Type of `application/json` as well as
-`application/text`
+```go
+r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
+```
 
-There's also a way to build only the URL host or path for a route:
-use the methods URLHost() or URLPath() instead. For the previous route,
-we would do:
+...and the route will match both requests with a Content-Type of `application/json` as well as `application/text`
 
-	// ""http://news.domain.com/""
-	host, err := r.Get(""article"").URLHost(""subdomain"", ""news"")
+There's also a way to build only the URL host or path for a route: use the methods `URLHost()` or `URLPath()` instead. For the previous route, we would do:
 
-	// ""/articles/technology/42""
-	path, err := r.Get(""article"").URLPath(""category"", ""technology"", ""id"", ""42"")
+```go
+// ""http://news.domain.com/""
+host, err := r.Get(""article"").URLHost(""subdomain"", ""news"")
 
-And if you use subrouters, host and path defined separately can be built
-as well:
+// ""/articles/technology/42""
+path, err := r.Get(""article"").URLPath(""category"", ""technology"", ""id"", ""42"")
+```
 
-	r := mux.NewRouter()
-	s := r.Host(""{subdomain}.domain.com"").Subrouter()
-	s.Path(""/articles/{category}/{id:[0-9]+}"").
-	  HandlerFunc(ArticleHandler).
-	  Name(""article"")
+And if you use subrouters, host and path defined separately can be built as well:
 
-	// ""http://news.domain.com/articles/technology/42""
-	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-	                                 ""category"", ""technology"",
-	                                 ""id"", ""42"")
+```go
+r := mux.NewRouter()
+s := r.Host(""{subdomain}.domain.com"").Subrouter()
+s.Path(""/articles/{category}/{id:[0-9]+}"").
+  HandlerFunc(ArticleHandler).
+  Name(""article"")
+
+// ""http://news.domain.com/articles/technology/42""
+url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+                                 ""category"", ""technology"",
+                                 ""id"", ""42"")
+```
 
 ## Full Example
 
-Here's a complete, runnable example of a small mux based server:
+Here's a complete, runnable example of a small `mux` based server:
 
 ```go
 package main",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=26a6070f849969ba72b72256e9f14cf519751690,https://github.com/gorilla/mux/blob/26a6070f849969ba72b72256e9f14cf519751690/README.md
66181ed3371dcbff358575eff5e41efc013608d8,b987c9e5d10e5534287261323af124a6e2653c16,README.md,,"Thu, 31 Dec 2015 16:12:17 GMT",modified,144,139,283,"@@ -1,211 +1,216 @@
 mux
 ===
 [![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
-[![Build Status](https://travis-ci.org/gorilla/mux.png?branch=master)](https://travis-ci.org/gorilla/mux)
-
-Package gorilla/mux implements a request router and dispatcher.
-
-The name mux stands for ""HTTP request multiplexer"". Like the standard
-http.ServeMux, mux.Router matches incoming requests against a list of
-registered routes and calls a handler for the route that matches the URL
-or other conditions. The main features are:
-
-	* Requests can be matched based on URL host, path, path prefix, schemes,
-	  header and query values, HTTP methods or using custom matchers.
-	* URL hosts and paths can have variables with an optional regular
-	  expression.
-	* Registered URLs can be built, or ""reversed"", which helps maintaining
-	  references to resources.
-	* Routes can be used as subrouters: nested routes are only tested if the
-	  parent route matches. This is useful to define groups of routes that
-	  share common conditions like a host, a path prefix or other repeated
-	  attributes. As a bonus, this optimizes request matching.
-	* It implements the http.Handler interface so it is compatible with the
-	  standard http.ServeMux.
+[![Build Status](https://travis-ci.org/gorilla/mux.svg?branch=master)](https://travis-ci.org/gorilla/mux)
 
-Let's start registering a couple of URL paths and handlers:
+Package `gorilla/mux` implements a request router and dispatcher.
 
-	func main() {
-		r := mux.NewRouter()
-		r.HandleFunc(""/"", HomeHandler)
-		r.HandleFunc(""/products"", ProductsHandler)
-		r.HandleFunc(""/articles"", ArticlesHandler)
-		http.Handle(""/"", r)
-	}
+The name mux stands for ""HTTP request multiplexer"". Like the standard `http.ServeMux`, `mux.Router` matches incoming requests against a list of registered routes and calls a handler for the route that matches the URL or other conditions. The main features are:
 
-Here we register three routes mapping URL paths to handlers. This is
-equivalent to how http.HandleFunc() works: if an incoming request URL matches
-one of the paths, the corresponding handler is called passing
-(http.ResponseWriter, *http.Request) as parameters.
+* Requests can be matched based on URL host, path, path prefix, schemes, header and query values, HTTP methods or using custom matchers.
+* URL hosts and paths can have variables with an optional regular expression.
+* Registered URLs can be built, or ""reversed"", which helps maintaining references to resources.
+* Routes can be used as subrouters: nested routes are only tested if the parent route matches. This is useful to define groups of routes that share common conditions like a host, a path prefix or other repeated attributes. As a bonus, this optimizes request matching.
+* It implements the `http.Handler` interface so it is compatible with the standard `http.ServeMux`.
 
-Paths can have variables. They are defined using the format {name} or
-{name:pattern}. If a regular expression pattern is not defined, the matched
-variable will be anything until the next slash. For example:
+Let's start registering a couple of URL paths and handlers:
 
+```go
+func main() {
 	r := mux.NewRouter()
-	r.HandleFunc(""/products/{key}"", ProductHandler)
-	r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
-	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
+	r.HandleFunc(""/"", HomeHandler)
+	r.HandleFunc(""/products"", ProductsHandler)
+	r.HandleFunc(""/articles"", ArticlesHandler)
+	http.Handle(""/"", r)
+}
+```
 
-The names are used to create a map of route variables which can be retrieved
-calling mux.Vars():
+Here we register three routes mapping URL paths to handlers. This is equivalent to how `http.HandleFunc()` works: if an incoming request URL matches one of the paths, the corresponding handler is called passing (`http.ResponseWriter`, `*http.Request`) as parameters.
 
-	vars := mux.Vars(request)
-	category := vars[""category""]
+Paths can have variables. They are defined using the format `{name}` or `{name:pattern}`. If a regular expression pattern is not defined, the matched variable will be anything until the next slash. For example:
 
-And this is all you need to know about the basic usage. More advanced options
-are explained below.
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/products/{key}"", ProductHandler)
+r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
+r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
+```
 
-Routes can also be restricted to a domain or subdomain. Just define a host
-pattern to be matched. They can also have variables:
+The names are used to create a map of route variables which can be retrieved calling `mux.Vars()`:
 
-	r := mux.NewRouter()
-	// Only matches if domain is ""www.example.com"".
-	r.Host(""www.example.com"")
-	// Matches a dynamic subdomain.
-	r.Host(""{subdomain:[a-z]+}.domain.com"")
+```go
+vars := mux.Vars(request)
+category := vars[""category""]
+```
+
+And this is all you need to know about the basic usage. More advanced options are explained below.
+
+Routes can also be restricted to a domain or subdomain. Just define a host pattern to be matched. They can also have variables:
+
+```go
+r := mux.NewRouter()
+// Only matches if domain is ""www.example.com"".
+r.Host(""www.example.com"")
+// Matches a dynamic subdomain.
+r.Host(""{subdomain:[a-z]+}.domain.com"")
+```
 
 There are several other matchers that can be added. To match path prefixes:
 
-	r.PathPrefix(""/products/"")
+```go
+r.PathPrefix(""/products/"")
+```
 
 ...or HTTP methods:
 
-	r.Methods(""GET"", ""POST"")
+```go
+r.Methods(""GET"", ""POST"")
+```
 
 ...or URL schemes:
 
-	r.Schemes(""https"")
+```go
+r.Schemes(""https"")
+```
 
 ...or header values:
 
-	r.Headers(""X-Requested-With"", ""XMLHttpRequest"")
+```go
+r.Headers(""X-Requested-With"", ""XMLHttpRequest"")
+```
 
 ...or query values:
 
-	r.Queries(""key"", ""value"")
+```go
+r.Queries(""key"", ""value"")
+```
 
 ...or to use a custom matcher function:
 
-	r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
-		return r.ProtoMajor == 0
-	})
+```go
+r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
+	return r.ProtoMajor == 0
+})
+```
 
 ...and finally, it is possible to combine several matchers in a single route:
 
-	r.HandleFunc(""/products"", ProductsHandler).
-	  Host(""www.example.com"").
-	  Methods(""GET"").
-	  Schemes(""http"")
+```go
+r.HandleFunc(""/products"", ProductsHandler).
+  Host(""www.example.com"").
+  Methods(""GET"").
+  Schemes(""http"")
+```
 
-Setting the same matching conditions again and again can be boring, so we have
-a way to group several routes that share the same requirements.
-We call it ""subrouting"".
+Setting the same matching conditions again and again can be boring, so we have a way to group several routes that share the same requirements. We call it ""subrouting"".
 
-For example, let's say we have several URLs that should only match when the
-host is `www.example.com`. Create a route for that host and get a ""subrouter""
-from it:
+For example, let's say we have several URLs that should only match when the host is `www.example.com`. Create a route for that host and get a ""subrouter"" from it:
 
-	r := mux.NewRouter()
-	s := r.Host(""www.example.com"").Subrouter()
+```go
+r := mux.NewRouter()
+s := r.Host(""www.example.com"").Subrouter()
+```
 
 Then register routes in the subrouter:
 
-	s.HandleFunc(""/products/"", ProductsHandler)
-	s.HandleFunc(""/products/{key}"", ProductHandler)
-	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+```go
+s.HandleFunc(""/products/"", ProductsHandler)
+s.HandleFunc(""/products/{key}"", ProductHandler)
+s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+```
 
-The three URL paths we registered above will only be tested if the domain is
-`www.example.com`, because the subrouter is tested first. This is not
-only convenient, but also optimizes request matching. You can create
-subrouters combining any attribute matchers accepted by a route.
+The three URL paths we registered above will only be tested if the domain is `www.example.com`, because the subrouter is tested first. This is not only convenient, but also optimizes request matching. You can create subrouters combining any attribute matchers accepted by a route.
 
-Subrouters can be used to create domain or path ""namespaces"": you define
-subrouters in a central place and then parts of the app can register its
-paths relatively to a given subrouter.
+Subrouters can be used to create domain or path ""namespaces"": you define subrouters in a central place and then parts of the app can register its paths relatively to a given subrouter.
 
-There's one more thing about subroutes. When a subrouter has a path prefix,
-the inner routes use it as base for their paths:
+There's one more thing about subroutes. When a subrouter has a path prefix, the inner routes use it as base for their paths:
 
-	r := mux.NewRouter()
-	s := r.PathPrefix(""/products"").Subrouter()
-	// ""/products/""
-	s.HandleFunc(""/"", ProductsHandler)
-	// ""/products/{key}/""
-	s.HandleFunc(""/{key}/"", ProductHandler)
-	// ""/products/{key}/details""
-	s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
+```go
+r := mux.NewRouter()
+s := r.PathPrefix(""/products"").Subrouter()
+// ""/products/""
+s.HandleFunc(""/"", ProductsHandler)
+// ""/products/{key}/""
+s.HandleFunc(""/{key}/"", ProductHandler)
+// ""/products/{key}/details""
+s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
+```
 
 Now let's see how to build registered URLs.
 
-Routes can be named. All routes that define a name can have their URLs built,
-or ""reversed"". We define a name calling Name() on a route. For example:
+Routes can be named. All routes that define a name can have their URLs built, or ""reversed"". We define a name calling `Name()` on a route. For example:
 
-	r := mux.NewRouter()
-	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
-	  Name(""article"")
+```go
+r := mux.NewRouter()
+r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+  Name(""article"")
+```
 
-To build a URL, get the route and call the URL() method, passing a sequence of
-key/value pairs for the route variables. For the previous route, we would do:
+To build a URL, get the route and call the `URL()` method, passing a sequence of key/value pairs for the route variables. For the previous route, we would do:
 
-	url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+```go
+url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+```
 
-...and the result will be a url.URL with the following path:
+...and the result will be a `url.URL` with the following path:
 
-	""/articles/technology/42""
+```
+""/articles/technology/42""
+```
 
 This also works for host variables:
 
-	r := mux.NewRouter()
-	r.Host(""{subdomain}.domain.com"").
-	  Path(""/articles/{category}/{id:[0-9]+}"").
-	  HandlerFunc(ArticleHandler).
-	  Name(""article"")
-
-	// url.String() will be ""http://news.domain.com/articles/technology/42""
-	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-	                                 ""category"", ""technology"",
-	                                 ""id"", ""42"")
+```go
+r := mux.NewRouter()
+r.Host(""{subdomain}.domain.com"").
+  Path(""/articles/{category}/{id:[0-9]+}"").
+  HandlerFunc(ArticleHandler).
+  Name(""article"")
+
+// url.String() will be ""http://news.domain.com/articles/technology/42""
+url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+                                 ""category"", ""technology"",
+                                 ""id"", ""42"")
+```
 
-All variables defined in the route are required, and their values must
-conform to the corresponding patterns. These requirements guarantee that a
-generated URL will always match a registered route -- the only exception is
-for explicitly defined ""build-only"" routes which never match.
+All variables defined in the route are required, and their values must conform to the corresponding patterns. These requirements guarantee that a generated URL will always match a registered route -- the only exception is for explicitly defined ""build-only"" routes which never match.
 
 Regex support also exists for matching Headers within a route. For example, we could do:
 
-	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
-
-...and the route will match both requests with a Content-Type of `application/json` as well as
-`application/text`
+```go
+r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
+```
 
-There's also a way to build only the URL host or path for a route:
-use the methods URLHost() or URLPath() instead. For the previous route,
-we would do:
+...and the route will match both requests with a Content-Type of `application/json` as well as `application/text`
 
-	// ""http://news.domain.com/""
-	host, err := r.Get(""article"").URLHost(""subdomain"", ""news"")
+There's also a way to build only the URL host or path for a route: use the methods `URLHost()` or `URLPath()` instead. For the previous route, we would do:
 
-	// ""/articles/technology/42""
-	path, err := r.Get(""article"").URLPath(""category"", ""technology"", ""id"", ""42"")
+```go
+// ""http://news.domain.com/""
+host, err := r.Get(""article"").URLHost(""subdomain"", ""news"")
 
-And if you use subrouters, host and path defined separately can be built
-as well:
+// ""/articles/technology/42""
+path, err := r.Get(""article"").URLPath(""category"", ""technology"", ""id"", ""42"")
+```
 
-	r := mux.NewRouter()
-	s := r.Host(""{subdomain}.domain.com"").Subrouter()
-	s.Path(""/articles/{category}/{id:[0-9]+}"").
-	  HandlerFunc(ArticleHandler).
-	  Name(""article"")
+And if you use subrouters, host and path defined separately can be built as well:
 
-	// ""http://news.domain.com/articles/technology/42""
-	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-	                                 ""category"", ""technology"",
-	                                 ""id"", ""42"")
+```go
+r := mux.NewRouter()
+s := r.Host(""{subdomain}.domain.com"").Subrouter()
+s.Path(""/articles/{category}/{id:[0-9]+}"").
+  HandlerFunc(ArticleHandler).
+  Name(""article"")
+
+// ""http://news.domain.com/articles/technology/42""
+url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+                                 ""category"", ""technology"",
+                                 ""id"", ""42"")
+```
 
 ## Full Example
 
-Here's a complete, runnable example of a small mux based server:
+Here's a complete, runnable example of a small `mux` based server:
 
 ```go
 package main",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=66181ed3371dcbff358575eff5e41efc013608d8,https://github.com/gorilla/mux/blob/66181ed3371dcbff358575eff5e41efc013608d8/README.md
2aad27d3101b8183f8fa1bebdbc2cdb74fcef090,aabe9958f2097f7f19ced28d59a9592fd1274d2a,mux.go,,"Tue, 29 Dec 2015 06:32:19 GMT",modified,13,6,19,"@@ -59,6 +59,12 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 			return true
 		}
 	}
+
+	// Closest match for a router (includes sub-routers)
+	if r.NotFoundHandler != nil {
+		match.Handler = r.NotFoundHandler
+		return true
+	}
 	return false
 }
 
@@ -89,10 +95,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		setCurrentRoute(req, match.Route)
 	}
 	if handler == nil {
-		handler = r.NotFoundHandler
-		if handler == nil {
-			handler = http.NotFoundHandler()
-		}
+		handler = http.NotFoundHandler()
 	}
 	if !r.KeepContext {
 		defer context.Clear(req)
@@ -324,11 +327,15 @@ func CurrentRoute(r *http.Request) *Route {
 }
 
 func setVars(r *http.Request, val interface{}) {
-	context.Set(r, varsKey, val)
+	if val != nil {
+		context.Set(r, varsKey, val)
+	}
 }
 
 func setCurrentRoute(r *http.Request, val interface{}) {
-	context.Set(r, routeKey, val)
+	if val != nil {
+		context.Set(r, routeKey, val)
+	}
 }
 
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=2aad27d3101b8183f8fa1bebdbc2cdb74fcef090,https://github.com/gorilla/mux/blob/2aad27d3101b8183f8fa1bebdbc2cdb74fcef090/mux.go
2aad27d3101b8183f8fa1bebdbc2cdb74fcef090,1ea439ad131204ff00a7cdf985338be91a119b0b,mux_test.go,,"Tue, 29 Dec 2015 06:32:19 GMT",modified,24,0,24,"@@ -1123,6 +1123,30 @@ func TestWalkNested(t *testing.T) {
 	}
 }
 
+func TestSubrouterErrorHandling(t *testing.T) {
+	superRouterCalled := false
+	subRouterCalled := false
+
+	router := NewRouter()
+	router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		superRouterCalled = true
+	})
+	subRouter := router.PathPrefix(""/bign8"").Subrouter()
+	subRouter.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		subRouterCalled = true
+	})
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost/bign8/was/here"", nil)
+	router.ServeHTTP(NewRecorder(), req)
+
+	if superRouterCalled {
+		t.Error(""Super router 404 handler called when sub-router 404 handler is available."")
+	}
+	if !subRouterCalled {
+		t.Error(""Sub-router 404 handler was not called."")
+	}
+}
+
 // ----------------------------------------------------------------------------
 // Helpers
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=2aad27d3101b8183f8fa1bebdbc2cdb74fcef090,https://github.com/gorilla/mux/blob/2aad27d3101b8183f8fa1bebdbc2cdb74fcef090/mux_test.go
82a9c170d40582ee65ff8af081485e5e325fb4a0,1ea439ad131204ff00a7cdf985338be91a119b0b,mux_test.go,,"Sat, 26 Dec 2015 07:09:25 GMT",modified,24,0,24,"@@ -1123,6 +1123,30 @@ func TestWalkNested(t *testing.T) {
 	}
 }
 
+func TestSubrouterErrorHandling(t *testing.T) {
+	superRouterCalled := false
+	subRouterCalled := false
+
+	router := NewRouter()
+	router.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		superRouterCalled = true
+	})
+	subRouter := router.PathPrefix(""/bign8"").Subrouter()
+	subRouter.NotFoundHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
+		subRouterCalled = true
+	})
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost/bign8/was/here"", nil)
+	router.ServeHTTP(NewRecorder(), req)
+
+	if superRouterCalled {
+		t.Error(""Super router 404 handler called when sub-router 404 handler is available."")
+	}
+	if !subRouterCalled {
+		t.Error(""Sub-router 404 handler was not called."")
+	}
+}
+
 // ----------------------------------------------------------------------------
 // Helpers
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=82a9c170d40582ee65ff8af081485e5e325fb4a0,https://github.com/gorilla/mux/blob/82a9c170d40582ee65ff8af081485e5e325fb4a0/mux_test.go
c329c7d193285eb0aeac7892896766be20a84c4c,aabe9958f2097f7f19ced28d59a9592fd1274d2a,mux.go,,"Fri, 25 Dec 2015 20:18:57 GMT",modified,13,6,19,"@@ -59,6 +59,12 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 			return true
 		}
 	}
+
+	// Closest match for a router (includes sub-routers)
+	if r.NotFoundHandler != nil {
+		match.Handler = r.NotFoundHandler
+		return true
+	}
 	return false
 }
 
@@ -89,10 +95,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		setCurrentRoute(req, match.Route)
 	}
 	if handler == nil {
-		handler = r.NotFoundHandler
-		if handler == nil {
-			handler = http.NotFoundHandler()
-		}
+		handler = http.NotFoundHandler()
 	}
 	if !r.KeepContext {
 		defer context.Clear(req)
@@ -324,11 +327,15 @@ func CurrentRoute(r *http.Request) *Route {
 }
 
 func setVars(r *http.Request, val interface{}) {
-	context.Set(r, varsKey, val)
+	if val != nil {
+		context.Set(r, varsKey, val)
+	}
 }
 
 func setCurrentRoute(r *http.Request, val interface{}) {
-	context.Set(r, routeKey, val)
+	if val != nil {
+		context.Set(r, routeKey, val)
+	}
 }
 
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=c329c7d193285eb0aeac7892896766be20a84c4c,https://github.com/gorilla/mux/blob/c329c7d193285eb0aeac7892896766be20a84c4c/mux.go
9c068cf16d982f8bd444b8c352acbeec34c4fe5b,83ab8f59dd1ad992d7379ac5d3b52ccdc0d84d94,.travis.yml,,"Wed, 11 Nov 2015 10:35:30 GMT",modified,7,1,8,"@@ -1,8 +1,14 @@
 language: go
 sudo: false
-
 go:
   - 1.3
   - 1.4
   - 1.5
   - tip
+install:
+  - go get golang.org/x/tools/cmd/vet
+script:
+  - go get -t -v ./...
+  - diff -u <(echo -n) <(gofmt -d -s .)
+  - go tool vet .
+  - go test -v -race ./...",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=9c068cf16d982f8bd444b8c352acbeec34c4fe5b,https://github.com/gorilla/mux/blob/9c068cf16d982f8bd444b8c352acbeec34c4fe5b/.travis.yml
9a9f155278d9b29c53acbb38c89b3024f658b55d,83ab8f59dd1ad992d7379ac5d3b52ccdc0d84d94,.travis.yml,,"Mon, 09 Nov 2015 01:29:33 GMT",modified,7,1,8,"@@ -1,8 +1,14 @@
 language: go
 sudo: false
-
 go:
   - 1.3
   - 1.4
   - 1.5
   - tip
+install:
+  - go get golang.org/x/tools/cmd/vet
+script:
+  - go get -t -v ./...
+  - diff -u <(echo -n) <(gofmt -d -s .)
+  - go tool vet .
+  - go test -v -race ./...",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=9a9f155278d9b29c53acbb38c89b3024f658b55d,https://github.com/gorilla/mux/blob/9a9f155278d9b29c53acbb38c89b3024f658b55d/.travis.yml
48e889f422c9702f924e53b095546239a1253159,d1eae9265889bf713ba5f0ca017e735c34e3d75a,mux_test.go,,"Sun, 08 Nov 2015 05:16:49 GMT",modified,1,1,2,"@@ -1077,7 +1077,7 @@ func TestWalkSingleDepth(t *testing.T) {
 			return SkipRouter
 		}
 		if len(ancestors) != depths[i] {
-			t.Errorf(`Expected depth of %d at i = %d; got ""%s""`, depths[i], i, len(ancestors))
+			t.Errorf(`Expected depth of %d at i = %d; got ""%d""`, depths[i], i, len(ancestors))
 		}
 		if matcher.template != ""/""+paths[i] {
 			t.Errorf(`Expected ""/%s"" at i = %d; got ""%s""`, paths[i], i, matcher.template)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=48e889f422c9702f924e53b095546239a1253159,https://github.com/gorilla/mux/blob/48e889f422c9702f924e53b095546239a1253159/mux_test.go
a90bbbc6fa11b6a5c4ad95c2ab27eb51229890a5,d1eae9265889bf713ba5f0ca017e735c34e3d75a,mux_test.go,,"Sat, 07 Nov 2015 12:34:30 GMT",modified,1,1,2,"@@ -1077,7 +1077,7 @@ func TestWalkSingleDepth(t *testing.T) {
 			return SkipRouter
 		}
 		if len(ancestors) != depths[i] {
-			t.Errorf(`Expected depth of %d at i = %d; got ""%s""`, depths[i], i, len(ancestors))
+			t.Errorf(`Expected depth of %d at i = %d; got ""%d""`, depths[i], i, len(ancestors))
 		}
 		if matcher.template != ""/""+paths[i] {
 			t.Errorf(`Expected ""/%s"" at i = %d; got ""%s""`, paths[i], i, matcher.template)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a90bbbc6fa11b6a5c4ad95c2ab27eb51229890a5,https://github.com/gorilla/mux/blob/a90bbbc6fa11b6a5c4ad95c2ab27eb51229890a5/mux_test.go
ad4d7a5882b961e07e2626045eb995c022ac6664,68c4ea5d85cc0840a7949b0d28f68e6cf34e3941,mux.go,,"Sat, 03 Oct 2015 07:26:51 GMT",modified,7,2,9,"@@ -70,7 +70,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	// Clean path to canonical form and redirect.
 	if p := cleanPath(req.URL.Path); p != req.URL.Path {
 
-		// Added 3 lines (Philip Schlump) - It was droping the query string and #whatever from query.
+		// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
 		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
 		// http://code.google.com/p/go/issues/detail?id=5252
 		url := *req.URL
@@ -365,6 +365,8 @@ func uniqueVars(s1, s2 []string) error {
 	return nil
 }
 
+// checkPairs returns the count of strings passed in, and an error if
+// the count is not an even number.
 func checkPairs(pairs ...string) (int, error) {
 	length := len(pairs)
 	if length%2 != 0 {
@@ -374,7 +376,8 @@ func checkPairs(pairs ...string) (int, error) {
 	return length, nil
 }
 
-// mapFromPairs converts variadic string parameters to a string map.
+// mapFromPairsToString converts variadic string parameters to a
+// string to string map.
 func mapFromPairsToString(pairs ...string) (map[string]string, error) {
 	length, err := checkPairs(pairs...)
 	if err != nil {
@@ -387,6 +390,8 @@ func mapFromPairsToString(pairs ...string) (map[string]string, error) {
 	return m, nil
 }
 
+// mapFromPairsToRegex converts variadic string paramers to a
+// string to regex map.
 func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
 	length, err := checkPairs(pairs...)
 	if err != nil {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=ad4d7a5882b961e07e2626045eb995c022ac6664,https://github.com/gorilla/mux/blob/ad4d7a5882b961e07e2626045eb995c022ac6664/mux.go
ac3897eae3767628df9a43b55c53fca226870a27,68c4ea5d85cc0840a7949b0d28f68e6cf34e3941,mux.go,,"Sat, 03 Oct 2015 07:21:00 GMT",modified,7,2,9,"@@ -70,7 +70,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	// Clean path to canonical form and redirect.
 	if p := cleanPath(req.URL.Path); p != req.URL.Path {
 
-		// Added 3 lines (Philip Schlump) - It was droping the query string and #whatever from query.
+		// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
 		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
 		// http://code.google.com/p/go/issues/detail?id=5252
 		url := *req.URL
@@ -365,6 +365,8 @@ func uniqueVars(s1, s2 []string) error {
 	return nil
 }
 
+// checkPairs returns the count of strings passed in, and an error if
+// the count is not an even number.
 func checkPairs(pairs ...string) (int, error) {
 	length := len(pairs)
 	if length%2 != 0 {
@@ -374,7 +376,8 @@ func checkPairs(pairs ...string) (int, error) {
 	return length, nil
 }
 
-// mapFromPairs converts variadic string parameters to a string map.
+// mapFromPairsToString converts variadic string parameters to a
+// string to string map.
 func mapFromPairsToString(pairs ...string) (map[string]string, error) {
 	length, err := checkPairs(pairs...)
 	if err != nil {
@@ -387,6 +390,8 @@ func mapFromPairsToString(pairs ...string) (map[string]string, error) {
 	return m, nil
 }
 
+// mapFromPairsToRegex converts variadic string paramers to a
+// string to regex map.
 func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
 	length, err := checkPairs(pairs...)
 	if err != nil {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=ac3897eae3767628df9a43b55c53fca226870a27,https://github.com/gorilla/mux/blob/ac3897eae3767628df9a43b55c53fca226870a27/mux.go
49c024275504f0341e5a9971eb7ba7fa3dc7af40,913432c1c0d1c2581aa858785c52d155ccd384bf,route.go,,"Tue, 08 Sep 2015 16:58:39 GMT",modified,1,9,10,"@@ -200,15 +200,7 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 //               ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both request header values match.
-// Alternatively, you can provide a regular expression and match the header as follows:
-//
-//     r.Headers(""Content-Type"", ""application/(text|json)"",
-//               ""X-Requested-With"", ""XMLHttpRequest"")
-//
-// The above route will the same as the previous example, with the addition of matching
-// application/text as well.
-//
-// It the value is an empty string, it will match any value if the key is set.
+// If the value is an empty string, it will match any value if the key is set.
 func (r *Route) Headers(pairs ...string) *Route {
 	if r.err == nil {
 		var headers map[string]string",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=49c024275504f0341e5a9971eb7ba7fa3dc7af40,https://github.com/gorilla/mux/blob/49c024275504f0341e5a9971eb7ba7fa3dc7af40/route.go
8ae7a23e03967d170fbd699eaf8e55883b99e94b,24fd97508dc076866205928d96f9fea5855847c7,route.go,,"Tue, 08 Sep 2015 11:31:30 GMT",modified,1,9,10,"@@ -200,15 +200,7 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 //               ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both request header values match.
-// Alternatively, you can provide a regular expression and match the header as follows:
-//
-//     r.Headers(""Content-Type"", ""application/(text|json)"",
-//               ""X-Requested-With"", ""XMLHttpRequest"")
-//
-// The above route will the same as the previous example, with the addition of matching
-// application/text as well.
-//
-// It the value is an empty string, it will match any value if the key is set.
+// If the value is an empty string, it will match any value if the key is set.
 func (r *Route) Headers(pairs ...string) *Route {
 	if r.err == nil {
 		var headers map[string]string",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=8ae7a23e03967d170fbd699eaf8e55883b99e94b,https://github.com/gorilla/mux/blob/8ae7a23e03967d170fbd699eaf8e55883b99e94b/route.go
ee1815431e497d3850809578c93ab6705f1a19f7,f983b60c62bdf29df9c335b061f056fdae9d1f3d,.travis.yml,,"Thu, 20 Aug 2015 05:15:06 GMT",modified,2,0,2,"@@ -1,6 +1,8 @@
 language: go
+sudo: false
 
 go:
   - 1.3
   - 1.4
+  - 1.5
   - tip",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=ee1815431e497d3850809578c93ab6705f1a19f7,https://github.com/gorilla/mux/blob/ee1815431e497d3850809578c93ab6705f1a19f7/.travis.yml
f8220e087da2fc83d083bfc0289ed7f9db3536bd,245a2f517f3e6dfdd02819df270f9a2de346ebd7,.travis.yml,,"Sun, 16 Aug 2015 07:31:34 GMT",modified,2,3,5,"@@ -1,7 +1,6 @@
 language: go
 
 go:
-  - 1.0
-  - 1.1
-  - 1.2
+  - 1.3
+  - 1.4
   - tip",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=f8220e087da2fc83d083bfc0289ed7f9db3536bd,https://github.com/gorilla/mux/blob/f8220e087da2fc83d083bfc0289ed7f9db3536bd/.travis.yml
f7b6aaaa69e39a15e1f94389b8effd3f9338b013,55dd4e59a5a2c08263cc1ceb9a27f3674643e9ae,README.md,,"Fri, 14 Aug 2015 14:29:16 GMT",modified,1,1,2,"@@ -1,6 +1,6 @@
 mux
 ===
-[![GoDoc](https://godoc.org/github.com/gorilla/securecookie?status.svg)](https://godoc.org/github.com/gorilla/securecookie)
+[![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.png?branch=master)](https://travis-ci.org/gorilla/mux)
 
 Package gorilla/mux implements a request router and dispatcher.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=f7b6aaaa69e39a15e1f94389b8effd3f9338b013,https://github.com/gorilla/mux/blob/f7b6aaaa69e39a15e1f94389b8effd3f9338b013/README.md
e45852e5374d4b40feb756a967c21a758fca25b1,55dd4e59a5a2c08263cc1ceb9a27f3674643e9ae,README.md,,"Fri, 14 Aug 2015 14:25:16 GMT",modified,1,1,2,"@@ -1,6 +1,6 @@
 mux
 ===
-[![GoDoc](https://godoc.org/github.com/gorilla/securecookie?status.svg)](https://godoc.org/github.com/gorilla/securecookie)
+[![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
 [![Build Status](https://travis-ci.org/gorilla/mux.png?branch=master)](https://travis-ci.org/gorilla/mux)
 
 Package gorilla/mux implements a request router and dispatcher.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=e45852e5374d4b40feb756a967c21a758fca25b1,https://github.com/gorilla/mux/blob/e45852e5374d4b40feb756a967c21a758fca25b1/README.md
b0b2bc47bcd1442dfc76e58ab649dea056461ac9,9a046ff97faa64e904f753c034d6dc6c9aad1406,README.md,,"Thu, 13 Aug 2015 19:01:04 GMT",modified,6,6,12,"@@ -60,8 +60,8 @@ Routes can also be restricted to a domain or subdomain. Just define a host
 pattern to be matched. They can also have variables:
 
 	r := mux.NewRouter()
-	// Only matches if domain is ""www.domain.com"".
-	r.Host(""www.domain.com"")
+	// Only matches if domain is ""www.example.com"".
+	r.Host(""www.example.com"")
 	// Matches a dynamic subdomain.
 	r.Host(""{subdomain:[a-z]+}.domain.com"")
 
@@ -94,7 +94,7 @@ There are several other matchers that can be added. To match path prefixes:
 ...and finally, it is possible to combine several matchers in a single route:
 
 	r.HandleFunc(""/products"", ProductsHandler).
-	  Host(""www.domain.com"").
+	  Host(""www.example.com"").
 	  Methods(""GET"").
 	  Schemes(""http"")
 
@@ -103,11 +103,11 @@ a way to group several routes that share the same requirements.
 We call it ""subrouting"".
 
 For example, let's say we have several URLs that should only match when the
-host is ""www.domain.com"". Create a route for that host and get a ""subrouter""
+host is `www.example.com`. Create a route for that host and get a ""subrouter""
 from it:
 
 	r := mux.NewRouter()
-	s := r.Host(""www.domain.com"").Subrouter()
+	s := r.Host(""www.example.com"").Subrouter()
 
 Then register routes in the subrouter:
 
@@ -116,7 +116,7 @@ Then register routes in the subrouter:
 	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
 
 The three URL paths we registered above will only be tested if the domain is
-""www.domain.com"", because the subrouter is tested first. This is not
+`www.example.com`, because the subrouter is tested first. This is not
 only convenient, but also optimizes request matching. You can create
 subrouters combining any attribute matchers accepted by a route.
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=b0b2bc47bcd1442dfc76e58ab649dea056461ac9,https://github.com/gorilla/mux/blob/b0b2bc47bcd1442dfc76e58ab649dea056461ac9/README.md
b0b2bc47bcd1442dfc76e58ab649dea056461ac9,49798cb5cf5291db6bc3eee2ad4d168c647b4166,doc.go,,"Thu, 13 Aug 2015 19:01:04 GMT",modified,6,6,12,"@@ -60,8 +60,8 @@ Routes can also be restricted to a domain or subdomain. Just define a host
 pattern to be matched. They can also have variables:
 
 	r := mux.NewRouter()
-	// Only matches if domain is ""www.domain.com"".
-	r.Host(""www.domain.com"")
+	// Only matches if domain is ""www.example.com"".
+	r.Host(""www.example.com"")
 	// Matches a dynamic subdomain.
 	r.Host(""{subdomain:[a-z]+}.domain.com"")
 
@@ -94,7 +94,7 @@ There are several other matchers that can be added. To match path prefixes:
 ...and finally, it is possible to combine several matchers in a single route:
 
 	r.HandleFunc(""/products"", ProductsHandler).
-	  Host(""www.domain.com"").
+	  Host(""www.example.com"").
 	  Methods(""GET"").
 	  Schemes(""http"")
 
@@ -103,11 +103,11 @@ a way to group several routes that share the same requirements.
 We call it ""subrouting"".
 
 For example, let's say we have several URLs that should only match when the
-host is ""www.domain.com"". Create a route for that host and get a ""subrouter""
+host is ""www.example.com"". Create a route for that host and get a ""subrouter""
 from it:
 
 	r := mux.NewRouter()
-	s := r.Host(""www.domain.com"").Subrouter()
+	s := r.Host(""www.example.com"").Subrouter()
 
 Then register routes in the subrouter:
 
@@ -116,7 +116,7 @@ Then register routes in the subrouter:
 	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
 
 The three URL paths we registered above will only be tested if the domain is
-""www.domain.com"", because the subrouter is tested first. This is not
+""www.example.com"", because the subrouter is tested first. This is not
 only convenient, but also optimizes request matching. You can create
 subrouters combining any attribute matchers accepted by a route.
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=b0b2bc47bcd1442dfc76e58ab649dea056461ac9,https://github.com/gorilla/mux/blob/b0b2bc47bcd1442dfc76e58ab649dea056461ac9/doc.go
b0b2bc47bcd1442dfc76e58ab649dea056461ac9,755db483e8f387040c98487c9e577e20703eaa51,old_test.go,,"Thu, 13 Aug 2015 19:01:04 GMT",modified,3,3,6,"@@ -545,7 +545,7 @@ func TestMatchedRouteName(t *testing.T) {
 	router := NewRouter()
 	route := router.NewRoute().Path(""/products/"").Name(routeName)
 
-	url := ""http://www.domain.com/products/""
+	url := ""http://www.example.com/products/""
 	request, _ := http.NewRequest(""GET"", url, nil)
 	var rv RouteMatch
 	ok := router.Match(request, &rv)
@@ -563,10 +563,10 @@ func TestMatchedRouteName(t *testing.T) {
 func TestSubRouting(t *testing.T) {
 	// Example from docs.
 	router := NewRouter()
-	subrouter := router.NewRoute().Host(""www.domain.com"").Subrouter()
+	subrouter := router.NewRoute().Host(""www.example.com"").Subrouter()
 	route := subrouter.NewRoute().Path(""/products/"").Name(""products"")
 
-	url := ""http://www.domain.com/products/""
+	url := ""http://www.example.com/products/""
 	request, _ := http.NewRequest(""GET"", url, nil)
 	var rv RouteMatch
 	ok := router.Match(request, &rv)",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=b0b2bc47bcd1442dfc76e58ab649dea056461ac9,https://github.com/gorilla/mux/blob/b0b2bc47bcd1442dfc76e58ab649dea056461ac9/old_test.go
b0b2bc47bcd1442dfc76e58ab649dea056461ac9,890130460c9c0726739a0b9668a0821b31c174d0,route.go,,"Thu, 13 Aug 2015 19:01:04 GMT",modified,2,2,4,"@@ -255,7 +255,7 @@ func (r *Route) HeadersRegexp(pairs ...string) *Route {
 // For example:
 //
 //     r := mux.NewRouter()
-//     r.Host(""www.domain.com"")
+//     r.Host(""www.example.com"")
 //     r.Host(""{subdomain}.domain.com"")
 //     r.Host(""{subdomain:[a-z]+}.domain.com"")
 //
@@ -414,7 +414,7 @@ func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
 // It will test the inner routes only if the parent route matched. For example:
 //
 //     r := mux.NewRouter()
-//     s := r.Host(""www.domain.com"").Subrouter()
+//     s := r.Host(""www.example.com"").Subrouter()
 //     s.HandleFunc(""/products/"", ProductsHandler)
 //     s.HandleFunc(""/products/{key}"", ProductHandler)
 //     s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=b0b2bc47bcd1442dfc76e58ab649dea056461ac9,https://github.com/gorilla/mux/blob/b0b2bc47bcd1442dfc76e58ab649dea056461ac9/route.go
5112c33f3a6ef694c1e5784b68981f08b3f0327c,5732d2da345a4fc567648da363155077fa896f77,mux_test.go,,"Wed, 12 Aug 2015 05:16:39 GMT",modified,13,0,13,"@@ -7,11 +7,24 @@ package mux
 import (
 	""fmt""
 	""net/http""
+	""strings""
 	""testing""
 
 	""github.com/gorilla/context""
 )
 
+func (r *Route) GoString() string {
+	matchers := make([]string, len(r.matchers))
+	for i, m := range r.matchers {
+		matchers[i] = fmt.Sprintf(""%#v"", m)
+	}
+	return fmt.Sprintf(""&Route{matchers:[]matcher{%s}}"", strings.Join(matchers, "", ""))
+}
+
+func (r *routeRegexp) GoString() string {
+	return fmt.Sprintf(""&routeRegexp{template: %q, matchHost: %t, matchQuery: %t, strictSlash: %t, regexp: regexp.MustCompile(%q), reverse: %q, varsN: %v, varsR: %v"", r.template, r.matchHost, r.matchQuery, r.strictSlash, r.regexp.String(), r.reverse, r.varsN, r.varsR)
+}
+
 type routeTest struct {
 	title          string            // title of the test
 	route          *Route            // the route being tested",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=5112c33f3a6ef694c1e5784b68981f08b3f0327c,https://github.com/gorilla/mux/blob/5112c33f3a6ef694c1e5784b68981f08b3f0327c/mux_test.go
e330fd08a314ab270035e000f1543d1af53f6812,7a0bc9e441f2de1e9a9b8e8e67cd41b40ed91980,mux_test.go,,"Tue, 11 Aug 2015 05:40:28 GMT",modified,90,0,90,"@@ -144,6 +144,33 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Host route with hyphenated name and pattern, match"",
+			route:       new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with hyphenated name and pattern, additional capturing group, match"",
+			route:       new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with multiple hyphenated names and patterns, match"",
+			route:       new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Path route with single pattern with pipe, match"",
 			route:       new(Route).Path(""/{category:a|b/c}""),
@@ -278,6 +305,33 @@ func TestPath(t *testing.T) {
 			path:        ""/a/product_name/1"",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Path route with hyphenated name and pattern, match"",
+			route:       new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v-1"": ""222""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple hyphenated names and patterns, match"",
+			route:       new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple hyphenated names and patterns with pipe, match"",
+			route:       new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:        map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
+			host:        """",
+			path:        ""/a/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {
@@ -633,6 +687,42 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with hyphenated name, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:        map[string]string{""v-1"": ""bar""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with multiple hyphenated names, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1}"", ""baz"", ""{v-2}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:        map[string]string{""v-1"": ""bar"", ""v-2"": ""ding""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with hyphenate name and pattern, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=10""),
+			vars:        map[string]string{""v-1"": ""10""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with hyphenated name and pattern with quantifier, additional capturing group"",
+			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]{1}(a|b)}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
+			vars:        map[string]string{""v-1"": ""1a""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route with empty value, should match"",
 			route:       new(Route).Queries(""foo"", """"),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e330fd08a314ab270035e000f1543d1af53f6812,https://github.com/gorilla/mux/blob/e330fd08a314ab270035e000f1543d1af53f6812/mux_test.go
e330fd08a314ab270035e000f1543d1af53f6812,06728dd545e0283d4d590be47013abc47387f1d2,regexp.go,,"Tue, 11 Aug 2015 05:40:28 GMT",modified,16,9,25,"@@ -10,6 +10,7 @@ import (
 	""net/http""
 	""net/url""
 	""regexp""
+	""strconv""
 	""strings""
 )
 
@@ -72,13 +73,14 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), name, patt)
+		varIdx := i / 2
+		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), varGroupName(varIdx), patt)
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 
 		// Append variable name and compiled pattern.
-		varsN[i/2] = name
-		varsR[i/2], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
+		varsN[varIdx] = name
+		varsR[varIdx], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
 		if err != nil {
 			return nil, err
 		}
@@ -224,6 +226,11 @@ func braceIndices(s string) ([]int, error) {
 	return idxs, nil
 }
 
+// varGroupName builds a capturing group name for the indexed variable.
+func varGroupName(idx int) string {
+	return ""v"" + strconv.Itoa(idx)
+}
+
 // ----------------------------------------------------------------------------
 // routeRegexpGroup
 // ----------------------------------------------------------------------------
@@ -244,8 +251,8 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := v.host.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name != """" && v.host.varsN[varName] == name {
-					m.Vars[name] = hostVars[i+1]
+				if name != """" && name == varGroupName(varName) {
+					m.Vars[v.host.varsN[varName]] = hostVars[i+1]
 					varName++
 				}
 			}
@@ -258,8 +265,8 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := v.path.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name != """" && v.path.varsN[varName] == name {
-					m.Vars[name] = pathVars[i+1]
+				if name != """" && name == varGroupName(varName) {
+					m.Vars[v.path.varsN[varName]] = pathVars[i+1]
 					varName++
 				}
 			}
@@ -286,8 +293,8 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := q.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name != """" && q.varsN[varName] == name {
-					m.Vars[name] = queryVars[i+1]
+				if name != """" && name == varGroupName(varName) {
+					m.Vars[q.varsN[varName]] = queryVars[i+1]
 					varName++
 				}
 			}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=e330fd08a314ab270035e000f1543d1af53f6812,https://github.com/gorilla/mux/blob/e330fd08a314ab270035e000f1543d1af53f6812/regexp.go
d17b93cab89c2fe13ef8292fdefb116d86666e75,06728dd545e0283d4d590be47013abc47387f1d2,regexp.go,,"Tue, 11 Aug 2015 05:26:09 GMT",modified,5,4,9,"@@ -10,6 +10,7 @@ import (
 	""net/http""
 	""net/url""
 	""regexp""
+	""strconv""
 	""strings""
 )
 
@@ -227,7 +228,7 @@ func braceIndices(s string) ([]int, error) {
 
 // varGroupName builds a capturing group name for the indexed variable.
 func varGroupName(idx int) string {
-	return fmt.Sprintf(""v%d"", idx)
+	return ""v"" + strconv.Itoa(idx)
 }
 
 // ----------------------------------------------------------------------------
@@ -250,7 +251,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := v.host.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name == varGroupName(varName) {
+				if name != """" && name == varGroupName(varName) {
 					m.Vars[v.host.varsN[varName]] = hostVars[i+1]
 					varName++
 				}
@@ -264,7 +265,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := v.path.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name == varGroupName(varName) {
+				if name != """" && name == varGroupName(varName) {
 					m.Vars[v.path.varsN[varName]] = pathVars[i+1]
 					varName++
 				}
@@ -292,7 +293,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := q.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name == varGroupName(varName) {
+				if name != """" && name == varGroupName(varName) {
 					m.Vars[q.varsN[varName]] = queryVars[i+1]
 					varName++
 				}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=d17b93cab89c2fe13ef8292fdefb116d86666e75,https://github.com/gorilla/mux/blob/d17b93cab89c2fe13ef8292fdefb116d86666e75/regexp.go
273db68971215ed764f24e23f49469c54e9bcd4b,d3f25ded0d2350b3f0b36c2f404c3dbe7ac92d25,regexp.go,,"Mon, 10 Aug 2015 19:32:47 GMT",modified,15,9,24,"@@ -72,13 +72,14 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), name, patt)
+		varIdx := i / 2
+		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), varGroupName(varIdx), patt)
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 
 		// Append variable name and compiled pattern.
-		varsN[i/2] = name
-		varsR[i/2], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
+		varsN[varIdx] = name
+		varsR[varIdx], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
 		if err != nil {
 			return nil, err
 		}
@@ -224,6 +225,11 @@ func braceIndices(s string) ([]int, error) {
 	return idxs, nil
 }
 
+// varGroupName builds a capturing group name for the indexed variable.
+func varGroupName(idx int) string {
+	return fmt.Sprintf(""v%d"", idx)
+}
+
 // ----------------------------------------------------------------------------
 // routeRegexpGroup
 // ----------------------------------------------------------------------------
@@ -244,8 +250,8 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := v.host.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name != """" && v.host.varsN[varName] == name {
-					m.Vars[name] = hostVars[i+1]
+				if name == varGroupName(varName) {
+					m.Vars[v.host.varsN[varName]] = hostVars[i+1]
 					varName++
 				}
 			}
@@ -258,8 +264,8 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := v.path.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name != """" && v.path.varsN[varName] == name {
-					m.Vars[name] = pathVars[i+1]
+				if name == varGroupName(varName) {
+					m.Vars[v.path.varsN[varName]] = pathVars[i+1]
 					varName++
 				}
 			}
@@ -286,8 +292,8 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			subexpNames := q.regexp.SubexpNames()
 			varName := 0
 			for i, name := range subexpNames[1:] {
-				if name != """" && q.varsN[varName] == name {
-					m.Vars[name] = queryVars[i+1]
+				if name == varGroupName(varName) {
+					m.Vars[q.varsN[varName]] = queryVars[i+1]
 					varName++
 				}
 			}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=273db68971215ed764f24e23f49469c54e9bcd4b,https://github.com/gorilla/mux/blob/273db68971215ed764f24e23f49469c54e9bcd4b/regexp.go
577b9e4a658e25897ddd3320255d96a9285a26c0,7a0bc9e441f2de1e9a9b8e8e67cd41b40ed91980,mux_test.go,,"Mon, 10 Aug 2015 19:05:30 GMT",modified,90,0,90,"@@ -144,6 +144,33 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Host route with hyphenated name and pattern, match"",
+			route:       new(Route).Host(""aaa.{v-1:[a-z]{3}}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with hyphenated name and pattern, additional capturing group, match"",
+			route:       new(Route).Host(""aaa.{v-1:[a-z]{2}(b|c)}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with multiple hyphenated names and patterns, match"",
+			route:       new(Route).Host(""{v-1:[a-z]{3}}.{v-2:[a-z]{3}}.{v-3:[a-z]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v-1"": ""aaa"", ""v-2"": ""bbb"", ""v-3"": ""ccc""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Path route with single pattern with pipe, match"",
 			route:       new(Route).Path(""/{category:a|b/c}""),
@@ -278,6 +305,33 @@ func TestPath(t *testing.T) {
 			path:        ""/a/product_name/1"",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Path route with hyphenated name and pattern, match"",
+			route:       new(Route).Path(""/111/{v-1:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v-1"": ""222""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple hyphenated names and patterns, match"",
+			route:       new(Route).Path(""/{v-1:[0-9]{3}}/{v-2:[0-9]{3}}/{v-3:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v-1"": ""111"", ""v-2"": ""222"", ""v-3"": ""333""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple hyphenated names and patterns with pipe, match"",
+			route:       new(Route).Path(""/{product-category:a|(b/c)}/{product-name}/{product-id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:        map[string]string{""product-category"": ""a"", ""product-name"": ""product_name"", ""product-id"": ""1""},
+			host:        """",
+			path:        ""/a/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {
@@ -633,6 +687,42 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with hyphenated name, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:        map[string]string{""v-1"": ""bar""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with multiple hyphenated names, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1}"", ""baz"", ""{v-2}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:        map[string]string{""v-1"": ""bar"", ""v-2"": ""ding""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with hyphenate name and pattern, match"",
+			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=10""),
+			vars:        map[string]string{""v-1"": ""10""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with hyphenated name and pattern with quantifier, additional capturing group"",
+			route:       new(Route).Queries(""foo"", ""{v-1:[0-9]{1}(a|b)}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
+			vars:        map[string]string{""v-1"": ""1a""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route with empty value, should match"",
 			route:       new(Route).Queries(""foo"", """"),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=577b9e4a658e25897ddd3320255d96a9285a26c0,https://github.com/gorilla/mux/blob/577b9e4a658e25897ddd3320255d96a9285a26c0/mux_test.go
ffb3f683aad4dcbc2bb65177799563252585dd22,bf49ebd96bfc35cae6b7bd8fb33d459624502ac5,README.md,,"Sat, 08 Aug 2015 06:16:13 GMT",modified,31,0,31,"@@ -202,3 +202,34 @@ as well:
 	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
 	                                 ""category"", ""technology"",
 	                                 ""id"", ""42"")
+
+## Full Example
+
+Here's a complete, runnable example of a small mux based server:
+
+```go
+package main
+
+import (
+	""net/http""
+
+	""github.com/gorilla/mux""
+)
+
+func YourHandler(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte(""Gorilla!\n""))
+}
+
+func main() {
+	r := mux.NewRouter()
+	// Routes consist of a path and a handler function.
+	r.HandleFunc(""/"", YourHandler)
+
+	// Bind to a port and pass our router in
+	http.ListenAndServe("":8000"", r)
+}
+```
+
+## License
+
+BSD licensed. See the LICENSE file for details.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=ffb3f683aad4dcbc2bb65177799563252585dd22,https://github.com/gorilla/mux/blob/ffb3f683aad4dcbc2bb65177799563252585dd22/README.md
ca524fd37fc91e043c82ba10aed96f77d523c514,bf49ebd96bfc35cae6b7bd8fb33d459624502ac5,README.md,,"Sat, 08 Aug 2015 04:41:49 GMT",modified,31,0,31,"@@ -202,3 +202,34 @@ as well:
 	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
 	                                 ""category"", ""technology"",
 	                                 ""id"", ""42"")
+
+## Full Example
+
+Here's a complete, runnable example of a small mux based server:
+
+```go
+package main
+
+import (
+	""net/http""
+
+	""github.com/gorilla/mux""
+)
+
+func YourHandler(w http.ResponseWriter, r *http.Request) {
+	w.Write([]byte(""Gorilla!\n""))
+}
+
+func main() {
+	r := mux.NewRouter()
+	// Routes consist of a path and a handler function.
+	r.HandleFunc(""/"", YourHandler)
+
+	// Bind to a port and pass our router in
+	http.ListenAndServe("":8000"", r)
+}
+```
+
+## License
+
+BSD licensed. See the LICENSE file for details.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=ca524fd37fc91e043c82ba10aed96f77d523c514,https://github.com/gorilla/mux/blob/ca524fd37fc91e043c82ba10aed96f77d523c514/README.md
8965bfef36e398a40fa4afbe4e22eea61cb8db86,d49a0f234a8334ca5fbdea8d0585393cb801102b,mux_test.go,,"Fri, 07 Aug 2015 20:34:10 GMT",modified,27,0,27,"@@ -108,6 +108,15 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Host route with pattern, additional capturing group, match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Host route with pattern, wrong host in request URL"",
 			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
@@ -260,6 +269,15 @@ func TestPath(t *testing.T) {
 			path:        ""/111/222/333"",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Path route with multiple patterns with pipe, match"",
+			route:       new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:        """",
+			path:        ""/a/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {
@@ -597,6 +615,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with regexp pattern with quantifier, additional capturing group"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}(a|b)}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
+			vars:        map[string]string{""v1"": ""1a""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
 			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=8965bfef36e398a40fa4afbe4e22eea61cb8db86,https://github.com/gorilla/mux/blob/8965bfef36e398a40fa4afbe4e22eea61cb8db86/mux_test.go
8965bfef36e398a40fa4afbe4e22eea61cb8db86,6b34fec0606abc680c4a1eb3ccaed67ccc06f328,regexp.go,,"Fri, 07 Aug 2015 20:34:10 GMT",modified,22,7,29,"@@ -72,7 +72,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
+		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), name, patt)
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 
@@ -241,17 +241,27 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	if v.host != nil {
 		hostVars := v.host.regexp.FindStringSubmatch(getHost(req))
 		if hostVars != nil {
-			for k, v := range v.host.varsN {
-				m.Vars[v] = hostVars[k+1]
+			subexpNames := v.host.regexp.SubexpNames()
+			varName := 0
+			for i, name := range subexpNames[1:] {
+				if name != """" && v.host.varsN[varName] == name {
+					m.Vars[name] = hostVars[i+1]
+					varName++
+				}
 			}
 		}
 	}
 	// Store path variables.
 	if v.path != nil {
 		pathVars := v.path.regexp.FindStringSubmatch(req.URL.Path)
 		if pathVars != nil {
-			for k, v := range v.path.varsN {
-				m.Vars[v] = pathVars[k+1]
+			subexpNames := v.path.regexp.SubexpNames()
+			varName := 0
+			for i, name := range subexpNames[1:] {
+				if name != """" && v.path.varsN[varName] == name {
+					m.Vars[name] = pathVars[i+1]
+					varName++
+				}
 			}
 			// Check if we should redirect.
 			if v.path.strictSlash {
@@ -273,8 +283,13 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	for _, q := range v.queries {
 		queryVars := q.regexp.FindStringSubmatch(q.getUrlQuery(req))
 		if queryVars != nil {
-			for k, v := range q.varsN {
-				m.Vars[v] = queryVars[k+1]
+			subexpNames := q.regexp.SubexpNames()
+			varName := 0
+			for i, name := range subexpNames[1:] {
+				if name != """" && q.varsN[varName] == name {
+					m.Vars[name] = queryVars[i+1]
+					varName++
+				}
 			}
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=8965bfef36e398a40fa4afbe4e22eea61cb8db86,https://github.com/gorilla/mux/blob/8965bfef36e398a40fa4afbe4e22eea61cb8db86/regexp.go
c3c5f0000f7b474738b08f34308c1e8a4060ce14,caeaa462251e8362632e845544fc0d317cd005ba,mux_test.go,,"Fri, 07 Aug 2015 05:12:38 GMT",modified,9,0,9,"@@ -660,6 +660,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route, bad submatch"",
+			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://localhost?fffoo=bar&baz=dingggg""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=c3c5f0000f7b474738b08f34308c1e8a4060ce14,https://github.com/gorilla/mux/blob/c3c5f0000f7b474738b08f34308c1e8a4060ce14/mux_test.go
780d0505d751ba5c99ecf71ea287253f089a496b,e7566cac4e1bf1ecc4d5d6037ebe09ba0aa7e1af,README.md,,"Fri, 07 Aug 2015 03:46:08 GMT",modified,199,2,201,"@@ -1,7 +1,204 @@
 mux
 ===
+[![GoDoc](https://godoc.org/github.com/gorilla/securecookie?status.svg)](https://godoc.org/github.com/gorilla/securecookie)
 [![Build Status](https://travis-ci.org/gorilla/mux.png?branch=master)](https://travis-ci.org/gorilla/mux)
 
-gorilla/mux is a powerful URL router and dispatcher.
+Package gorilla/mux implements a request router and dispatcher.
 
-Read the full documentation here: http://www.gorillatoolkit.org/pkg/mux
+The name mux stands for ""HTTP request multiplexer"". Like the standard
+http.ServeMux, mux.Router matches incoming requests against a list of
+registered routes and calls a handler for the route that matches the URL
+or other conditions. The main features are:
+
+	* Requests can be matched based on URL host, path, path prefix, schemes,
+	  header and query values, HTTP methods or using custom matchers.
+	* URL hosts and paths can have variables with an optional regular
+	  expression.
+	* Registered URLs can be built, or ""reversed"", which helps maintaining
+	  references to resources.
+	* Routes can be used as subrouters: nested routes are only tested if the
+	  parent route matches. This is useful to define groups of routes that
+	  share common conditions like a host, a path prefix or other repeated
+	  attributes. As a bonus, this optimizes request matching.
+	* It implements the http.Handler interface so it is compatible with the
+	  standard http.ServeMux.
+
+Let's start registering a couple of URL paths and handlers:
+
+	func main() {
+		r := mux.NewRouter()
+		r.HandleFunc(""/"", HomeHandler)
+		r.HandleFunc(""/products"", ProductsHandler)
+		r.HandleFunc(""/articles"", ArticlesHandler)
+		http.Handle(""/"", r)
+	}
+
+Here we register three routes mapping URL paths to handlers. This is
+equivalent to how http.HandleFunc() works: if an incoming request URL matches
+one of the paths, the corresponding handler is called passing
+(http.ResponseWriter, *http.Request) as parameters.
+
+Paths can have variables. They are defined using the format {name} or
+{name:pattern}. If a regular expression pattern is not defined, the matched
+variable will be anything until the next slash. For example:
+
+	r := mux.NewRouter()
+	r.HandleFunc(""/products/{key}"", ProductHandler)
+	r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
+	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
+
+The names are used to create a map of route variables which can be retrieved
+calling mux.Vars():
+
+	vars := mux.Vars(request)
+	category := vars[""category""]
+
+And this is all you need to know about the basic usage. More advanced options
+are explained below.
+
+Routes can also be restricted to a domain or subdomain. Just define a host
+pattern to be matched. They can also have variables:
+
+	r := mux.NewRouter()
+	// Only matches if domain is ""www.domain.com"".
+	r.Host(""www.domain.com"")
+	// Matches a dynamic subdomain.
+	r.Host(""{subdomain:[a-z]+}.domain.com"")
+
+There are several other matchers that can be added. To match path prefixes:
+
+	r.PathPrefix(""/products/"")
+
+...or HTTP methods:
+
+	r.Methods(""GET"", ""POST"")
+
+...or URL schemes:
+
+	r.Schemes(""https"")
+
+...or header values:
+
+	r.Headers(""X-Requested-With"", ""XMLHttpRequest"")
+
+...or query values:
+
+	r.Queries(""key"", ""value"")
+
+...or to use a custom matcher function:
+
+	r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
+		return r.ProtoMajor == 0
+	})
+
+...and finally, it is possible to combine several matchers in a single route:
+
+	r.HandleFunc(""/products"", ProductsHandler).
+	  Host(""www.domain.com"").
+	  Methods(""GET"").
+	  Schemes(""http"")
+
+Setting the same matching conditions again and again can be boring, so we have
+a way to group several routes that share the same requirements.
+We call it ""subrouting"".
+
+For example, let's say we have several URLs that should only match when the
+host is ""www.domain.com"". Create a route for that host and get a ""subrouter""
+from it:
+
+	r := mux.NewRouter()
+	s := r.Host(""www.domain.com"").Subrouter()
+
+Then register routes in the subrouter:
+
+	s.HandleFunc(""/products/"", ProductsHandler)
+	s.HandleFunc(""/products/{key}"", ProductHandler)
+	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+
+The three URL paths we registered above will only be tested if the domain is
+""www.domain.com"", because the subrouter is tested first. This is not
+only convenient, but also optimizes request matching. You can create
+subrouters combining any attribute matchers accepted by a route.
+
+Subrouters can be used to create domain or path ""namespaces"": you define
+subrouters in a central place and then parts of the app can register its
+paths relatively to a given subrouter.
+
+There's one more thing about subroutes. When a subrouter has a path prefix,
+the inner routes use it as base for their paths:
+
+	r := mux.NewRouter()
+	s := r.PathPrefix(""/products"").Subrouter()
+	// ""/products/""
+	s.HandleFunc(""/"", ProductsHandler)
+	// ""/products/{key}/""
+	s.HandleFunc(""/{key}/"", ProductHandler)
+	// ""/products/{key}/details""
+	s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
+
+Now let's see how to build registered URLs.
+
+Routes can be named. All routes that define a name can have their URLs built,
+or ""reversed"". We define a name calling Name() on a route. For example:
+
+	r := mux.NewRouter()
+	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+	  Name(""article"")
+
+To build a URL, get the route and call the URL() method, passing a sequence of
+key/value pairs for the route variables. For the previous route, we would do:
+
+	url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+
+...and the result will be a url.URL with the following path:
+
+	""/articles/technology/42""
+
+This also works for host variables:
+
+	r := mux.NewRouter()
+	r.Host(""{subdomain}.domain.com"").
+	  Path(""/articles/{category}/{id:[0-9]+}"").
+	  HandlerFunc(ArticleHandler).
+	  Name(""article"")
+
+	// url.String() will be ""http://news.domain.com/articles/technology/42""
+	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+	                                 ""category"", ""technology"",
+	                                 ""id"", ""42"")
+
+All variables defined in the route are required, and their values must
+conform to the corresponding patterns. These requirements guarantee that a
+generated URL will always match a registered route -- the only exception is
+for explicitly defined ""build-only"" routes which never match.
+
+Regex support also exists for matching Headers within a route. For example, we could do:
+
+	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
+
+...and the route will match both requests with a Content-Type of `application/json` as well as
+`application/text`
+
+There's also a way to build only the URL host or path for a route:
+use the methods URLHost() or URLPath() instead. For the previous route,
+we would do:
+
+	// ""http://news.domain.com/""
+	host, err := r.Get(""article"").URLHost(""subdomain"", ""news"")
+
+	// ""/articles/technology/42""
+	path, err := r.Get(""article"").URLPath(""category"", ""technology"", ""id"", ""42"")
+
+And if you use subrouters, host and path defined separately can be built
+as well:
+
+	r := mux.NewRouter()
+	s := r.Host(""{subdomain}.domain.com"").Subrouter()
+	s.Path(""/articles/{category}/{id:[0-9]+}"").
+	  HandlerFunc(ArticleHandler).
+	  Name(""article"")
+
+	// ""http://news.domain.com/articles/technology/42""
+	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+	                                 ""category"", ""technology"",
+	                                 ""id"", ""42"")",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=780d0505d751ba5c99ecf71ea287253f089a496b,https://github.com/gorilla/mux/blob/780d0505d751ba5c99ecf71ea287253f089a496b/README.md
e73f183699f8ab7d54609771e1fa0ab7ffddc21b,455d68e3604eaeb7d9d7ccdb93be814f02358fbd,mux_test.go,,"Fri, 07 Aug 2015 03:32:43 GMT",modified,27,0,27,"@@ -108,6 +108,15 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Host route with pattern, additional capturing group, match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{2}(b|c)}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Host route with pattern, wrong host in request URL"",
 			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
@@ -260,6 +269,15 @@ func TestPath(t *testing.T) {
 			path:        ""/111/222/333"",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Path route with multiple patterns with pipe, match"",
+			route:       new(Route).Path(""/{category:a|(b/c)}/{product}/{id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:        """",
+			path:        ""/a/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {
@@ -597,6 +615,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with regexp pattern with quantifier, additional capturing group"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}(a|b)}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=1a""),
+			vars:        map[string]string{""v1"": ""1a""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
 			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e73f183699f8ab7d54609771e1fa0ab7ffddc21b,https://github.com/gorilla/mux/blob/e73f183699f8ab7d54609771e1fa0ab7ffddc21b/mux_test.go
e73f183699f8ab7d54609771e1fa0ab7ffddc21b,6b34fec0606abc680c4a1eb3ccaed67ccc06f328,regexp.go,,"Fri, 07 Aug 2015 03:32:43 GMT",modified,22,7,29,"@@ -72,7 +72,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 				tpl[idxs[i]:end])
 		}
 		// Build the regexp pattern.
-		fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
+		fmt.Fprintf(pattern, ""%s(?P<%s>%s)"", regexp.QuoteMeta(raw), name, patt)
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
 
@@ -241,17 +241,27 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	if v.host != nil {
 		hostVars := v.host.regexp.FindStringSubmatch(getHost(req))
 		if hostVars != nil {
-			for k, v := range v.host.varsN {
-				m.Vars[v] = hostVars[k+1]
+			subexpNames := v.host.regexp.SubexpNames()
+			varName := 0
+			for i, name := range subexpNames[1:] {
+				if name != """" && v.host.varsN[varName] == name {
+					m.Vars[name] = hostVars[i+1]
+					varName++
+				}
 			}
 		}
 	}
 	// Store path variables.
 	if v.path != nil {
 		pathVars := v.path.regexp.FindStringSubmatch(req.URL.Path)
 		if pathVars != nil {
-			for k, v := range v.path.varsN {
-				m.Vars[v] = pathVars[k+1]
+			subexpNames := v.path.regexp.SubexpNames()
+			varName := 0
+			for i, name := range subexpNames[1:] {
+				if name != """" && v.path.varsN[varName] == name {
+					m.Vars[name] = pathVars[i+1]
+					varName++
+				}
 			}
 			// Check if we should redirect.
 			if v.path.strictSlash {
@@ -273,8 +283,13 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 	for _, q := range v.queries {
 		queryVars := q.regexp.FindStringSubmatch(q.getUrlQuery(req))
 		if queryVars != nil {
-			for k, v := range q.varsN {
-				m.Vars[v] = queryVars[k+1]
+			subexpNames := q.regexp.SubexpNames()
+			varName := 0
+			for i, name := range subexpNames[1:] {
+				if name != """" && q.varsN[varName] == name {
+					m.Vars[name] = queryVars[i+1]
+					varName++
+				}
 			}
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=e73f183699f8ab7d54609771e1fa0ab7ffddc21b,https://github.com/gorilla/mux/blob/e73f183699f8ab7d54609771e1fa0ab7ffddc21b/regexp.go
5a8a0400500543e28b2886a8c52d21a435815411,002051fcf49b711f1867e51a13800fec5badbff5,mux.go,,"Wed, 05 Aug 2015 16:48:15 GMT",modified,4,0,4,"@@ -312,6 +312,10 @@ func Vars(r *http.Request) map[string]string {
 }
 
 // CurrentRoute returns the matched route for the current request, if any.
+// This only works when called inside the handler of the matched route
+// because the matched route is stored in the request context which is cleared
+// after the handler returns, unless the KeepContext option is set on the
+// Router.
 func CurrentRoute(r *http.Request) *Route {
 	if rv := context.Get(r, routeKey); rv != nil {
 		return rv.(*Route)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=5a8a0400500543e28b2886a8c52d21a435815411,https://github.com/gorilla/mux/blob/5a8a0400500543e28b2886a8c52d21a435815411/mux.go
13c8226081008f7ade9c619da744ed14e78eb8de,002051fcf49b711f1867e51a13800fec5badbff5,mux.go,,"Wed, 05 Aug 2015 08:24:37 GMT",modified,4,3,7,"@@ -312,9 +312,10 @@ func Vars(r *http.Request) map[string]string {
 }
 
 // CurrentRoute returns the matched route for the current request, if any.
-// Note: this only works when called inside the handler of the matched route
-// because it uses context.Get() which will be cleared after executing the
-// handler.
+// This only works when called inside the handler of the matched route
+// because the matched route is stored in the request context which is cleared
+// after the handler returns, unless the KeepContext option is set on the
+// Router.
 func CurrentRoute(r *http.Request) *Route {
 	if rv := context.Get(r, routeKey); rv != nil {
 		return rv.(*Route)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=13c8226081008f7ade9c619da744ed14e78eb8de,https://github.com/gorilla/mux/blob/13c8226081008f7ade9c619da744ed14e78eb8de/mux.go
39cff3481ca9e2726231c3067f58fcf3a8c9e333,4a94a23f0640733084401de06a141e3e0fd62494,mux.go,,"Wed, 05 Aug 2015 07:26:50 GMT",modified,3,0,3,"@@ -312,6 +312,9 @@ func Vars(r *http.Request) map[string]string {
 }
 
 // CurrentRoute returns the matched route for the current request, if any.
+// Note: this only works when called inside the handler of the matched route
+// because it uses context.Get() which will be cleared after executing the
+// handler.
 func CurrentRoute(r *http.Request) *Route {
 	if rv := context.Get(r, routeKey); rv != nil {
 		return rv.(*Route)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=39cff3481ca9e2726231c3067f58fcf3a8c9e333,https://github.com/gorilla/mux/blob/39cff3481ca9e2726231c3067f58fcf3a8c9e333/mux.go
f15e0c49460fd49eebe2bcc8486b05d1bef68d3a,442babab854e07944baa5ba391b6d6290f0bdf5e,doc.go,,"Mon, 27 Jul 2015 16:40:50 GMT",modified,7,0,7,"@@ -172,6 +172,13 @@ conform to the corresponding patterns. These requirements guarantee that a
 generated URL will always match a registered route -- the only exception is
 for explicitly defined ""build-only"" routes which never match.
 
+Regex support also exists for matching Headers within a route. For example, we could do:
+
+	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
+
+...and the route will match both requests with a Content-Type of `application/json` as well as
+`application/text`
+
 There's also a way to build only the URL host or path for a route:
 use the methods URLHost() or URLPath() instead. For the previous route,
 we would do:",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=f15e0c49460fd49eebe2bcc8486b05d1bef68d3a,https://github.com/gorilla/mux/blob/f15e0c49460fd49eebe2bcc8486b05d1bef68d3a/doc.go
f15e0c49460fd49eebe2bcc8486b05d1bef68d3a,e25323092d4484741a5dd06476c063bab1e0bbf4,mux.go,,"Mon, 27 Jul 2015 16:40:50 GMT",modified,58,6,64,"@@ -9,6 +9,7 @@ import (
 	""fmt""
 	""net/http""
 	""path""
+	""regexp""
 
 	""github.com/gorilla/context""
 )
@@ -360,20 +361,44 @@ func uniqueVars(s1, s2 []string) error {
 	return nil
 }
 
-// mapFromPairs converts variadic string parameters to a string map.
-func mapFromPairs(pairs ...string) (map[string]string, error) {
+func checkPairs(pairs ...string) (int, error) {
 	length := len(pairs)
 	if length%2 != 0 {
-		return nil, fmt.Errorf(
+		return length, fmt.Errorf(
 			""mux: number of parameters must be multiple of 2, got %v"", pairs)
 	}
+	return length, nil
+}
+
+// mapFromPairs converts variadic string parameters to a string map.
+func mapFromPairsToString(pairs ...string) (map[string]string, error) {
+	length, err := checkPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
 	m := make(map[string]string, length/2)
 	for i := 0; i < length; i += 2 {
 		m[pairs[i]] = pairs[i+1]
 	}
 	return m, nil
 }
 
+func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
+	length, err := checkPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	m := make(map[string]*regexp.Regexp, length/2)
+	for i := 0; i < length; i += 2 {
+		regex, err := regexp.Compile(pairs[i+1])
+		if err != nil {
+			return nil, err
+		}
+		m[pairs[i]] = regex
+	}
+	return m, nil
+}
+
 // matchInArray returns true if the given string value is in the array.
 func matchInArray(arr []string, value string) bool {
 	for _, v := range arr {
@@ -384,9 +409,8 @@ func matchInArray(arr []string, value string) bool {
 	return false
 }
 
-// matchMap returns true if the given key/value pairs exist in a given map.
-func matchMap(toCheck map[string]string, toMatch map[string][]string,
-	canonicalKey bool) bool {
+// matchMapWithString returns true if the given key/value pairs exist in a given map.
+func matchMapWithString(toCheck map[string]string, toMatch map[string][]string, canonicalKey bool) bool {
 	for k, v := range toCheck {
 		// Check if key exists.
 		if canonicalKey {
@@ -411,3 +435,31 @@ func matchMap(toCheck map[string]string, toMatch map[string][]string,
 	}
 	return true
 }
+
+// matchMapWithRegex returns true if the given key/value pairs exist in a given map compiled against
+// the given regex
+func matchMapWithRegex(toCheck map[string]*regexp.Regexp, toMatch map[string][]string, canonicalKey bool) bool {
+	for k, v := range toCheck {
+		// Check if key exists.
+		if canonicalKey {
+			k = http.CanonicalHeaderKey(k)
+		}
+		if values := toMatch[k]; values == nil {
+			return false
+		} else if v != nil {
+			// If value was defined as an empty string we only check that the
+			// key exists. Otherwise we also check for equality.
+			valueExists := false
+			for _, value := range values {
+				if v.MatchString(value) {
+					valueExists = true
+					break
+				}
+			}
+			if !valueExists {
+				return false
+			}
+		}
+	}
+	return true
+}",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=f15e0c49460fd49eebe2bcc8486b05d1bef68d3a,https://github.com/gorilla/mux/blob/f15e0c49460fd49eebe2bcc8486b05d1bef68d3a/mux.go
f15e0c49460fd49eebe2bcc8486b05d1bef68d3a,ba47727c525742f55bf5a139290194f2be25dd99,mux_test.go,,"Mon, 27 Jul 2015 16:40:50 GMT",modified,18,0,18,"@@ -434,6 +434,24 @@ func TestHeaders(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Headers route, regex header values to match"",
+			route:       new(Route).Headers(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Headers route, regex header values to match"",
+			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baz""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=f15e0c49460fd49eebe2bcc8486b05d1bef68d3a,https://github.com/gorilla/mux/blob/f15e0c49460fd49eebe2bcc8486b05d1bef68d3a/mux_test.go
f15e0c49460fd49eebe2bcc8486b05d1bef68d3a,75481b5797902b49411cbb2983d52c3fabe429b2,route.go,,"Mon, 27 Jul 2015 16:40:50 GMT",modified,35,3,38,"@@ -9,6 +9,7 @@ import (
 	""fmt""
 	""net/http""
 	""net/url""
+	""regexp""
 	""strings""
 )
 
@@ -188,7 +189,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 type headerMatcher map[string]string
 
 func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
-	return matchMap(m, r.Header, true)
+	return matchMapWithString(m, r.Header, true)
 }
 
 // Headers adds a matcher for request header values.
@@ -199,17 +200,48 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 //               ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both request header values match.
+// Alternatively, you can provide a regular expression and match the header as follows:
+//
+//     r.Headers(""Content-Type"", ""application/(text|json)"",
+//               ""X-Requested-With"", ""XMLHttpRequest"")
+//
+// The above route will the same as the previous example, with the addition of matching
+// application/text as well.
 //
 // It the value is an empty string, it will match any value if the key is set.
 func (r *Route) Headers(pairs ...string) *Route {
 	if r.err == nil {
 		var headers map[string]string
-		headers, r.err = mapFromPairs(pairs...)
+		headers, r.err = mapFromPairsToString(pairs...)
 		return r.addMatcher(headerMatcher(headers))
 	}
 	return r
 }
 
+// headerRegexMatcher matches the request against the route given a regex for the header
+type headerRegexMatcher map[string]*regexp.Regexp
+
+func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
+	return matchMapWithRegex(m, r.Header, true)
+}
+
+// Regular expressions can be used with headers as well.
+// It accepts a sequence of key/value pairs, where the value has regex support. For example
+//     r := mux.NewRouter()
+//     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
+//               ""X-Requested-With"", ""XMLHttpRequest"")
+//
+// The above route will only match if both the request header matches both regular expressions.
+// It the value is an empty string, it will match any value if the key is set.
+func (r *Route) HeadersRegexp(pairs ...string) *Route {
+	if r.err == nil {
+		var headers map[string]*regexp.Regexp
+		headers, r.err = mapFromPairsToRegex(pairs...)
+		return r.addMatcher(headerRegexMatcher(headers))
+	}
+	return r
+}
+
 // Host -----------------------------------------------------------------------
 
 // Host adds a matcher for the URL host.
@@ -511,7 +543,7 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
-	m, err := mapFromPairs(pairs...)
+	m, err := mapFromPairsToString(pairs...)
 	if err != nil {
 		return nil, err
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=f15e0c49460fd49eebe2bcc8486b05d1bef68d3a,https://github.com/gorilla/mux/blob/f15e0c49460fd49eebe2bcc8486b05d1bef68d3a/route.go
98fb535d771e43021d337c156c78ab13d1a7f506,2304c91d7b43ff68a5a311388f97a9ed24a43956,mux.go,,"Sun, 19 Jul 2015 08:57:47 GMT",modified,4,1,5,"@@ -343,7 +343,10 @@ func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
 	}
 	m := make(map[string]*regexp.Regexp, length/2)
 	for i := 0; i < length; i += 2 {
-		regex, _ := regexp.Compile(pairs[i+1])
+		regex, err := regexp.Compile(pairs[i+1])
+		if err != nil {
+			return nil, err
+		}
 		m[pairs[i]] = regex
 	}
 	return m, nil",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=98fb535d771e43021d337c156c78ab13d1a7f506,https://github.com/gorilla/mux/blob/98fb535d771e43021d337c156c78ab13d1a7f506/mux.go
ba336c9cfb43552c90de6cb2ceedd3271c747558,7c636d0ef0e3fa3d90da09bd12cd47e77818d559,regexp.go,,"Fri, 17 Jul 2015 15:03:03 GMT",modified,1,1,2,"@@ -186,7 +186,7 @@ func (r *routeRegexp) getUrlQuery(req *http.Request) string {
 	if !r.matchQuery {
 		return """"
 	}
-	templateKey := strings.Split(r.template, ""="")[0]
+	templateKey := strings.SplitN(r.template, ""="", 2)[0]
 	for key, vals := range req.URL.Query() {
 		if key == templateKey && len(vals) > 0 {
 			return key + ""="" + vals[0]",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=ba336c9cfb43552c90de6cb2ceedd3271c747558,https://github.com/gorilla/mux/blob/ba336c9cfb43552c90de6cb2ceedd3271c747558/regexp.go
61445102e8c8e7ce9c2ad977d594d26ac226a8b6,75475fd07ca9a24eb0ed80cbbc221988618c9d8c,mux_test.go,,"Fri, 17 Jul 2015 15:02:10 GMT",modified,36,0,36,"@@ -597,6 +597,24 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route with empty value and no parameter in request, should not match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Queries route with empty value and empty parameter in request, should match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost?foo=""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route with overlapping value, should not match"",
 			route:       new(Route).Queries(""foo"", ""bar""),
@@ -606,6 +624,24 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with no parameter in request, should not match"",
+			route:       new(Route).Queries(""foo"", ""{bar}""),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Queries route with empty parameter in request, should match"",
+			route:       new(Route).Queries(""foo"", ""{bar}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=""),
+			vars:        map[string]string{""foo"": """"},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=61445102e8c8e7ce9c2ad977d594d26ac226a8b6,https://github.com/gorilla/mux/blob/61445102e8c8e7ce9c2ad977d594d26ac226a8b6/mux_test.go
61445102e8c8e7ce9c2ad977d594d26ac226a8b6,b30073043ce29dd351bd6392a543b08bb4278fab,regexp.go,,"Fri, 17 Jul 2015 15:02:10 GMT",modified,7,3,10,"@@ -186,9 +186,13 @@ func (r *routeRegexp) getUrlQuery(req *http.Request) string {
 	if !r.matchQuery {
 		return """"
 	}
-	key := strings.Split(r.template, ""="")[0]
-	val := req.URL.Query().Get(key)
-	return key + ""="" + val
+	templateKey := strings.Split(r.template, ""="")[0]
+	for key, vals := range req.URL.Query() {
+		if key == templateKey && len(vals) > 0 {
+			return key + ""="" + vals[0]
+		}
+	}
+	return """"
 }
 
 func (r *routeRegexp) matchQueryString(req *http.Request) bool {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=61445102e8c8e7ce9c2ad977d594d26ac226a8b6,https://github.com/gorilla/mux/blob/61445102e8c8e7ce9c2ad977d594d26ac226a8b6/regexp.go
3339267a853e3a855d6e415b96d6f3447b60a824,1a66ad58359a28bf827059cba02c9f75b4cdc387,mux_test.go,,"Fri, 17 Jul 2015 09:52:37 GMT",modified,28,1,29,"@@ -597,6 +597,24 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route with empty value and no parameter in request, should not match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Queries route with empty value and empty parameter in request, should match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost?foo=""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route with overlapping value, should not match"",
 			route:       new(Route).Queries(""foo"", ""bar""),
@@ -607,14 +625,23 @@ func TestQueries(t *testing.T) {
 			shouldMatch: false,
 		},
 		{
-			title:       ""Queries route with no parameter in request , should not match"",
+			title:       ""Queries route with no parameter in request, should not match"",
 			route:       new(Route).Queries(""foo"", ""{bar}""),
 			request:     newRequest(""GET"", ""http://localhost""),
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with empty parameter in request, should match"",
+			route:       new(Route).Queries(""foo"", ""{bar}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=""),
+			vars:        map[string]string{""foo"": """"},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=3339267a853e3a855d6e415b96d6f3447b60a824,https://github.com/gorilla/mux/blob/3339267a853e3a855d6e415b96d6f3447b60a824/mux_test.go
fe40f0d05612a52a42bbbcd9d28cb81ebe4e6d36,79d1651459667d1a78c56b5debec8f105999dbf7,mux_test.go,,"Fri, 17 Jul 2015 09:19:25 GMT",modified,9,0,9,"@@ -606,6 +606,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with no parameter in request , should not match"",
+			route:       new(Route).Queries(""foo"", ""{bar}""),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=fe40f0d05612a52a42bbbcd9d28cb81ebe4e6d36,https://github.com/gorilla/mux/blob/fe40f0d05612a52a42bbbcd9d28cb81ebe4e6d36/mux_test.go
fe40f0d05612a52a42bbbcd9d28cb81ebe4e6d36,b30073043ce29dd351bd6392a543b08bb4278fab,regexp.go,,"Fri, 17 Jul 2015 09:19:25 GMT",modified,7,3,10,"@@ -186,9 +186,13 @@ func (r *routeRegexp) getUrlQuery(req *http.Request) string {
 	if !r.matchQuery {
 		return """"
 	}
-	key := strings.Split(r.template, ""="")[0]
-	val := req.URL.Query().Get(key)
-	return key + ""="" + val
+	templateKey := strings.Split(r.template, ""="")[0]
+	for key, vals := range req.URL.Query() {
+		if key == templateKey && len(vals) > 0 {
+			return key + ""="" + vals[0]
+		}
+	}
+	return """"
 }
 
 func (r *routeRegexp) matchQueryString(req *http.Request) bool {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=fe40f0d05612a52a42bbbcd9d28cb81ebe4e6d36,https://github.com/gorilla/mux/blob/fe40f0d05612a52a42bbbcd9d28cb81ebe4e6d36/regexp.go
104068abd5cf50032c57aecbf2b8ce5b0a08a2cb,ec1ef37e08495721fcc62dea5602381dd814132e,mux.go,,"Thu, 16 Jul 2015 17:39:48 GMT",modified,47,0,47,"@@ -5,6 +5,7 @@
 package mux
 
 import (
+	""errors""
 	""fmt""
 	""net/http""
 	""path""
@@ -237,6 +238,52 @@ func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
 	return r.NewRoute().BuildVarsFunc(f)
 }
 
+// Walk walks the router and all its sub-routers, calling walkFn for each route
+// in the tree. The routes are walked in the order they were added. Sub-routers
+// are explored depth-first.
+func (r *Router) Walk(walkFn WalkFunc) error {
+	return r.walk(walkFn, []*Route{})
+}
+
+// SkipRouter is used as a return value from WalkFuncs to indicate that the
+// router that walk is about to descend down to should be skipped.
+var SkipRouter = errors.New(""skip this router"")
+
+// WalkFunc is the type of the function called for each route visited by Walk.
+// At every invocation, it is given the current route, and the current router,
+// and a list of ancestor routes that lead to the current route.
+type WalkFunc func(route *Route, router *Router, ancestors []*Route) error
+
+func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
+	for _, t := range r.routes {
+		if t.regexp == nil || t.regexp.path == nil || t.regexp.path.template == """" {
+			continue
+		}
+
+		err := walkFn(t, r, ancestors)
+		if err == SkipRouter {
+			continue
+		}
+		for _, sr := range t.matchers {
+			if h, ok := sr.(*Router); ok {
+				err := h.walk(walkFn, ancestors)
+				if err != nil {
+					return err
+				}
+			}
+		}
+		if h, ok := t.handler.(*Router); ok {
+			ancestors = append(ancestors, t)
+			err := h.walk(walkFn, ancestors)
+			if err != nil {
+				return err
+			}
+			ancestors = ancestors[:len(ancestors)-1]
+		}
+	}
+	return nil
+}
+
 // ----------------------------------------------------------------------------
 // Context
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=104068abd5cf50032c57aecbf2b8ce5b0a08a2cb,https://github.com/gorilla/mux/blob/104068abd5cf50032c57aecbf2b8ce5b0a08a2cb/mux.go
104068abd5cf50032c57aecbf2b8ce5b0a08a2cb,be5252a44853e5d0a9d8cf31e8b6367acf44c665,mux_test.go,,"Thu, 16 Jul 2015 17:39:48 GMT",modified,75,0,75,"@@ -855,6 +855,81 @@ func TestStrictSlash(t *testing.T) {
 	}
 }
 
+func TestWalkSingleDepth(t *testing.T) {
+	r0 := NewRouter()
+	r1 := NewRouter()
+	r2 := NewRouter()
+
+	r0.Path(""/g"")
+	r0.Path(""/o"")
+	r0.Path(""/d"").Handler(r1)
+	r0.Path(""/r"").Handler(r2)
+	r0.Path(""/a"")
+
+	r1.Path(""/z"")
+	r1.Path(""/i"")
+	r1.Path(""/l"")
+	r1.Path(""/l"")
+
+	r2.Path(""/i"")
+	r2.Path(""/l"")
+	r2.Path(""/l"")
+
+	paths := []string{""g"", ""o"", ""r"", ""i"", ""l"", ""l"", ""a""}
+	depths := []int{0, 0, 0, 1, 1, 1, 0}
+	i := 0
+	err := r0.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		matcher := route.matchers[0].(*routeRegexp)
+		if matcher.template == ""/d"" {
+			return SkipRouter
+		}
+		if len(ancestors) != depths[i] {
+			t.Errorf(`Expected depth of %d at i = %d; got ""%s""`, depths[i], i, len(ancestors))
+		}
+		if matcher.template != ""/""+paths[i] {
+			t.Errorf(`Expected ""/%s"" at i = %d; got ""%s""`, paths[i], i, matcher.template)
+		}
+		i++
+		return nil
+	})
+	if err != nil {
+		panic(err)
+	}
+	if i != len(paths) {
+		t.Errorf(""Expected %d routes, found %d"", len(paths), i)
+	}
+}
+
+func TestWalkNested(t *testing.T) {
+	router := NewRouter()
+
+	g := router.Path(""/g"").Subrouter()
+	o := g.PathPrefix(""/o"").Subrouter()
+	r := o.PathPrefix(""/r"").Subrouter()
+	i := r.PathPrefix(""/i"").Subrouter()
+	l1 := i.PathPrefix(""/l"").Subrouter()
+	l2 := l1.PathPrefix(""/l"").Subrouter()
+	l2.Path(""/a"")
+
+	paths := []string{""/g"", ""/g/o"", ""/g/o/r"", ""/g/o/r/i"", ""/g/o/r/i/l"", ""/g/o/r/i/l/l"", ""/g/o/r/i/l/l/a""}
+	idx := 0
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		path := paths[idx]
+		tpl := route.regexp.path.template
+		if tpl != path {
+			t.Errorf(`Expected %s got %s`, path, tpl)
+		}
+		idx++
+		return nil
+	})
+	if err != nil {
+		panic(err)
+	}
+	if idx != len(paths) {
+		t.Errorf(""Expected %d routes, found %d"", len(paths), idx)
+	}
+}
+
 // ----------------------------------------------------------------------------
 // Helpers
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=104068abd5cf50032c57aecbf2b8ce5b0a08a2cb,https://github.com/gorilla/mux/blob/104068abd5cf50032c57aecbf2b8ce5b0a08a2cb/mux_test.go
fe156cb197c7094648577e93c1734bb4c856969e,9bed205ef4559a338813f009d795609ef02f29e9,mux_test.go,,"Thu, 16 Jul 2015 14:26:10 GMT",modified,18,0,18,"@@ -588,6 +588,24 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with empty value, should match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with overlapping value, should not match"",
+			route:       new(Route).Queries(""foo"", ""bar""),
+			request:     newRequest(""GET"", ""http://localhost?foo=barfoo""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=fe156cb197c7094648577e93c1734bb4c856969e,https://github.com/gorilla/mux/blob/fe156cb197c7094648577e93c1734bb4c856969e/mux_test.go
fe156cb197c7094648577e93c1734bb4c856969e,a1f6eb64308954dfd7a33514f4ec0b967e7048a8,regexp.go,,"Thu, 16 Jul 2015 14:26:10 GMT",modified,7,1,8,"@@ -34,7 +34,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
 	if matchQuery {
-		defaultPattern = ""[^?&]+""
+		defaultPattern = ""[^?&]*""
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
 		matchPrefix = false
@@ -89,6 +89,12 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	if strictSlash {
 		pattern.WriteString(""[/]?"")
 	}
+	if matchQuery {
+		// Add the default pattern if the query value is empty
+		if queryVal := strings.SplitN(template, ""="", 2)[1]; queryVal == """" {
+			pattern.WriteString(defaultPattern)
+		}
+	}
 	if !matchPrefix {
 		pattern.WriteByte('$')
 	}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=fe156cb197c7094648577e93c1734bb4c856969e,https://github.com/gorilla/mux/blob/fe156cb197c7094648577e93c1734bb4c856969e/regexp.go
19f0a91c4e299b8253f142001ad546110f3c1e84,9bed205ef4559a338813f009d795609ef02f29e9,mux_test.go,,"Thu, 16 Jul 2015 11:48:02 GMT",modified,9,0,9,"@@ -597,6 +597,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route with overlapping value, should not match"",
+			route:       new(Route).Queries(""foo"", ""bar""),
+			request:     newRequest(""GET"", ""http://localhost?foo=barfoo""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=19f0a91c4e299b8253f142001ad546110f3c1e84,https://github.com/gorilla/mux/blob/19f0a91c4e299b8253f142001ad546110f3c1e84/mux_test.go
19f0a91c4e299b8253f142001ad546110f3c1e84,a1f6eb64308954dfd7a33514f4ec0b967e7048a8,regexp.go,,"Thu, 16 Jul 2015 11:48:02 GMT",modified,5,2,7,"@@ -89,8 +89,11 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	if strictSlash {
 		pattern.WriteString(""[/]?"")
 	}
-	if matchQuery && len(idxs) == 0 {
-		pattern.WriteString(defaultPattern)
+	if matchQuery {
+		// Add the default pattern if the query value is empty
+		if queryVal := strings.SplitN(template, ""="", 2)[1]; queryVal == """" {
+			pattern.WriteString(defaultPattern)
+		}
 	}
 	if !matchPrefix {
 		pattern.WriteByte('$')",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=19f0a91c4e299b8253f142001ad546110f3c1e84,https://github.com/gorilla/mux/blob/19f0a91c4e299b8253f142001ad546110f3c1e84/regexp.go
2b32409792406cc61512ca3aa35706bb9ce8c7dd,0f61da8f9b2769a9138b15269ece1e4b4347b32d,mux_test.go,,"Thu, 16 Jul 2015 09:52:01 GMT",modified,9,0,9,"@@ -588,6 +588,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with empty value, should match"",
+			route:       new(Route).Queries(""foo"", """"),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=2b32409792406cc61512ca3aa35706bb9ce8c7dd,https://github.com/gorilla/mux/blob/2b32409792406cc61512ca3aa35706bb9ce8c7dd/mux_test.go
2b32409792406cc61512ca3aa35706bb9ce8c7dd,8ecf27021f30377f3996787633862a1921fc86eb,regexp.go,,"Thu, 16 Jul 2015 09:52:01 GMT",modified,4,1,5,"@@ -34,7 +34,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
 	if matchQuery {
-		defaultPattern = ""[^?&]+""
+		defaultPattern = ""[^?&]*""
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
 		matchPrefix = false
@@ -89,6 +89,9 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	if strictSlash {
 		pattern.WriteString(""[/]?"")
 	}
+	if matchQuery && len(idxs) == 0 {
+		pattern.WriteString(defaultPattern)
+	}
 	if !matchPrefix {
 		pattern.WriteByte('$')
 	}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=2b32409792406cc61512ca3aa35706bb9ce8c7dd,https://github.com/gorilla/mux/blob/2b32409792406cc61512ca3aa35706bb9ce8c7dd/regexp.go
92ae1d67265b4cf52d659a340435398e8da2ad05,ec1ef37e08495721fcc62dea5602381dd814132e,mux.go,,"Thu, 09 Jul 2015 18:46:53 GMT",modified,47,0,47,"@@ -5,6 +5,7 @@
 package mux
 
 import (
+	""errors""
 	""fmt""
 	""net/http""
 	""path""
@@ -237,6 +238,52 @@ func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
 	return r.NewRoute().BuildVarsFunc(f)
 }
 
+// Walk walks the router and all its sub-routers, calling walkFn for each route
+// in the tree. The routes are walked in the order they were added. Sub-routers
+// are explored depth-first.
+func (r *Router) Walk(walkFn WalkFunc) error {
+	return r.walk(walkFn, []*Route{})
+}
+
+// SkipRouter is used as a return value from WalkFuncs to indicate that the
+// router that walk is about to descend down to should be skipped.
+var SkipRouter = errors.New(""skip this router"")
+
+// WalkFunc is the type of the function called for each route visited by Walk.
+// At every invocation, it is given the current route, and the current router,
+// and a list of ancestor routes that lead to the current route.
+type WalkFunc func(route *Route, router *Router, ancestors []*Route) error
+
+func (r *Router) walk(walkFn WalkFunc, ancestors []*Route) error {
+	for _, t := range r.routes {
+		if t.regexp == nil || t.regexp.path == nil || t.regexp.path.template == """" {
+			continue
+		}
+
+		err := walkFn(t, r, ancestors)
+		if err == SkipRouter {
+			continue
+		}
+		for _, sr := range t.matchers {
+			if h, ok := sr.(*Router); ok {
+				err := h.walk(walkFn, ancestors)
+				if err != nil {
+					return err
+				}
+			}
+		}
+		if h, ok := t.handler.(*Router); ok {
+			ancestors = append(ancestors, t)
+			err := h.walk(walkFn, ancestors)
+			if err != nil {
+				return err
+			}
+			ancestors = ancestors[:len(ancestors)-1]
+		}
+	}
+	return nil
+}
+
 // ----------------------------------------------------------------------------
 // Context
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=92ae1d67265b4cf52d659a340435398e8da2ad05,https://github.com/gorilla/mux/blob/92ae1d67265b4cf52d659a340435398e8da2ad05/mux.go
92ae1d67265b4cf52d659a340435398e8da2ad05,d8dc5515de6232890a54c95412b1bc6bd5e324d2,mux_test.go,,"Thu, 09 Jul 2015 18:46:53 GMT",modified,75,0,75,"@@ -837,6 +837,81 @@ func TestStrictSlash(t *testing.T) {
 	}
 }
 
+func TestWalkSingleDepth(t *testing.T) {
+	r0 := NewRouter()
+	r1 := NewRouter()
+	r2 := NewRouter()
+
+	r0.Path(""/g"")
+	r0.Path(""/o"")
+	r0.Path(""/d"").Handler(r1)
+	r0.Path(""/r"").Handler(r2)
+	r0.Path(""/a"")
+
+	r1.Path(""/z"")
+	r1.Path(""/i"")
+	r1.Path(""/l"")
+	r1.Path(""/l"")
+
+	r2.Path(""/i"")
+	r2.Path(""/l"")
+	r2.Path(""/l"")
+
+	paths := []string{""g"", ""o"", ""r"", ""i"", ""l"", ""l"", ""a""}
+	depths := []int{0, 0, 0, 1, 1, 1, 0}
+	i := 0
+	err := r0.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		matcher := route.matchers[0].(*routeRegexp)
+		if matcher.template == ""/d"" {
+			return SkipRouter
+		}
+		if len(ancestors) != depths[i] {
+			t.Errorf(`Expected depth of %d at i = %d; got ""%s""`, depths[i], i, len(ancestors))
+		}
+		if matcher.template != ""/""+paths[i] {
+			t.Errorf(`Expected ""/%s"" at i = %d; got ""%s""`, paths[i], i, matcher.template)
+		}
+		i++
+		return nil
+	})
+	if err != nil {
+		panic(err)
+	}
+	if i != len(paths) {
+		t.Errorf(""Expected %d routes, found %d"", len(paths), i)
+	}
+}
+
+func TestWalkNested(t *testing.T) {
+	router := NewRouter()
+
+	g := router.Path(""/g"").Subrouter()
+	o := g.PathPrefix(""/o"").Subrouter()
+	r := o.PathPrefix(""/r"").Subrouter()
+	i := r.PathPrefix(""/i"").Subrouter()
+	l1 := i.PathPrefix(""/l"").Subrouter()
+	l2 := l1.PathPrefix(""/l"").Subrouter()
+	l2.Path(""/a"")
+
+	paths := []string{""/g"", ""/g/o"", ""/g/o/r"", ""/g/o/r/i"", ""/g/o/r/i/l"", ""/g/o/r/i/l/l"", ""/g/o/r/i/l/l/a""}
+	idx := 0
+	err := router.Walk(func(route *Route, router *Router, ancestors []*Route) error {
+		path := paths[idx]
+		tpl := route.regexp.path.template
+		if tpl != path {
+			t.Errorf(`Expected %s got %s`, path, tpl)
+		}
+		idx++
+		return nil
+	})
+	if err != nil {
+		panic(err)
+	}
+	if idx != len(paths) {
+		t.Errorf(""Expected %d routes, found %d"", len(paths), idx)
+	}
+}
+
 // ----------------------------------------------------------------------------
 // Helpers
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=92ae1d67265b4cf52d659a340435398e8da2ad05,https://github.com/gorilla/mux/blob/92ae1d67265b4cf52d659a340435398e8da2ad05/mux_test.go
8eb02a9f12e527fe2ce9ab3b640579a6104f2d44,77fca939afeb7aa3c08fb0d4f4d9bf515304228d,route.go,,"Wed, 08 Jul 2015 16:47:01 GMT",modified,13,0,13,"@@ -508,6 +508,19 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	}, nil
 }
 
+// URLPathTemplate returns the template used to match against for the route
+//
+// The route must have a path defined.
+func (r *Route) URLPathTemplate() (string, error) {
+	if r.err != nil {
+		return """", r.err
+	}
+	if r.regexp == nil || r.regexp.path == nil {
+		return """", errors.New(""mux: route doesn't have a path"")
+	}
+	return r.regexp.path.template, nil
+}
+
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=8eb02a9f12e527fe2ce9ab3b640579a6104f2d44,https://github.com/gorilla/mux/blob/8eb02a9f12e527fe2ce9ab3b640579a6104f2d44/route.go
9cb89f07ca03c6a28d1e237ba033bc6a29422fd6,8118aab057d8786009835cfa59e7c8cd03df3a7a,mux_test.go,,"Sun, 05 Jul 2015 23:02:00 GMT",modified,18,0,18,"@@ -561,6 +561,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route with regexp pattern with quantifier, additional variable in query string, match"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
+			request:     newRequest(""GET"", ""http://localhost?bar=2&foo=1""),
+			vars:        map[string]string{""v1"": ""1""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route with regexp pattern with quantifier, regexp does not match"",
 			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
@@ -570,6 +579,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=12""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=9cb89f07ca03c6a28d1e237ba033bc6a29422fd6,https://github.com/gorilla/mux/blob/9cb89f07ca03c6a28d1e237ba033bc6a29422fd6/mux_test.go
0c9d5c08c1d6103f2ced11750a195fc94902d3fc,d98575eec5d6c502378b1e488cca09d51f99d597,regexp.go,,"Sun, 05 Jul 2015 22:03:37 GMT",modified,9,5,14,"@@ -139,7 +139,7 @@ type routeRegexp struct {
 func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 	if !r.matchHost {
 		if r.matchQuery {
-			return r.regexp.MatchString(r.getUrlQuery(req))
+			return r.matchQueryString(req)
 		} else {
 			return r.regexp.MatchString(req.URL.Path)
 		}
@@ -177,12 +177,16 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 // For a URL with foo=bar&baz=ding, we return only the relevant key
 // value pair for the routeRegexp.
 func (r *routeRegexp) getUrlQuery(req *http.Request) string {
-	keyVal := strings.Split(r.template, ""="")
-	if len(keyVal) == 0 {
+	if !r.matchQuery {
 		return """"
 	}
-	re := regexp.MustCompile(keyVal[0] + ""[^&]*"")
-	return re.FindString(req.URL.RawQuery)
+	key := strings.Split(r.template, ""="")[0]
+	val := req.URL.Query().Get(key)
+	return key + ""="" + val
+}
+
+func (r *routeRegexp) matchQueryString(req *http.Request) bool {
+	return r.regexp.MatchString(r.getUrlQuery(req))
 }
 
 // braceIndices returns the first level curly brace indices from a string.",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=0c9d5c08c1d6103f2ced11750a195fc94902d3fc,https://github.com/gorilla/mux/blob/0c9d5c08c1d6103f2ced11750a195fc94902d3fc/regexp.go
a710a8bfa96010c24d50767a4207e34a0b9f1b90,44cc57e4c6243fe23bd74feba2bca5416833898d,mux_test.go,,"Sun, 05 Jul 2015 11:49:02 GMT",modified,18,0,18,"@@ -552,6 +552,24 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with regexp pattern with quantifier, match"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=1""),
+			vars:        map[string]string{""v1"": ""1""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with regexp pattern with quantifier, regexp does not match"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=12""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a710a8bfa96010c24d50767a4207e34a0b9f1b90,https://github.com/gorilla/mux/blob/a710a8bfa96010c24d50767a4207e34a0b9f1b90/mux_test.go
a710a8bfa96010c24d50767a4207e34a0b9f1b90,883872746d90f459b35700e661490fb0a5eb3d57,regexp.go,,"Sun, 05 Jul 2015 11:49:02 GMT",modified,16,7,23,"@@ -35,7 +35,6 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	defaultPattern := ""[^/]+""
 	if matchQuery {
 		defaultPattern = ""[^?&]+""
-		matchPrefix = true
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
 		matchPrefix = false
@@ -53,9 +52,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	varsN := make([]string, len(idxs)/2)
 	varsR := make([]*regexp.Regexp, len(idxs)/2)
 	pattern := bytes.NewBufferString("""")
-	if !matchQuery {
-		pattern.WriteByte('^')
-	}
+	pattern.WriteByte('^')
 	reverse := bytes.NewBufferString("""")
 	var end int
 	var err error
@@ -78,6 +75,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 		fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
 		// Build the reverse template.
 		fmt.Fprintf(reverse, ""%s%%s"", raw)
+
 		// Append variable name and compiled pattern.
 		varsN[i/2] = name
 		varsR[i/2], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
@@ -141,7 +139,7 @@ type routeRegexp struct {
 func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 	if !r.matchHost {
 		if r.matchQuery {
-			return r.regexp.MatchString(req.URL.RawQuery)
+			return r.regexp.MatchString(r.getUrlQuery(req))
 		} else {
 			return r.regexp.MatchString(req.URL.Path)
 		}
@@ -175,6 +173,18 @@ func (r *routeRegexp) url(values map[string]string) (string, error) {
 	return rv, nil
 }
 
+// getUrlQuery returns a single query parameter from a request URL.
+// For a URL with foo=bar&baz=ding, we return only the relevant key
+// value pair for the routeRegexp.
+func (r *routeRegexp) getUrlQuery(req *http.Request) string {
+	keyVal := strings.Split(r.template, ""="")
+	if len(keyVal) == 0 {
+		return """"
+	}
+	re := regexp.MustCompile(keyVal[0] + ""[^&]*"")
+	return re.FindString(req.URL.RawQuery)
+}
+
 // braceIndices returns the first level curly brace indices from a string.
 // It returns an error in case of unbalanced braces.
 func braceIndices(s string) ([]int, error) {
@@ -246,9 +256,8 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 		}
 	}
 	// Store query string variables.
-	rawQuery := req.URL.RawQuery
 	for _, q := range v.queries {
-		queryVars := q.regexp.FindStringSubmatch(rawQuery)
+		queryVars := q.regexp.FindStringSubmatch(q.getUrlQuery(req))
 		if queryVars != nil {
 			for k, v := range q.varsN {
 				m.Vars[v] = queryVars[k+1]",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=a710a8bfa96010c24d50767a4207e34a0b9f1b90,https://github.com/gorilla/mux/blob/a710a8bfa96010c24d50767a4207e34a0b9f1b90/regexp.go
a710a8bfa96010c24d50767a4207e34a0b9f1b90,6cb12d3c0f8858a6cd0c0896adbca60780420554,route.go,,"Sun, 05 Jul 2015 11:49:02 GMT",modified,1,1,2,"@@ -336,7 +336,7 @@ func (r *Route) Queries(pairs ...string) *Route {
 		return nil
 	}
 	for i := 0; i < length; i += 2 {
-		if r.err = r.addRegexpMatcher(pairs[i]+""=""+pairs[i+1], false, true, true); r.err != nil {
+		if r.err = r.addRegexpMatcher(pairs[i]+""=""+pairs[i+1], false, false, true); r.err != nil {
 			return r
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=a710a8bfa96010c24d50767a4207e34a0b9f1b90,https://github.com/gorilla/mux/blob/a710a8bfa96010c24d50767a4207e34a0b9f1b90/route.go
c21431a6cd004f2e4ac692b2ec8c56f3a4ebd036,aa2bedfbd4964a94400d22e7d6c441df95fd151c,mux.go,,"Sun, 05 Jul 2015 10:18:38 GMT",modified,3,4,7,"@@ -359,9 +359,7 @@ func matchInArray(arr []string, value string) bool {
 	return false
 }
 
-type equals func(interface{}, interface{}) bool
-
-// matchMap returns true if the given key/value pairs exist in a given map.
+// matchMapWithString returns true if the given key/value pairs exist in a given map.
 func matchMapWithString(toCheck map[string]string, toMatch map[string][]string, canonicalKey bool) bool {
 	for k, v := range toCheck {
 		// Check if key exists.
@@ -388,7 +386,8 @@ func matchMapWithString(toCheck map[string]string, toMatch map[string][]string,
 	return true
 }
 
-// matchMap returns true if the given key/value pairs exist in a given map.
+// matchMapWithRegex returns true if the given key/value pairs exist in a given map compiled against
+// the given regex
 func matchMapWithRegex(toCheck map[string]*regexp.Regexp, toMatch map[string][]string, canonicalKey bool) bool {
 	for k, v := range toCheck {
 		// Check if key exists.",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=c21431a6cd004f2e4ac692b2ec8c56f3a4ebd036,https://github.com/gorilla/mux/blob/c21431a6cd004f2e4ac692b2ec8c56f3a4ebd036/mux.go
c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f,442babab854e07944baa5ba391b6d6290f0bdf5e,doc.go,,"Sun, 05 Jul 2015 10:15:55 GMT",modified,7,0,7,"@@ -172,6 +172,13 @@ conform to the corresponding patterns. These requirements guarantee that a
 generated URL will always match a registered route -- the only exception is
 for explicitly defined ""build-only"" routes which never match.
 
+Regex support also exists for matching Headers within a route. For example, we could do:
+
+	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
+
+...and the route will match both requests with a Content-Type of `application/json` as well as
+`application/text`
+
 There's also a way to build only the URL host or path for a route:
 use the methods URLHost() or URLPath() instead. For the previous route,
 we would do:",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f,https://github.com/gorilla/mux/blob/c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f/doc.go
c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f,f7e3c22186b45de59637eb07e4fddee599ed05f2,mux.go,,"Sun, 05 Jul 2015 10:15:55 GMT",modified,55,5,60,"@@ -8,6 +8,7 @@ import (
 	""fmt""
 	""net/http""
 	""path""
+	""regexp""
 
 	""github.com/gorilla/context""
 )
@@ -313,20 +314,41 @@ func uniqueVars(s1, s2 []string) error {
 	return nil
 }
 
-// mapFromPairs converts variadic string parameters to a string map.
-func mapFromPairs(pairs ...string) (map[string]string, error) {
+func checkPairs(pairs ...string) (int, error) {
 	length := len(pairs)
 	if length%2 != 0 {
-		return nil, fmt.Errorf(
+		return length, fmt.Errorf(
 			""mux: number of parameters must be multiple of 2, got %v"", pairs)
 	}
+	return length, nil
+}
+
+// mapFromPairs converts variadic string parameters to a string map.
+func mapFromPairsToString(pairs ...string) (map[string]string, error) {
+	length, err := checkPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
 	m := make(map[string]string, length/2)
 	for i := 0; i < length; i += 2 {
 		m[pairs[i]] = pairs[i+1]
 	}
 	return m, nil
 }
 
+func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
+	length, err := checkPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	m := make(map[string]*regexp.Regexp, length/2)
+	for i := 0; i < length; i += 2 {
+		regex, _ := regexp.Compile(pairs[i+1])
+		m[pairs[i]] = regex
+	}
+	return m, nil
+}
+
 // matchInArray returns true if the given string value is in the array.
 func matchInArray(arr []string, value string) bool {
 	for _, v := range arr {
@@ -337,9 +359,10 @@ func matchInArray(arr []string, value string) bool {
 	return false
 }
 
+type equals func(interface{}, interface{}) bool
+
 // matchMap returns true if the given key/value pairs exist in a given map.
-func matchMap(toCheck map[string]string, toMatch map[string][]string,
-	canonicalKey bool) bool {
+func matchMapWithString(toCheck map[string]string, toMatch map[string][]string, canonicalKey bool) bool {
 	for k, v := range toCheck {
 		// Check if key exists.
 		if canonicalKey {
@@ -364,3 +387,30 @@ func matchMap(toCheck map[string]string, toMatch map[string][]string,
 	}
 	return true
 }
+
+// matchMap returns true if the given key/value pairs exist in a given map.
+func matchMapWithRegex(toCheck map[string]*regexp.Regexp, toMatch map[string][]string, canonicalKey bool) bool {
+	for k, v := range toCheck {
+		// Check if key exists.
+		if canonicalKey {
+			k = http.CanonicalHeaderKey(k)
+		}
+		if values := toMatch[k]; values == nil {
+			return false
+		} else if v != nil {
+			// If value was defined as an empty string we only check that the
+			// key exists. Otherwise we also check for equality.
+			valueExists := false
+			for _, value := range values {
+				if v.MatchString(value) {
+					valueExists = true
+					break
+				}
+			}
+			if !valueExists {
+				return false
+			}
+		}
+	}
+	return true
+}",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f,https://github.com/gorilla/mux/blob/c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f/mux.go
c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f,67f13e4819dfcba7f8858ca166e77429c1eaabba,mux_test.go,,"Sun, 05 Jul 2015 10:15:55 GMT",modified,18,0,18,"@@ -434,6 +434,24 @@ func TestHeaders(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Headers route, regex header values to match"",
+			route:       new(Route).Headers(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Headers route, regex header values to match"",
+			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baz""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f,https://github.com/gorilla/mux/blob/c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f/mux_test.go
c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f,e81723ec2e6a2f1f28ee1603a28e0b5b5a39b471,route.go,,"Sun, 05 Jul 2015 10:15:55 GMT",modified,38,6,44,"@@ -9,6 +9,7 @@ import (
 	""fmt""
 	""net/http""
 	""net/url""
+	""regexp""
 	""strings""
 )
 
@@ -188,7 +189,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 type headerMatcher map[string]string
 
 func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
-	return matchMap(m, r.Header, true)
+	return matchMapWithString(m, r.Header, true)
 }
 
 // Headers adds a matcher for request header values.
@@ -199,22 +200,53 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 //               ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both request header values match.
+// Alternatively, you can provide a regular expression and match the header as follows:
+//
+//     r.Headers(""Content-Type"", ""application/(text|json)"",
+//               ""X-Requested-With"", ""XMLHttpRequest"")
+//
+// The above route will the same as the previous example, with the addition of matching
+// application/text as well.
 //
 // It the value is an empty string, it will match any value if the key is set.
 func (r *Route) Headers(pairs ...string) *Route {
 	if r.err == nil {
 		var headers map[string]string
-		headers, r.err = mapFromPairs(pairs...)
+		headers, r.err = mapFromPairsToString(pairs...)
 		return r.addMatcher(headerMatcher(headers))
 	}
 	return r
 }
 
+// headerRegexMatcher matches the request against the route given a regex for the header
+type headerRegexMatcher map[string]*regexp.Regexp
+
+func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
+	return matchMapWithRegex(m, r.Header, true)
+}
+
+// Regular expressions can be used with headers as well.
+// It accepts a sequence of key/value pairs, where the value has regex support. For example
+//     r := mux.NewRouter()
+//     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
+//               ""X-Requested-With"", ""XMLHttpRequest"")
+//
+// The above route will only match if both the request header matches both regular expressions.
+// It the value is an empty string, it will match any value if the key is set.
+func (r *Route) HeadersRegexp(pairs ...string) *Route {
+	if r.err == nil {
+		var headers map[string]*regexp.Regexp
+		headers, r.err = mapFromPairsToRegex(pairs...)
+		return r.addMatcher(headerRegexMatcher(headers))
+	}
+	return r
+}
+
 // Host -----------------------------------------------------------------------
 
 // Host adds a matcher for the URL host.
 // It accepts a template with zero or more URL variables enclosed by {}.
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next dot.
 //
@@ -272,7 +304,7 @@ func (r *Route) Methods(methods ...string) *Route {
 // Path adds a matcher for the URL path.
 // It accepts a template with zero or more URL variables enclosed by {}. The
 // template must start with a ""/"".
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next slash.
 //
@@ -323,7 +355,7 @@ func (r *Route) PathPrefix(tpl string) *Route {
 //
 // It the value is an empty string, it will match any value if the key is set.
 //
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next slash.
 //
@@ -511,7 +543,7 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
-	m, err := mapFromPairs(pairs...)
+	m, err := mapFromPairsToString(pairs...)
 	if err != nil {
 		return nil, err
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f,https://github.com/gorilla/mux/blob/c0a5cbce5acc7d44030541b8b383b1ebcdfcc96f/route.go
a063f14812c8ea1ae2a62a8d9b2307afe23348a7,442babab854e07944baa5ba391b6d6290f0bdf5e,doc.go,,"Sun, 05 Jul 2015 10:12:48 GMT",modified,7,0,7,"@@ -172,6 +172,13 @@ conform to the corresponding patterns. These requirements guarantee that a
 generated URL will always match a registered route -- the only exception is
 for explicitly defined ""build-only"" routes which never match.
 
+Regex support also exists for matching Headers within a route. For example, we could do:
+
+	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"")
+
+...and the route will match both requests with a Content-Type of `application/json` as well as
+`application/text`
+
 There's also a way to build only the URL host or path for a route:
 use the methods URLHost() or URLPath() instead. For the previous route,
 we would do:",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=a063f14812c8ea1ae2a62a8d9b2307afe23348a7,https://github.com/gorilla/mux/blob/a063f14812c8ea1ae2a62a8d9b2307afe23348a7/doc.go
a063f14812c8ea1ae2a62a8d9b2307afe23348a7,f7e3c22186b45de59637eb07e4fddee599ed05f2,mux.go,,"Sun, 05 Jul 2015 10:12:48 GMT",modified,55,5,60,"@@ -8,6 +8,7 @@ import (
 	""fmt""
 	""net/http""
 	""path""
+	""regexp""
 
 	""github.com/gorilla/context""
 )
@@ -313,20 +314,41 @@ func uniqueVars(s1, s2 []string) error {
 	return nil
 }
 
-// mapFromPairs converts variadic string parameters to a string map.
-func mapFromPairs(pairs ...string) (map[string]string, error) {
+func checkPairs(pairs ...string) (int, error) {
 	length := len(pairs)
 	if length%2 != 0 {
-		return nil, fmt.Errorf(
+		return length, fmt.Errorf(
 			""mux: number of parameters must be multiple of 2, got %v"", pairs)
 	}
+	return length, nil
+}
+
+// mapFromPairs converts variadic string parameters to a string map.
+func mapFromPairsToString(pairs ...string) (map[string]string, error) {
+	length, err := checkPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
 	m := make(map[string]string, length/2)
 	for i := 0; i < length; i += 2 {
 		m[pairs[i]] = pairs[i+1]
 	}
 	return m, nil
 }
 
+func mapFromPairsToRegex(pairs ...string) (map[string]*regexp.Regexp, error) {
+	length, err := checkPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	m := make(map[string]*regexp.Regexp, length/2)
+	for i := 0; i < length; i += 2 {
+		regex, _ := regexp.Compile(pairs[i+1])
+		m[pairs[i]] = regex
+	}
+	return m, nil
+}
+
 // matchInArray returns true if the given string value is in the array.
 func matchInArray(arr []string, value string) bool {
 	for _, v := range arr {
@@ -337,9 +359,10 @@ func matchInArray(arr []string, value string) bool {
 	return false
 }
 
+type equals func(interface{}, interface{}) bool
+
 // matchMap returns true if the given key/value pairs exist in a given map.
-func matchMap(toCheck map[string]string, toMatch map[string][]string,
-	canonicalKey bool) bool {
+func matchMapWithString(toCheck map[string]string, toMatch map[string][]string, canonicalKey bool) bool {
 	for k, v := range toCheck {
 		// Check if key exists.
 		if canonicalKey {
@@ -364,3 +387,30 @@ func matchMap(toCheck map[string]string, toMatch map[string][]string,
 	}
 	return true
 }
+
+// matchMap returns true if the given key/value pairs exist in a given map.
+func matchMapWithRegex(toCheck map[string]*regexp.Regexp, toMatch map[string][]string, canonicalKey bool) bool {
+	for k, v := range toCheck {
+		// Check if key exists.
+		if canonicalKey {
+			k = http.CanonicalHeaderKey(k)
+		}
+		if values := toMatch[k]; values == nil {
+			return false
+		} else if v != nil {
+			// If value was defined as an empty string we only check that the
+			// key exists. Otherwise we also check for equality.
+			valueExists := false
+			for _, value := range values {
+				if v.MatchString(value) {
+					valueExists = true
+					break
+				}
+			}
+			if !valueExists {
+				return false
+			}
+		}
+	}
+	return true
+}",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=a063f14812c8ea1ae2a62a8d9b2307afe23348a7,https://github.com/gorilla/mux/blob/a063f14812c8ea1ae2a62a8d9b2307afe23348a7/mux.go
a063f14812c8ea1ae2a62a8d9b2307afe23348a7,67f13e4819dfcba7f8858ca166e77429c1eaabba,mux_test.go,,"Sun, 05 Jul 2015 10:12:48 GMT",modified,18,0,18,"@@ -434,6 +434,24 @@ func TestHeaders(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Headers route, regex header values to match"",
+			route:       new(Route).Headers(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Headers route, regex header values to match"",
+			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baz""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a063f14812c8ea1ae2a62a8d9b2307afe23348a7,https://github.com/gorilla/mux/blob/a063f14812c8ea1ae2a62a8d9b2307afe23348a7/mux_test.go
a063f14812c8ea1ae2a62a8d9b2307afe23348a7,e81723ec2e6a2f1f28ee1603a28e0b5b5a39b471,route.go,,"Sun, 05 Jul 2015 10:12:48 GMT",modified,38,6,44,"@@ -9,6 +9,7 @@ import (
 	""fmt""
 	""net/http""
 	""net/url""
+	""regexp""
 	""strings""
 )
 
@@ -188,7 +189,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 type headerMatcher map[string]string
 
 func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
-	return matchMap(m, r.Header, true)
+	return matchMapWithString(m, r.Header, true)
 }
 
 // Headers adds a matcher for request header values.
@@ -199,22 +200,53 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 //               ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both request header values match.
+// Alternatively, you can provide a regular expression and match the header as follows:
+//
+//     r.Headers(""Content-Type"", ""application/(text|json)"",
+//               ""X-Requested-With"", ""XMLHttpRequest"")
+//
+// The above route will the same as the previous example, with the addition of matching
+// application/text as well.
 //
 // It the value is an empty string, it will match any value if the key is set.
 func (r *Route) Headers(pairs ...string) *Route {
 	if r.err == nil {
 		var headers map[string]string
-		headers, r.err = mapFromPairs(pairs...)
+		headers, r.err = mapFromPairsToString(pairs...)
 		return r.addMatcher(headerMatcher(headers))
 	}
 	return r
 }
 
+// headerRegexMatcher matches the request against the route given a regex for the header
+type headerRegexMatcher map[string]*regexp.Regexp
+
+func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
+	return matchMapWithRegex(m, r.Header, true)
+}
+
+// Regular expressions can be used with headers as well.
+// It accepts a sequence of key/value pairs, where the value has regex support. For example
+//     r := mux.NewRouter()
+//     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
+//               ""X-Requested-With"", ""XMLHttpRequest"")
+//
+// The above route will only match if both the request header matches both regular expressions.
+// It the value is an empty string, it will match any value if the key is set.
+func (r *Route) HeadersRegexp(pairs ...string) *Route {
+	if r.err == nil {
+		var headers map[string]*regexp.Regexp
+		headers, r.err = mapFromPairsToRegex(pairs...)
+		return r.addMatcher(headerRegexMatcher(headers))
+	}
+	return r
+}
+
 // Host -----------------------------------------------------------------------
 
 // Host adds a matcher for the URL host.
 // It accepts a template with zero or more URL variables enclosed by {}.
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next dot.
 //
@@ -272,7 +304,7 @@ func (r *Route) Methods(methods ...string) *Route {
 // Path adds a matcher for the URL path.
 // It accepts a template with zero or more URL variables enclosed by {}. The
 // template must start with a ""/"".
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next slash.
 //
@@ -323,7 +355,7 @@ func (r *Route) PathPrefix(tpl string) *Route {
 //
 // It the value is an empty string, it will match any value if the key is set.
 //
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next slash.
 //
@@ -511,7 +543,7 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
-	m, err := mapFromPairs(pairs...)
+	m, err := mapFromPairsToString(pairs...)
 	if err != nil {
 		return nil, err
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=a063f14812c8ea1ae2a62a8d9b2307afe23348a7,https://github.com/gorilla/mux/blob/a063f14812c8ea1ae2a62a8d9b2307afe23348a7/route.go
47e8f450ef38c857cdd922ec08862ca9d65a1c6d,00d230026350d91d7fd26f18f62728ba19cbc846,route.go,,"Sat, 30 May 2015 19:53:56 GMT",modified,3,3,6,"@@ -214,7 +214,7 @@ func (r *Route) Headers(pairs ...string) *Route {
 
 // Host adds a matcher for the URL host.
 // It accepts a template with zero or more URL variables enclosed by {}.
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next dot.
 //
@@ -272,7 +272,7 @@ func (r *Route) Methods(methods ...string) *Route {
 // Path adds a matcher for the URL path.
 // It accepts a template with zero or more URL variables enclosed by {}. The
 // template must start with a ""/"".
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next slash.
 //
@@ -323,7 +323,7 @@ func (r *Route) PathPrefix(tpl string) *Route {
 //
 // It the value is an empty string, it will match any value if the key is set.
 //
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next slash.
 //",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=47e8f450ef38c857cdd922ec08862ca9d65a1c6d,https://github.com/gorilla/mux/blob/47e8f450ef38c857cdd922ec08862ca9d65a1c6d/route.go
77f424d3ae04bf4130e489900890fa84992d9b40,00d230026350d91d7fd26f18f62728ba19cbc846,route.go,,"Fri, 29 May 2015 21:16:30 GMT",modified,3,3,6,"@@ -214,7 +214,7 @@ func (r *Route) Headers(pairs ...string) *Route {
 
 // Host adds a matcher for the URL host.
 // It accepts a template with zero or more URL variables enclosed by {}.
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next dot.
 //
@@ -272,7 +272,7 @@ func (r *Route) Methods(methods ...string) *Route {
 // Path adds a matcher for the URL path.
 // It accepts a template with zero or more URL variables enclosed by {}. The
 // template must start with a ""/"".
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next slash.
 //
@@ -323,7 +323,7 @@ func (r *Route) PathPrefix(tpl string) *Route {
 //
 // It the value is an empty string, it will match any value if the key is set.
 //
-// Variables can define an optional regexp pattern to me matched:
+// Variables can define an optional regexp pattern to be matched:
 //
 // - {name} matches anything until the next slash.
 //",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=77f424d3ae04bf4130e489900890fa84992d9b40,https://github.com/gorilla/mux/blob/77f424d3ae04bf4130e489900890fa84992d9b40/route.go
94903de8c98a68d8b4483c529b26a5d146e386a2,6b2c1d22f7268c3bfa94b96dd013ba7ba111b90f,mux_test.go,,"Tue, 05 May 2015 17:01:36 GMT",modified,9,0,9,"@@ -162,6 +162,15 @@ func TestHost(t *testing.T) {
 			path:        ""/a/product_name/1"",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Path route with multiple patterns with pipe, match"",
+			route:       new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
+			vars:        map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
+			host:        """",
+			path:        ""/b/c/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 	for _, test := range tests {
 		testRoute(t, test)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=94903de8c98a68d8b4483c529b26a5d146e386a2,https://github.com/gorilla/mux/blob/94903de8c98a68d8b4483c529b26a5d146e386a2/mux_test.go
660d31f8602b95058fed6833debf113e85350868,9a5e381a22f4d6403306e70774525ae68b025bf9,doc.go,,"Wed, 22 Apr 2015 20:14:49 GMT",modified,5,5,10,"@@ -89,7 +89,7 @@ There are several other matchers that can be added. To match path prefixes:
 
 	r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
 		return r.ProtoMajor == 0
-    })
+	})
 
 ...and finally, it is possible to combine several matchers in a single route:
 
@@ -164,8 +164,8 @@ This also works for host variables:
 
 	// url.String() will be ""http://news.domain.com/articles/technology/42""
 	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-									 ""category"", ""technology"",
-									 ""id"", ""42"")
+	                                 ""category"", ""technology"",
+	                                 ""id"", ""42"")
 
 All variables defined in the route are required, and their values must
 conform to the corresponding patterns. These requirements guarantee that a
@@ -193,7 +193,7 @@ as well:
 
 	// ""http://news.domain.com/articles/technology/42""
 	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-									 ""category"", ""technology"",
-									 ""id"", ""42"")
+	                                 ""category"", ""technology"",
+	                                 ""id"", ""42"")
 */
 package mux",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=660d31f8602b95058fed6833debf113e85350868,https://github.com/gorilla/mux/blob/660d31f8602b95058fed6833debf113e85350868/doc.go
9641367e95358701e3b0b36e09090c8c10131e0c,9a5e381a22f4d6403306e70774525ae68b025bf9,doc.go,,"Wed, 22 Apr 2015 19:28:32 GMT",modified,5,5,10,"@@ -89,7 +89,7 @@ There are several other matchers that can be added. To match path prefixes:
 
 	r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
 		return r.ProtoMajor == 0
-    })
+	})
 
 ...and finally, it is possible to combine several matchers in a single route:
 
@@ -164,8 +164,8 @@ This also works for host variables:
 
 	// url.String() will be ""http://news.domain.com/articles/technology/42""
 	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-									 ""category"", ""technology"",
-									 ""id"", ""42"")
+	                                 ""category"", ""technology"",
+	                                 ""id"", ""42"")
 
 All variables defined in the route are required, and their values must
 conform to the corresponding patterns. These requirements guarantee that a
@@ -193,7 +193,7 @@ as well:
 
 	// ""http://news.domain.com/articles/technology/42""
 	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-									 ""category"", ""technology"",
-									 ""id"", ""42"")
+	                                 ""category"", ""technology"",
+	                                 ""id"", ""42"")
 */
 package mux",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=9641367e95358701e3b0b36e09090c8c10131e0c,https://github.com/gorilla/mux/blob/9641367e95358701e3b0b36e09090c8c10131e0c/doc.go
8096f47503459bcc74d1f4c487b7e6e42e5746b5,075dedba48e6c1771d9d0565ae636deb75bef505,mux_test.go,,"Wed, 11 Mar 2015 03:17:35 GMT",modified,27,0,27,"@@ -135,6 +135,33 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Path route with single pattern with pipe, match"",
+			route:       new(Route).Path(""/{category:a|b/c}""),
+			request:     newRequest(""GET"", ""http://localhost/a""),
+			vars:        map[string]string{""category"": ""a""},
+			host:        """",
+			path:        ""/a"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with single pattern with pipe, match"",
+			route:       new(Route).Path(""/{category:a|b/c}""),
+			request:     newRequest(""GET"", ""http://localhost/b/c""),
+			vars:        map[string]string{""category"": ""b/c""},
+			host:        """",
+			path:        ""/b/c"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple patterns with pipe, match"",
+			route:       new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:        """",
+			path:        ""/a/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 	for _, test := range tests {
 		testRoute(t, test)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=8096f47503459bcc74d1f4c487b7e6e42e5746b5,https://github.com/gorilla/mux/blob/8096f47503459bcc74d1f4c487b7e6e42e5746b5/mux_test.go
e98fd88cbd7216fd46d0b480a047d34748d603d5,6b2c1d22f7268c3bfa94b96dd013ba7ba111b90f,mux_test.go,,"Wed, 11 Mar 2015 01:48:38 GMT",modified,9,0,9,"@@ -162,6 +162,15 @@ func TestHost(t *testing.T) {
 			path:        ""/a/product_name/1"",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Path route with multiple patterns with pipe, match"",
+			route:       new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/b/c/product_name/1""),
+			vars:        map[string]string{""category"": ""b/c"", ""product"": ""product_name"", ""id"": ""1""},
+			host:        """",
+			path:        ""/b/c/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 	for _, test := range tests {
 		testRoute(t, test)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e98fd88cbd7216fd46d0b480a047d34748d603d5,https://github.com/gorilla/mux/blob/e98fd88cbd7216fd46d0b480a047d34748d603d5/mux_test.go
00bf0e01a12e9ce13adef15e5ddb53700d90bd81,075dedba48e6c1771d9d0565ae636deb75bef505,mux_test.go,,"Wed, 11 Mar 2015 01:38:35 GMT",modified,27,0,27,"@@ -135,6 +135,33 @@ func TestHost(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Path route with single pattern with pipe, match"",
+			route:       new(Route).Path(""/{category:a|b/c}""),
+			request:     newRequest(""GET"", ""http://localhost/a""),
+			vars:        map[string]string{""category"": ""a""},
+			host:        """",
+			path:        ""/a"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with single pattern with pipe, match"",
+			route:       new(Route).Path(""/{category:a|b/c}""),
+			request:     newRequest(""GET"", ""http://localhost/b/c""),
+			vars:        map[string]string{""category"": ""b/c""},
+			host:        """",
+			path:        ""/b/c"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple patterns with pipe, match"",
+			route:       new(Route).Path(""/{category:a|b/c}/{product}/{id:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost/a/product_name/1""),
+			vars:        map[string]string{""category"": ""a"", ""product"": ""product_name"", ""id"": ""1""},
+			host:        """",
+			path:        ""/a/product_name/1"",
+			shouldMatch: true,
+		},
 	}
 	for _, test := range tests {
 		testRoute(t, test)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=00bf0e01a12e9ce13adef15e5ddb53700d90bd81,https://github.com/gorilla/mux/blob/00bf0e01a12e9ce13adef15e5ddb53700d90bd81/mux_test.go
8a875a034c69b940914d83ea03d3f1299b4d094b,af31d239557803eee569ebe0926d91cd91df196f,mux.go,,"Fri, 13 Feb 2015 19:22:55 GMT",modified,13,0,13,"@@ -152,6 +152,13 @@ func (r *Router) getRegexpGroup() *routeRegexpGroup {
 	return nil
 }
 
+func (r *Router) buildVars(m map[string]string) map[string]string {
+	if r.parent != nil {
+		m = r.parent.buildVars(m)
+	}
+	return m
+}
+
 // ----------------------------------------------------------------------------
 // Route factories
 // ----------------------------------------------------------------------------
@@ -224,6 +231,12 @@ func (r *Router) Schemes(schemes ...string) *Route {
 	return r.NewRoute().Schemes(schemes...)
 }
 
+// BuildVars registers a new route with a custom function for modifying
+// route variables before building a URL.
+func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
+	return r.NewRoute().BuildVarsFunc(f)
+}
+
 // ----------------------------------------------------------------------------
 // Context
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=8a875a034c69b940914d83ea03d3f1299b4d094b,https://github.com/gorilla/mux/blob/8a875a034c69b940914d83ea03d3f1299b4d094b/mux.go
8a875a034c69b940914d83ea03d3f1299b4d094b,c37be8a19ebbc4bfe8a93aa04a1846c1969b7888,mux_test.go,,"Fri, 13 Feb 2015 19:22:55 GMT",modified,33,0,33,"@@ -593,6 +593,39 @@ func TestMatcherFunc(t *testing.T) {
 	}
 }
 
+func TestBuildVarsFunc(t *testing.T) {
+	tests := []routeTest{
+		{
+			title: ""BuildVarsFunc set on route"",
+			route: new(Route).Path(`/111/{v1:\d}{v2:.*}`).BuildVarsFunc(func(vars map[string]string) map[string]string {
+				vars[""v1""] = ""3""
+				vars[""v2""] = ""a""
+				return vars
+			}),
+			request:     newRequest(""GET"", ""http://localhost/111/2""),
+			path:        ""/111/3a"",
+			shouldMatch: true,
+		},
+		{
+			title: ""BuildVarsFunc set on route and parent route"",
+			route: new(Route).PathPrefix(`/{v1:\d}`).BuildVarsFunc(func(vars map[string]string) map[string]string {
+				vars[""v1""] = ""2""
+				return vars
+			}).Subrouter().Path(`/{v2:\w}`).BuildVarsFunc(func(vars map[string]string) map[string]string {
+				vars[""v2""] = ""b""
+				return vars
+			}),
+			request:     newRequest(""GET"", ""http://localhost/1/a""),
+			path:        ""/2/b"",
+			shouldMatch: true,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
 func TestSubRouter(t *testing.T) {
 	subrouter1 := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
 	subrouter2 := new(Route).PathPrefix(""/foo/{v1}"").Subrouter()",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=8a875a034c69b940914d83ea03d3f1299b4d094b,https://github.com/gorilla/mux/blob/8a875a034c69b940914d83ea03d3f1299b4d094b/mux_test.go
8a875a034c69b940914d83ea03d3f1299b4d094b,aa3067986c5e261cd56aae0d8dcd83365b0459b8,regexp.go,,"Fri, 13 Feb 2015 19:22:55 GMT",modified,1,5,6,"@@ -150,11 +150,7 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 }
 
 // url builds a URL part using the given values.
-func (r *routeRegexp) url(pairs ...string) (string, error) {
-	values, err := mapFromPairs(pairs...)
-	if err != nil {
-		return """", err
-	}
+func (r *routeRegexp) url(values map[string]string) (string, error) {
 	urlValues := make([]interface{}, len(r.varsN))
 	for k, v := range r.varsN {
 		value, ok := values[v]",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=8a875a034c69b940914d83ea03d3f1299b4d094b,https://github.com/gorilla/mux/blob/8a875a034c69b940914d83ea03d3f1299b4d094b/regexp.go
8a875a034c69b940914d83ea03d3f1299b4d094b,d4f014688526a6ce58b89a31f15b00ab5ca2d85c,route.go,,"Fri, 13 Feb 2015 19:22:55 GMT",modified,52,5,57,"@@ -31,6 +31,8 @@ type Route struct {
 	name string
 	// Error resulted from building a route.
 	err error
+
+	buildVarsFunc BuildVarsFunc
 }
 
 // Match matches the route against the request.
@@ -360,6 +362,19 @@ func (r *Route) Schemes(schemes ...string) *Route {
 	return r.addMatcher(schemeMatcher(schemes))
 }
 
+// BuildVarsFunc --------------------------------------------------------------
+
+// BuildVarsFunc is the function signature used by custom build variable
+// functions (which can modify route variables before a route's URL is built).
+type BuildVarsFunc func(map[string]string) map[string]string
+
+// BuildVarsFunc adds a custom function to be used to modify build variables
+// before a route's URL is built.
+func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
+	r.buildVarsFunc = f
+	return r
+}
+
 // Subrouter ------------------------------------------------------------------
 
 // Subrouter creates a subrouter for the route.
@@ -422,17 +437,20 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil {
 		return nil, errors.New(""mux: route doesn't have a host or path"")
 	}
+	values, err := r.prepareVars(pairs...)
+	if err != nil {
+		return nil, err
+	}
 	var scheme, host, path string
-	var err error
 	if r.regexp.host != nil {
 		// Set a default scheme.
 		scheme = ""http""
-		if host, err = r.regexp.host.url(pairs...); err != nil {
+		if host, err = r.regexp.host.url(values); err != nil {
 			return nil, err
 		}
 	}
 	if r.regexp.path != nil {
-		if path, err = r.regexp.path.url(pairs...); err != nil {
+		if path, err = r.regexp.path.url(values); err != nil {
 			return nil, err
 		}
 	}
@@ -453,7 +471,11 @@ func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil || r.regexp.host == nil {
 		return nil, errors.New(""mux: route doesn't have a host"")
 	}
-	host, err := r.regexp.host.url(pairs...)
+	values, err := r.prepareVars(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	host, err := r.regexp.host.url(values)
 	if err != nil {
 		return nil, err
 	}
@@ -473,7 +495,11 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil || r.regexp.path == nil {
 		return nil, errors.New(""mux: route doesn't have a path"")
 	}
-	path, err := r.regexp.path.url(pairs...)
+	values, err := r.prepareVars(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	path, err := r.regexp.path.url(values)
 	if err != nil {
 		return nil, err
 	}
@@ -482,6 +508,26 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	}, nil
 }
 
+// prepareVars converts the route variable pairs into a map. If the route has a
+// BuildVarsFunc, it is invoked.
+func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
+	m, err := mapFromPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	return r.buildVars(m), nil
+}
+
+func (r *Route) buildVars(m map[string]string) map[string]string {
+	if r.parent != nil {
+		m = r.parent.buildVars(m)
+	}
+	if r.buildVarsFunc != nil {
+		m = r.buildVarsFunc(m)
+	}
+	return m
+}
+
 // ----------------------------------------------------------------------------
 // parentRoute
 // ----------------------------------------------------------------------------
@@ -490,6 +536,7 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 type parentRoute interface {
 	getNamedRoutes() map[string]*Route
 	getRegexpGroup() *routeRegexpGroup
+	buildVars(map[string]string) map[string]string
 }
 
 // getNamedRoutes returns the map where named routes are registered.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=8a875a034c69b940914d83ea03d3f1299b4d094b,https://github.com/gorilla/mux/blob/8a875a034c69b940914d83ea03d3f1299b4d094b/route.go
e444e69cbd2e2e3e0749a2f3c717cec491552bbf,a6305483d5ae5c4b15b0919fda72986eb2d064ca,regexp.go,,"Fri, 26 Sep 2014 15:38:14 GMT",modified,13,11,24,"@@ -35,12 +35,13 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	defaultPattern := ""[^/]+""
 	if matchQuery {
 		defaultPattern = ""[^?&]+""
-		matchPrefix, strictSlash = true, false
+		matchPrefix = true
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
-		matchPrefix, strictSlash = false, false
+		matchPrefix = false
 	}
-	if matchPrefix {
+	// Only match strict slash if not matching
+	if matchPrefix || matchHost || matchQuery {
 		strictSlash = false
 	}
 	// Set a flag for strictSlash.
@@ -262,13 +263,14 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 
 // getHost tries its best to return the request host.
 func getHost(r *http.Request) string {
-	if !r.URL.IsAbs() {
-		host := r.Host
-		// Slice off any port information.
-		if i := strings.Index(host, "":""); i != -1 {
-			host = host[:i]
-		}
-		return host
+	if r.URL.IsAbs() {
+		return r.URL.Host
+	}
+	host := r.Host
+	// Slice off any port information.
+	if i := strings.Index(host, "":""); i != -1 {
+		host = host[:i]
 	}
-	return r.URL.Host
+	return host
+
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=e444e69cbd2e2e3e0749a2f3c717cec491552bbf,https://github.com/gorilla/mux/blob/e444e69cbd2e2e3e0749a2f3c717cec491552bbf/regexp.go
d7e46398189abd89d18d874e3c53b42d492002b8,a6305483d5ae5c4b15b0919fda72986eb2d064ca,regexp.go,,"Fri, 26 Sep 2014 05:20:46 GMT",modified,4,3,7,"@@ -35,12 +35,13 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	defaultPattern := ""[^/]+""
 	if matchQuery {
 		defaultPattern = ""[^?&]+""
-		matchPrefix, strictSlash = true, false
+		matchPrefix = true
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
-		matchPrefix, strictSlash = false, false
+		matchPrefix = false
 	}
-	if matchPrefix {
+	// Only match strict slash if not matching
+	if matchPrefix || matchHost || matchQuery {
 		strictSlash = false
 	}
 	// Set a flag for strictSlash.",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=d7e46398189abd89d18d874e3c53b42d492002b8,https://github.com/gorilla/mux/blob/d7e46398189abd89d18d874e3c53b42d492002b8/regexp.go
8df3a80fb8cd2b280d3b0b7d809ad80c1d0be236,35c8177f7a13c3612a39e9e366be924dd446c44a,regexp.go,,"Fri, 26 Sep 2014 05:20:12 GMT",modified,9,8,17,"@@ -262,13 +262,14 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 
 // getHost tries its best to return the request host.
 func getHost(r *http.Request) string {
-	if !r.URL.IsAbs() {
-		host := r.Host
-		// Slice off any port information.
-		if i := strings.Index(host, "":""); i != -1 {
-			host = host[:i]
-		}
-		return host
+	if r.URL.IsAbs() {
+		return r.URL.Host
+	}
+	host := r.Host
+	// Slice off any port information.
+	if i := strings.Index(host, "":""); i != -1 {
+		host = host[:i]
 	}
-	return r.URL.Host
+	return host
+
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=8df3a80fb8cd2b280d3b0b7d809ad80c1d0be236,https://github.com/gorilla/mux/blob/8df3a80fb8cd2b280d3b0b7d809ad80c1d0be236/regexp.go
4b8fbc56f3b2400a7c7ea3dba9b3539787c486b6,c310e66bc7c3f1f6b4b33e9263ea2d8336de26d5,route.go,,"Mon, 11 Aug 2014 14:46:53 GMT",modified,0,1,1,"@@ -326,7 +326,6 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // - {name} matches anything until the next slash.
 //
 // - {name:pattern} matches the given regexp pattern.
-
 func (r *Route) Queries(pairs ...string) *Route {
 	length := len(pairs)
 	if length%2 != 0 {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=4b8fbc56f3b2400a7c7ea3dba9b3539787c486b6,https://github.com/gorilla/mux/blob/4b8fbc56f3b2400a7c7ea3dba9b3539787c486b6/route.go
8f1a419c38688087a65a29395ac483f7b113c745,c310e66bc7c3f1f6b4b33e9263ea2d8336de26d5,route.go,,"Mon, 11 Aug 2014 14:45:39 GMT",modified,0,1,1,"@@ -326,7 +326,6 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // - {name} matches anything until the next slash.
 //
 // - {name:pattern} matches the given regexp pattern.
-
 func (r *Route) Queries(pairs ...string) *Route {
 	length := len(pairs)
 	if length%2 != 0 {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=8f1a419c38688087a65a29395ac483f7b113c745,https://github.com/gorilla/mux/blob/8f1a419c38688087a65a29395ac483f7b113c745/route.go
14cafe28513321476c73967a5a4f3454b6129c46,1f7c190c0f972df39a84f078b5f7a15fbe3af569,old_test.go,,"Tue, 24 Jun 2014 18:46:26 GMT",modified,0,1,1,"@@ -490,7 +490,6 @@ func TestPathMatcher(t *testing.T) {
 	}
 }
 
-
 func TestSchemeMatcher(t *testing.T) {
 	for _, v := range schemeMatcherTests {
 		request, _ := http.NewRequest(""GET"", v.url, nil)",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=14cafe28513321476c73967a5a4f3454b6129c46,https://github.com/gorilla/mux/blob/14cafe28513321476c73967a5a4f3454b6129c46/old_test.go
3351f602a5ba82692d059fad533e58702e0cb5ce,1f7c190c0f972df39a84f078b5f7a15fbe3af569,old_test.go,,"Tue, 24 Jun 2014 18:40:51 GMT",modified,0,1,1,"@@ -490,7 +490,6 @@ func TestPathMatcher(t *testing.T) {
 	}
 }
 
-
 func TestSchemeMatcher(t *testing.T) {
 	for _, v := range schemeMatcherTests {
 		request, _ := http.NewRequest(""GET"", v.url, nil)",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=3351f602a5ba82692d059fad533e58702e0cb5ce,https://github.com/gorilla/mux/blob/3351f602a5ba82692d059fad533e58702e0cb5ce/old_test.go
854d482e26505d59549690719cbc009f04042c2e,5b5f8e7db5dc1eb85c5fec53dfccf73b6b68c839,mux.go,,"Wed, 04 Jun 2014 21:12:38 GMT",modified,3,3,6,"@@ -87,10 +87,10 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		setCurrentRoute(req, match.Route)
 	}
 	if handler == nil {
-		if r.NotFoundHandler == nil {
-			r.NotFoundHandler = http.NotFoundHandler()
-		}
 		handler = r.NotFoundHandler
+		if handler == nil {
+			handler = http.NotFoundHandler()
+		}
 	}
 	if !r.KeepContext {
 		defer context.Clear(req)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=854d482e26505d59549690719cbc009f04042c2e,https://github.com/gorilla/mux/blob/854d482e26505d59549690719cbc009f04042c2e/mux.go
0ef595e787efa95d68151570ead5c85dc2e05f91,e455bce8fdfeec4dde99edc02ec9ee59110fe5f6,mux_test.go,,"Tue, 27 May 2014 23:41:47 GMT",modified,9,0,9,"@@ -462,6 +462,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route, match with a query string out of order"",
+			route:       new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route, bad query"",
 			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=0ef595e787efa95d68151570ead5c85dc2e05f91,https://github.com/gorilla/mux/blob/0ef595e787efa95d68151570ead5c85dc2e05f91/mux_test.go
0ef595e787efa95d68151570ead5c85dc2e05f91,ef1db8ff98ab4a4915faed0dabfb7311502ba80c,regexp.go,,"Tue, 27 May 2014 23:41:47 GMT",modified,11,10,21,"@@ -34,7 +34,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
 	if matchQuery {
-		defaultPattern = ""[^?]+""
+		defaultPattern = ""[^?&]+""
 		matchPrefix, strictSlash = true, false
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
@@ -51,9 +51,9 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	}
 	varsN := make([]string, len(idxs)/2)
 	varsR := make([]*regexp.Regexp, len(idxs)/2)
-	pattern := bytes.NewBufferString(""^"")
-	if matchQuery {
-		pattern = bytes.NewBufferString("""")
+	pattern := bytes.NewBufferString("""")
+	if !matchQuery {
+		pattern.WriteByte('^')
 	}
 	reverse := bytes.NewBufferString("""")
 	var end int
@@ -209,9 +209,9 @@ func braceIndices(s string) ([]int, error) {
 
 // routeRegexpGroup groups the route matchers that carry variables.
 type routeRegexpGroup struct {
-	host  *routeRegexp
-	path  *routeRegexp
-	query *routeRegexp
+	host    *routeRegexp
+	path    *routeRegexp
+	queries []*routeRegexp
 }
 
 // setMatch extracts the variables from the URL once a route matches.
@@ -249,10 +249,11 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 		}
 	}
 	// Store query string variables.
-	if v.query != nil {
-		queryVars := v.query.regexp.FindStringSubmatch(req.URL.RawQuery)
+	rawQuery := req.URL.RawQuery
+	for _, q := range v.queries {
+		queryVars := q.regexp.FindStringSubmatch(rawQuery)
 		if queryVars != nil {
-			for k, v := range v.query.varsN {
+			for k, v := range q.varsN {
 				m.Vars[v] = queryVars[k+1]
 			}
 		}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=0ef595e787efa95d68151570ead5c85dc2e05f91,https://github.com/gorilla/mux/blob/0ef595e787efa95d68151570ead5c85dc2e05f91/regexp.go
0ef595e787efa95d68151570ead5c85dc2e05f91,4fb85f714ec49b6ed062c772737a9a242afd7bab,route.go,,"Tue, 27 May 2014 23:41:47 GMT",modified,12,24,36,"@@ -5,7 +5,6 @@
 package mux
 
 import (
-	""bytes""
 	""errors""
 	""fmt""
 	""net/http""
@@ -153,17 +152,17 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 	if err != nil {
 		return err
 	}
+	for _, q := range r.regexp.queries {
+		if err = uniqueVars(rr.varsN, q.varsN); err != nil {
+			return err
+		}
+	}
 	if matchHost {
 		if r.regexp.path != nil {
 			if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
 				return err
 			}
 		}
-		if r.regexp.query != nil {
-			if err = uniqueVars(rr.varsN, r.regexp.query.varsN); err != nil {
-				return err
-			}
-		}
 		r.regexp.host = rr
 	} else {
 		if r.regexp.host != nil {
@@ -172,18 +171,8 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 			}
 		}
 		if matchQuery {
-			if r.regexp.path != nil {
-				if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
-					return err
-				}
-			}
-			r.regexp.query = rr
+			r.regexp.queries = append(r.regexp.queries, rr)
 		} else {
-			if r.regexp.query != nil {
-				if err = uniqueVars(rr.varsN, r.regexp.query.varsN); err != nil {
-					return err
-				}
-			}
 			r.regexp.path = rr
 		}
 	}
@@ -345,12 +334,11 @@ func (r *Route) Queries(pairs ...string) *Route {
 			""mux: number of parameters must be multiple of 2, got %v"", pairs)
 		return nil
 	}
-	var buf bytes.Buffer
 	for i := 0; i < length; i += 2 {
-		buf.WriteString(fmt.Sprintf(""%s=%s&"", pairs[i], pairs[i+1]))
+		if r.err = r.addRegexpMatcher(pairs[i]+""=""+pairs[i+1], false, true, true); r.err != nil {
+			return r
+		}
 	}
-	tpl := strings.TrimRight(buf.String(), ""&"")
-	r.err = r.addRegexpMatcher(tpl, false, true, true)
 
 	return r
 }
@@ -527,9 +515,9 @@ func (r *Route) getRegexpGroup() *routeRegexpGroup {
 		} else {
 			// Copy.
 			r.regexp = &routeRegexpGroup{
-				host:  regexp.host,
-				path:  regexp.path,
-				query: regexp.query,
+				host:    regexp.host,
+				path:    regexp.path,
+				queries: regexp.queries,
 			}
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=0ef595e787efa95d68151570ead5c85dc2e05f91,https://github.com/gorilla/mux/blob/0ef595e787efa95d68151570ead5c85dc2e05f91/route.go
451fd8b7796015afbe01cfe9168e4c51e8b40013,ef1db8ff98ab4a4915faed0dabfb7311502ba80c,regexp.go,,"Tue, 27 May 2014 23:37:30 GMT",modified,6,8,14,"@@ -249,14 +249,12 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 		}
 	}
 	// Store query string variables.
-	if v.queries != nil && len(v.queries) > 0 {
-		rawQuery := req.URL.RawQuery
-		for _, q := range v.queries {
-			queryVars := q.regexp.FindStringSubmatch(rawQuery)
-			if queryVars != nil {
-				for k, v := range q.varsN {
-					m.Vars[v] = queryVars[k+1]
-				}
+	rawQuery := req.URL.RawQuery
+	for _, q := range v.queries {
+		queryVars := q.regexp.FindStringSubmatch(rawQuery)
+		if queryVars != nil {
+			for k, v := range q.varsN {
+				m.Vars[v] = queryVars[k+1]
 			}
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=451fd8b7796015afbe01cfe9168e4c51e8b40013,https://github.com/gorilla/mux/blob/451fd8b7796015afbe01cfe9168e4c51e8b40013/regexp.go
451fd8b7796015afbe01cfe9168e4c51e8b40013,4fb85f714ec49b6ed062c772737a9a242afd7bab,route.go,,"Tue, 27 May 2014 23:37:30 GMT",modified,3,5,8,"@@ -152,11 +152,9 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 	if err != nil {
 		return err
 	}
-	if r.regexp.queries != nil {
-		for _, q := range r.regexp.queries {
-			if err = uniqueVars(rr.varsN, q.varsN); err != nil {
-				return err
-			}
+	for _, q := range r.regexp.queries {
+		if err = uniqueVars(rr.varsN, q.varsN); err != nil {
+			return err
 		}
 	}
 	if matchHost {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=451fd8b7796015afbe01cfe9168e4c51e8b40013,https://github.com/gorilla/mux/blob/451fd8b7796015afbe01cfe9168e4c51e8b40013/route.go
3505396fb555c93ffac5e511eb8addb3bc4a9397,c70fe60ef8fda6a0231f621bc203aece4b2159d4,route.go,,"Tue, 27 May 2014 18:36:15 GMT",modified,2,7,9,"@@ -173,12 +173,7 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 			}
 		}
 		if matchQuery {
-			if r.regexp.queries == nil {
-				r.regexp.queries = make([]*routeRegexp, 1)
-				r.regexp.queries[0] = rr
-			} else {
-				r.regexp.queries = append(r.regexp.queries, rr)
-			}
+			r.regexp.queries = append(r.regexp.queries, rr)
 		} else {
 			r.regexp.path = rr
 		}
@@ -342,7 +337,7 @@ func (r *Route) Queries(pairs ...string) *Route {
 		return nil
 	}
 	for i := 0; i < length; i += 2 {
-		if r.err = r.addRegexpMatcher(fmt.Sprintf(""%s=%s"", pairs[i], pairs[i+1]), false, true, true); r.err != nil {
+		if r.err = r.addRegexpMatcher(pairs[i]+""=""+pairs[i+1], false, true, true); r.err != nil {
 			return r
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=3505396fb555c93ffac5e511eb8addb3bc4a9397,https://github.com/gorilla/mux/blob/3505396fb555c93ffac5e511eb8addb3bc4a9397/route.go
69237eaae593124b64a499c92be50a5ce17db2e6,e455bce8fdfeec4dde99edc02ec9ee59110fe5f6,mux_test.go,,"Tue, 27 May 2014 16:34:08 GMT",modified,9,0,9,"@@ -462,6 +462,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route, match with a query string out of order"",
+			route:       new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route, bad query"",
 			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=69237eaae593124b64a499c92be50a5ce17db2e6,https://github.com/gorilla/mux/blob/69237eaae593124b64a499c92be50a5ce17db2e6/mux_test.go
69237eaae593124b64a499c92be50a5ce17db2e6,19a358b2ac7df60b730345bb014f00841aa32f2b,regexp.go,,"Tue, 27 May 2014 16:34:08 GMT",modified,15,12,27,"@@ -34,7 +34,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
 	if matchQuery {
-		defaultPattern = ""[^?]+""
+		defaultPattern = ""[^?&]+""
 		matchPrefix, strictSlash = true, false
 	} else if matchHost {
 		defaultPattern = ""[^.]+""
@@ -51,9 +51,9 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash
 	}
 	varsN := make([]string, len(idxs)/2)
 	varsR := make([]*regexp.Regexp, len(idxs)/2)
-	pattern := bytes.NewBufferString(""^"")
-	if matchQuery {
-		pattern = bytes.NewBufferString("""")
+	pattern := bytes.NewBufferString("""")
+	if !matchQuery {
+		pattern.WriteByte('^')
 	}
 	reverse := bytes.NewBufferString("""")
 	var end int
@@ -209,9 +209,9 @@ func braceIndices(s string) ([]int, error) {
 
 // routeRegexpGroup groups the route matchers that carry variables.
 type routeRegexpGroup struct {
-	host  *routeRegexp
-	path  *routeRegexp
-	query *routeRegexp
+	host    *routeRegexp
+	path    *routeRegexp
+	queries []*routeRegexp
 }
 
 // setMatch extracts the variables from the URL once a route matches.
@@ -249,11 +249,14 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 		}
 	}
 	// Store query string variables.
-	if v.query != nil {
-		queryVars := v.query.regexp.FindStringSubmatch(req.URL.RawQuery)
-		if queryVars != nil {
-			for k, v := range v.query.varsN {
-				m.Vars[v] = queryVars[k+1]
+	if v.queries != nil && len(v.queries) > 0 {
+		rawQuery := req.URL.RawQuery
+		for _, q := range v.queries {
+			queryVars := q.regexp.FindStringSubmatch(rawQuery)
+			if queryVars != nil {
+				for k, v := range q.varsN {
+					m.Vars[v] = queryVars[k+1]
+				}
 			}
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=69237eaae593124b64a499c92be50a5ce17db2e6,https://github.com/gorilla/mux/blob/69237eaae593124b64a499c92be50a5ce17db2e6/regexp.go
69237eaae593124b64a499c92be50a5ce17db2e6,1ac20659d142c27381f7060b6fe2ca54f484335b,route.go,,"Tue, 27 May 2014 16:34:08 GMT",modified,18,23,41,"@@ -5,7 +5,6 @@
 package mux
 
 import (
-	""bytes""
 	""errors""
 	""fmt""
 	""net/http""
@@ -153,14 +152,16 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 	if err != nil {
 		return err
 	}
-	if matchHost {
-		if r.regexp.path != nil {
-			if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
+	if r.regexp.queries != nil {
+		for _, q := range r.regexp.queries {
+			if err = uniqueVars(rr.varsN, q.varsN); err != nil {
 				return err
 			}
 		}
-		if r.regexp.query != nil {
-			if err = uniqueVars(rr.varsN, r.regexp.query.varsN); err != nil {
+	}
+	if matchHost {
+		if r.regexp.path != nil {
+			if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
 				return err
 			}
 		}
@@ -172,18 +173,13 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery
 			}
 		}
 		if matchQuery {
-			if r.regexp.path != nil {
-				if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
-					return err
-				}
+			if r.regexp.queries == nil {
+				r.regexp.queries = make([]*routeRegexp, 1)
+				r.regexp.queries[0] = rr
+			} else {
+				r.regexp.queries = append(r.regexp.queries, rr)
 			}
-			r.regexp.query = rr
 		} else {
-			if r.regexp.query != nil {
-				if err = uniqueVars(rr.varsN, r.regexp.query.varsN); err != nil {
-					return err
-				}
-			}
 			r.regexp.path = rr
 		}
 	}
@@ -345,12 +341,11 @@ func (r *Route) Queries(pairs ...string) *Route {
 			""mux: number of parameters must be multiple of 2, got %v"", pairs)
 		return nil
 	}
-	var buf bytes.Buffer
 	for i := 0; i < length; i += 2 {
-		buf.WriteString(fmt.Sprintf(""%s=%s&"", pairs[i], pairs[i+1]))
+		if r.err = r.addRegexpMatcher(fmt.Sprintf(""%s=%s"", pairs[i], pairs[i+1]), false, true, true); r.err != nil {
+			return r
+		}
 	}
-	tpl := strings.TrimRight(buf.String(), ""&"")
-	r.err = r.addRegexpMatcher(tpl, false, true, true)
 
 	return r
 }
@@ -527,9 +522,9 @@ func (r *Route) getRegexpGroup() *routeRegexpGroup {
 		} else {
 			// Copy.
 			r.regexp = &routeRegexpGroup{
-				host:  regexp.host,
-				path:  regexp.path,
-				query: regexp.query,
+				host:    regexp.host,
+				path:    regexp.path,
+				queries: regexp.queries,
 			}
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=69237eaae593124b64a499c92be50a5ce17db2e6,https://github.com/gorilla/mux/blob/69237eaae593124b64a499c92be50a5ce17db2e6/route.go
2900ff05a48b4ab3619b7c56d87ea2859986e9c3,48506bf4fb91a1c9a91db10f32d550a3a8d514d0,mux_test.go,,"Tue, 27 May 2014 04:48:09 GMT",modified,36,0,36,"@@ -471,6 +471,42 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with pattern, match"",
+			route:       new(Route).Queries(""foo"", ""{v1}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:        map[string]string{""v1"": ""bar""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with multiple patterns, match"",
+			route:       new(Route).Queries(""foo"", ""{v1}"", ""baz"", ""{v2}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with regexp pattern, match"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=10""),
+			vars:        map[string]string{""v1"": ""10""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with regexp pattern, regexp does not match"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=a""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=2900ff05a48b4ab3619b7c56d87ea2859986e9c3,https://github.com/gorilla/mux/blob/2900ff05a48b4ab3619b7c56d87ea2859986e9c3/mux_test.go
2900ff05a48b4ab3619b7c56d87ea2859986e9c3,06ae0ebe8b78b6edf722b1f2f7bf6522c2912526,old_test.go,,"Tue, 27 May 2014 04:48:09 GMT",modified,2,45,47,"@@ -329,35 +329,6 @@ var pathMatcherTests = []pathMatcherTest{
 	},
 }
 
-type queryMatcherTest struct {
-	matcher queryMatcher
-	url     string
-	result  bool
-}
-
-var queryMatcherTests = []queryMatcherTest{
-	{
-		matcher: queryMatcher(map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
-		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
-		result:  true,
-	},
-	{
-		matcher: queryMatcher(map[string]string{""foo"": """", ""baz"": """"}),
-		url:     ""http://localhost:8080/?foo=anything&baz=anything"",
-		result:  true,
-	},
-	{
-		matcher: queryMatcher(map[string]string{""foo"": ""ding"", ""baz"": ""bar""}),
-		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
-		result:  false,
-	},
-	{
-		matcher: queryMatcher(map[string]string{""bar"": ""foo"", ""ding"": ""baz""}),
-		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
-		result:  false,
-	},
-}
-
 type schemeMatcherTest struct {
 	matcher schemeMatcher
 	url     string
@@ -519,23 +490,9 @@ func TestPathMatcher(t *testing.T) {
 	}
 }
 
-func TestQueryMatcher(t *testing.T) {
-	for _, v := range queryMatcherTests {
-		request, _ := http.NewRequest(""GET"", v.url, nil)
-		var routeMatch RouteMatch
-		result := v.matcher.Match(request, &routeMatch)
-		if result != v.result {
-			if v.result {
-				t.Errorf(""%#v: should match %v."", v.matcher, v.url)
-			} else {
-				t.Errorf(""%#v: should not match %v."", v.matcher, v.url)
-			}
-		}
-	}
-}
 
 func TestSchemeMatcher(t *testing.T) {
-	for _, v := range queryMatcherTests {
+	for _, v := range schemeMatcherTests {
 		request, _ := http.NewRequest(""GET"", v.url, nil)
 		var routeMatch RouteMatch
 		result := v.matcher.Match(request, &routeMatch)
@@ -735,7 +692,7 @@ func TestNewRegexp(t *testing.T) {
 	}
 
 	for pattern, paths := range tests {
-		p, _ = newRouteRegexp(pattern, false, false, false)
+		p, _ = newRouteRegexp(pattern, false, false, false, false)
 		for path, result := range paths {
 			matches = p.regexp.FindStringSubmatch(path)
 			if result == nil {",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=2900ff05a48b4ab3619b7c56d87ea2859986e9c3,https://github.com/gorilla/mux/blob/2900ff05a48b4ab3619b7c56d87ea2859986e9c3/old_test.go
2900ff05a48b4ab3619b7c56d87ea2859986e9c3,f1d314791a6f46b401533d15b8dcc8a39a9f622a,regexp.go,,"Tue, 27 May 2014 04:48:09 GMT",modified,30,7,37,"@@ -14,7 +14,7 @@ import (
 )
 
 // newRouteRegexp parses a route template and returns a routeRegexp,
-// used to match a host or path.
+// used to match a host, a path or a query string.
 //
 // It will extract named variables, assemble a regexp to be matched, create
 // a ""reverse"" template to build URLs and compile regexps to validate variable
@@ -23,7 +23,7 @@ import (
 // Previously we accepted only Python-like identifiers for variable
 // names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that
 // name and pattern can't be empty, and names can't contain a colon.
-func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*routeRegexp, error) {
+func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash bool) (*routeRegexp, error) {
 	// Check if it is well-formed.
 	idxs, errBraces := braceIndices(tpl)
 	if errBraces != nil {
@@ -33,7 +33,10 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 	template := tpl
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
-	if matchHost {
+	if matchQuery {
+		defaultPattern = ""[^?]+""
+		matchPrefix, strictSlash = true, false
+	} else if matchHost {
 		defaultPattern = ""[^.]+""
 		matchPrefix, strictSlash = false, false
 	}
@@ -49,6 +52,9 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 	varsN := make([]string, len(idxs)/2)
 	varsR := make([]*regexp.Regexp, len(idxs)/2)
 	pattern := bytes.NewBufferString(""^"")
+	if matchQuery {
+		pattern = bytes.NewBufferString("""")
+	}
 	reverse := bytes.NewBufferString("""")
 	var end int
 	var err error
@@ -100,6 +106,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 	return &routeRegexp{
 		template:    template,
 		matchHost:   matchHost,
+		matchQuery:  matchQuery,
 		strictSlash: strictSlash,
 		regexp:      reg,
 		reverse:     reverse.String(),
@@ -113,8 +120,10 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 type routeRegexp struct {
 	// The unmodified template.
 	template string
-	// True for host match, false for path match.
+	// True for host match, false for path or query string match.
 	matchHost bool
+	// True for query string match, false for path and host match.
+	matchQuery bool
 	// The strictSlash value defined on the route, but disabled if PathPrefix was used.
 	strictSlash bool
 	// Expanded regexp.
@@ -130,7 +139,11 @@ type routeRegexp struct {
 // Match matches the regexp against the URL host or path.
 func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 	if !r.matchHost {
-		return r.regexp.MatchString(req.URL.Path)
+		if r.matchQuery {
+			return r.regexp.MatchString(req.URL.RawQuery)
+		} else {
+			return r.regexp.MatchString(req.URL.Path)
+		}
 	}
 	return r.regexp.MatchString(getHost(req))
 }
@@ -196,8 +209,9 @@ func braceIndices(s string) ([]int, error) {
 
 // routeRegexpGroup groups the route matchers that carry variables.
 type routeRegexpGroup struct {
-	host *routeRegexp
-	path *routeRegexp
+	host  *routeRegexp
+	path  *routeRegexp
+	query *routeRegexp
 }
 
 // setMatch extracts the variables from the URL once a route matches.
@@ -234,6 +248,15 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			}
 		}
 	}
+	// Store query string variables.
+	if v.query != nil {
+		queryVars := v.query.regexp.FindStringSubmatch(req.URL.RawQuery)
+		if queryVars != nil {
+			for k, v := range v.query.varsN {
+				m.Vars[v] = queryVars[k+1]
+			}
+		}
+	}
 }
 
 // getHost tries its best to return the request host.",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=2900ff05a48b4ab3619b7c56d87ea2859986e9c3,https://github.com/gorilla/mux/blob/2900ff05a48b4ab3619b7c56d87ea2859986e9c3/regexp.go
2900ff05a48b4ab3619b7c56d87ea2859986e9c3,00989bf9f0cf5d215e571b357b48a2e084177cd4,route.go,,"Tue, 27 May 2014 04:48:09 GMT",modified,53,23,76,"@@ -5,6 +5,7 @@
 package mux
 
 import (
+	""bytes""
 	""errors""
 	""fmt""
 	""net/http""
@@ -135,20 +136,20 @@ func (r *Route) addMatcher(m matcher) *Route {
 }
 
 // addRegexpMatcher adds a host or path matcher and builder to a route.
-func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix bool) error {
+func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery bool) error {
 	if r.err != nil {
 		return r.err
 	}
 	r.regexp = r.getRegexpGroup()
-	if !matchHost {
+	if !matchHost && !matchQuery {
 		if len(tpl) == 0 || tpl[0] != '/' {
 			return fmt.Errorf(""mux: path must start with a slash, got %q"", tpl)
 		}
 		if r.regexp.path != nil {
 			tpl = strings.TrimRight(r.regexp.path.template, ""/"") + tpl
 		}
 	}
-	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, r.strictSlash)
+	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, matchQuery, r.strictSlash)
 	if err != nil {
 		return err
 	}
@@ -158,14 +159,33 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix bool) error
 				return err
 			}
 		}
+		if r.regexp.query != nil {
+			if err = uniqueVars(rr.varsN, r.regexp.query.varsN); err != nil {
+				return err
+			}
+		}
 		r.regexp.host = rr
 	} else {
 		if r.regexp.host != nil {
 			if err = uniqueVars(rr.varsN, r.regexp.host.varsN); err != nil {
 				return err
 			}
 		}
-		r.regexp.path = rr
+		if matchQuery {
+			if r.regexp.path != nil {
+				if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
+					return err
+				}
+			}
+			r.regexp.query = rr
+		} else {
+			if r.regexp.query != nil {
+				if err = uniqueVars(rr.varsN, r.regexp.query.varsN); err != nil {
+					return err
+				}
+			}
+			r.regexp.path = rr
+		}
 	}
 	r.addMatcher(rr)
 	return nil
@@ -219,7 +239,7 @@ func (r *Route) Headers(pairs ...string) *Route {
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
 func (r *Route) Host(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, true, false)
+	r.err = r.addRegexpMatcher(tpl, true, false, false)
 	return r
 }
 
@@ -278,7 +298,7 @@ func (r *Route) Methods(methods ...string) *Route {
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
 func (r *Route) Path(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, false, false)
+	r.err = r.addRegexpMatcher(tpl, false, false, false)
 	return r
 }
 
@@ -294,35 +314,44 @@ func (r *Route) Path(tpl string) *Route {
 // Also note that the setting of Router.StrictSlash() has no effect on routes
 // with a PathPrefix matcher.
 func (r *Route) PathPrefix(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, false, true)
+	r.err = r.addRegexpMatcher(tpl, false, true, false)
 	return r
 }
 
 // Query ----------------------------------------------------------------------
 
-// queryMatcher matches the request against URL queries.
-type queryMatcher map[string]string
-
-func (m queryMatcher) Match(r *http.Request, match *RouteMatch) bool {
-	return matchMap(m, r.URL.Query(), false)
-}
-
 // Queries adds a matcher for URL query values.
-// It accepts a sequence of key/value pairs. For example:
+// It accepts a sequence of key/value pairs. Values may define variables.
+// For example:
 //
 //     r := mux.NewRouter()
-//     r.Queries(""foo"", ""bar"", ""baz"", ""ding"")
+//     r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
 //
 // The above route will only match if the URL contains the defined queries
-// values, e.g.: ?foo=bar&baz=ding.
+// values, e.g.: ?foo=bar&id=42.
 //
 // It the value is an empty string, it will match any value if the key is set.
+//
+// Variables can define an optional regexp pattern to me matched:
+//
+// - {name} matches anything until the next slash.
+//
+// - {name:pattern} matches the given regexp pattern.
+
 func (r *Route) Queries(pairs ...string) *Route {
-	if r.err == nil {
-		var queries map[string]string
-		queries, r.err = mapFromPairs(pairs...)
-		return r.addMatcher(queryMatcher(queries))
+	length := len(pairs)
+	if length%2 != 0 {
+		r.err = fmt.Errorf(
+			""mux: number of parameters must be multiple of 2, got %v"", pairs)
+		return nil
 	}
+	var buf bytes.Buffer
+	for i := 0; i < length; i += 2 {
+		buf.WriteString(fmt.Sprintf(""%s=%s&"", pairs[i], pairs[i+1]))
+	}
+	tpl := strings.TrimRight(buf.String(), ""&"")
+	r.err = r.addRegexpMatcher(tpl, false, true, true)
+
 	return r
 }
 
@@ -498,8 +527,9 @@ func (r *Route) getRegexpGroup() *routeRegexpGroup {
 		} else {
 			// Copy.
 			r.regexp = &routeRegexpGroup{
-				host: regexp.host,
-				path: regexp.path,
+				host:  regexp.host,
+				path:  regexp.path,
+				query: regexp.query,
 			}
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=2900ff05a48b4ab3619b7c56d87ea2859986e9c3,https://github.com/gorilla/mux/blob/2900ff05a48b4ab3619b7c56d87ea2859986e9c3/route.go
0a0d6a1b2a0c75b931495697ce6a2182f810ffb3,48506bf4fb91a1c9a91db10f32d550a3a8d514d0,mux_test.go,,"Tue, 27 May 2014 03:20:14 GMT",modified,18,0,18,"@@ -489,6 +489,24 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route with regexp pattern, match"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=10""),
+			vars:        map[string]string{""v1"": ""10""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with regexp pattern, regexp does not match"",
+			route:       new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=a""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=0a0d6a1b2a0c75b931495697ce6a2182f810ffb3,https://github.com/gorilla/mux/blob/0a0d6a1b2a0c75b931495697ce6a2182f810ffb3/mux_test.go
0a0d6a1b2a0c75b931495697ce6a2182f810ffb3,00989bf9f0cf5d215e571b357b48a2e084177cd4,route.go,,"Tue, 27 May 2014 03:20:14 GMT",modified,9,5,14,"@@ -339,15 +339,19 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // - {name:pattern} matches the given regexp pattern.
 
 func (r *Route) Queries(pairs ...string) *Route {
+	length := len(pairs)
+	if length%2 != 0 {
+		r.err = fmt.Errorf(
+			""mux: number of parameters must be multiple of 2, got %v"", pairs)
+		return nil
+	}
 	var buf bytes.Buffer
-	var queries map[string]string
-	buf.WriteString("""")
-	queries, r.err = mapFromPairs(pairs...)
-	for k, v := range queries {
-		buf.WriteString(fmt.Sprintf(""%s=%s&"", k, v))
+	for i := 0; i < length; i += 2 {
+		buf.WriteString(fmt.Sprintf(""%s=%s&"", pairs[i], pairs[i+1]))
 	}
 	tpl := strings.TrimRight(buf.String(), ""&"")
 	r.err = r.addRegexpMatcher(tpl, false, true, true)
+
 	return r
 }
 ",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=0a0d6a1b2a0c75b931495697ce6a2182f810ffb3,https://github.com/gorilla/mux/blob/0a0d6a1b2a0c75b931495697ce6a2182f810ffb3/route.go
c9469524da00abe15b8d00bb1ee9621d85ebdfbc,06ae0ebe8b78b6edf722b1f2f7bf6522c2912526,old_test.go,,"Mon, 26 May 2014 22:13:05 GMT",modified,1,44,45,"@@ -329,35 +329,6 @@ var pathMatcherTests = []pathMatcherTest{
 	},
 }
 
-type queryMatcherTest struct {
-	matcher queryMatcher
-	url     string
-	result  bool
-}
-
-var queryMatcherTests = []queryMatcherTest{
-	{
-		matcher: queryMatcher(map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
-		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
-		result:  true,
-	},
-	{
-		matcher: queryMatcher(map[string]string{""foo"": """", ""baz"": """"}),
-		url:     ""http://localhost:8080/?foo=anything&baz=anything"",
-		result:  true,
-	},
-	{
-		matcher: queryMatcher(map[string]string{""foo"": ""ding"", ""baz"": ""bar""}),
-		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
-		result:  false,
-	},
-	{
-		matcher: queryMatcher(map[string]string{""bar"": ""foo"", ""ding"": ""baz""}),
-		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
-		result:  false,
-	},
-}
-
 type schemeMatcherTest struct {
 	matcher schemeMatcher
 	url     string
@@ -519,23 +490,9 @@ func TestPathMatcher(t *testing.T) {
 	}
 }
 
-func TestQueryMatcher(t *testing.T) {
-	for _, v := range queryMatcherTests {
-		request, _ := http.NewRequest(""GET"", v.url, nil)
-		var routeMatch RouteMatch
-		result := v.matcher.Match(request, &routeMatch)
-		if result != v.result {
-			if v.result {
-				t.Errorf(""%#v: should match %v."", v.matcher, v.url)
-			} else {
-				t.Errorf(""%#v: should not match %v."", v.matcher, v.url)
-			}
-		}
-	}
-}
 
 func TestSchemeMatcher(t *testing.T) {
-	for _, v := range queryMatcherTests {
+	for _, v := range schemeMatcherTests {
 		request, _ := http.NewRequest(""GET"", v.url, nil)
 		var routeMatch RouteMatch
 		result := v.matcher.Match(request, &routeMatch)",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=c9469524da00abe15b8d00bb1ee9621d85ebdfbc,https://github.com/gorilla/mux/blob/c9469524da00abe15b8d00bb1ee9621d85ebdfbc/old_test.go
65cc9b5df83a841607cf9f88c58cb6cdd8ab0421,c133d6c4481e84895fce4bb16226906f783c3488,mux_test.go,,"Mon, 26 May 2014 22:01:42 GMT",modified,18,0,18,"@@ -471,6 +471,24 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: false,
 		},
+		{
+			title:       ""Queries route with pattern, match"",
+			route:       new(Route).Queries(""foo"", ""{v1}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar""),
+			vars:        map[string]string{""v1"": ""bar""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Queries route with multiple patterns, match"",
+			route:       new(Route).Queries(""foo"", ""{v1}"", ""baz"", ""{v2}""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=65cc9b5df83a841607cf9f88c58cb6cdd8ab0421,https://github.com/gorilla/mux/blob/65cc9b5df83a841607cf9f88c58cb6cdd8ab0421/mux_test.go
65cc9b5df83a841607cf9f88c58cb6cdd8ab0421,4c773c66d5bc62890fd7bddc6fd869a6ce74e023,old_test.go,,"Mon, 26 May 2014 22:01:42 GMT",modified,1,1,2,"@@ -735,7 +735,7 @@ func TestNewRegexp(t *testing.T) {
 	}
 
 	for pattern, paths := range tests {
-		p, _ = newRouteRegexp(pattern, false, false, false)
+		p, _ = newRouteRegexp(pattern, false, false, false, false)
 		for path, result := range paths {
 			matches = p.regexp.FindStringSubmatch(path)
 			if result == nil {",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=65cc9b5df83a841607cf9f88c58cb6cdd8ab0421,https://github.com/gorilla/mux/blob/65cc9b5df83a841607cf9f88c58cb6cdd8ab0421/old_test.go
65cc9b5df83a841607cf9f88c58cb6cdd8ab0421,f1d314791a6f46b401533d15b8dcc8a39a9f622a,regexp.go,,"Mon, 26 May 2014 22:01:42 GMT",modified,30,7,37,"@@ -14,7 +14,7 @@ import (
 )
 
 // newRouteRegexp parses a route template and returns a routeRegexp,
-// used to match a host or path.
+// used to match a host, a path or a query string.
 //
 // It will extract named variables, assemble a regexp to be matched, create
 // a ""reverse"" template to build URLs and compile regexps to validate variable
@@ -23,7 +23,7 @@ import (
 // Previously we accepted only Python-like identifiers for variable
 // names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that
 // name and pattern can't be empty, and names can't contain a colon.
-func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*routeRegexp, error) {
+func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash bool) (*routeRegexp, error) {
 	// Check if it is well-formed.
 	idxs, errBraces := braceIndices(tpl)
 	if errBraces != nil {
@@ -33,7 +33,10 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 	template := tpl
 	// Now let's parse it.
 	defaultPattern := ""[^/]+""
-	if matchHost {
+	if matchQuery {
+		defaultPattern = ""[^?]+""
+		matchPrefix, strictSlash = true, false
+	} else if matchHost {
 		defaultPattern = ""[^.]+""
 		matchPrefix, strictSlash = false, false
 	}
@@ -49,6 +52,9 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 	varsN := make([]string, len(idxs)/2)
 	varsR := make([]*regexp.Regexp, len(idxs)/2)
 	pattern := bytes.NewBufferString(""^"")
+	if matchQuery {
+		pattern = bytes.NewBufferString("""")
+	}
 	reverse := bytes.NewBufferString("""")
 	var end int
 	var err error
@@ -100,6 +106,7 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 	return &routeRegexp{
 		template:    template,
 		matchHost:   matchHost,
+		matchQuery:  matchQuery,
 		strictSlash: strictSlash,
 		regexp:      reg,
 		reverse:     reverse.String(),
@@ -113,8 +120,10 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 type routeRegexp struct {
 	// The unmodified template.
 	template string
-	// True for host match, false for path match.
+	// True for host match, false for path or query string match.
 	matchHost bool
+	// True for query string match, false for path and host match.
+	matchQuery bool
 	// The strictSlash value defined on the route, but disabled if PathPrefix was used.
 	strictSlash bool
 	// Expanded regexp.
@@ -130,7 +139,11 @@ type routeRegexp struct {
 // Match matches the regexp against the URL host or path.
 func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 	if !r.matchHost {
-		return r.regexp.MatchString(req.URL.Path)
+		if r.matchQuery {
+			return r.regexp.MatchString(req.URL.RawQuery)
+		} else {
+			return r.regexp.MatchString(req.URL.Path)
+		}
 	}
 	return r.regexp.MatchString(getHost(req))
 }
@@ -196,8 +209,9 @@ func braceIndices(s string) ([]int, error) {
 
 // routeRegexpGroup groups the route matchers that carry variables.
 type routeRegexpGroup struct {
-	host *routeRegexp
-	path *routeRegexp
+	host  *routeRegexp
+	path  *routeRegexp
+	query *routeRegexp
 }
 
 // setMatch extracts the variables from the URL once a route matches.
@@ -234,6 +248,15 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 			}
 		}
 	}
+	// Store query string variables.
+	if v.query != nil {
+		queryVars := v.query.regexp.FindStringSubmatch(req.URL.RawQuery)
+		if queryVars != nil {
+			for k, v := range v.query.varsN {
+				m.Vars[v] = queryVars[k+1]
+			}
+		}
+	}
 }
 
 // getHost tries its best to return the request host.",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=65cc9b5df83a841607cf9f88c58cb6cdd8ab0421,https://github.com/gorilla/mux/blob/65cc9b5df83a841607cf9f88c58cb6cdd8ab0421/regexp.go
65cc9b5df83a841607cf9f88c58cb6cdd8ab0421,afe3e7f06d565d7b38734adb37f6b3da4ea3667a,route.go,,"Mon, 26 May 2014 22:01:42 GMT",modified,49,23,72,"@@ -5,6 +5,7 @@
 package mux
 
 import (
+	""bytes""
 	""errors""
 	""fmt""
 	""net/http""
@@ -135,20 +136,20 @@ func (r *Route) addMatcher(m matcher) *Route {
 }
 
 // addRegexpMatcher adds a host or path matcher and builder to a route.
-func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix bool) error {
+func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery bool) error {
 	if r.err != nil {
 		return r.err
 	}
 	r.regexp = r.getRegexpGroup()
-	if !matchHost {
+	if !matchHost && !matchQuery {
 		if len(tpl) == 0 || tpl[0] != '/' {
 			return fmt.Errorf(""mux: path must start with a slash, got %q"", tpl)
 		}
 		if r.regexp.path != nil {
 			tpl = strings.TrimRight(r.regexp.path.template, ""/"") + tpl
 		}
 	}
-	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, r.strictSlash)
+	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, matchQuery, r.strictSlash)
 	if err != nil {
 		return err
 	}
@@ -158,14 +159,33 @@ func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix bool) error
 				return err
 			}
 		}
+		if r.regexp.query != nil {
+			if err = uniqueVars(rr.varsN, r.regexp.query.varsN); err != nil {
+				return err
+			}
+		}
 		r.regexp.host = rr
 	} else {
 		if r.regexp.host != nil {
 			if err = uniqueVars(rr.varsN, r.regexp.host.varsN); err != nil {
 				return err
 			}
 		}
-		r.regexp.path = rr
+		if matchQuery {
+			if r.regexp.path != nil {
+				if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
+					return err
+				}
+			}
+			r.regexp.query = rr
+		} else {
+			if r.regexp.query != nil {
+				if err = uniqueVars(rr.varsN, r.regexp.query.varsN); err != nil {
+					return err
+				}
+			}
+			r.regexp.path = rr
+		}
 	}
 	r.addMatcher(rr)
 	return nil
@@ -219,7 +239,7 @@ func (r *Route) Headers(pairs ...string) *Route {
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
 func (r *Route) Host(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, true, false)
+	r.err = r.addRegexpMatcher(tpl, true, false, false)
 	return r
 }
 
@@ -278,7 +298,7 @@ func (r *Route) Methods(methods ...string) *Route {
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
 func (r *Route) Path(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, false, false)
+	r.err = r.addRegexpMatcher(tpl, false, false, false)
 	return r
 }
 
@@ -294,35 +314,40 @@ func (r *Route) Path(tpl string) *Route {
 // Also note that the setting of Router.StrictSlash() has no effect on routes
 // with a PathPrefix matcher.
 func (r *Route) PathPrefix(tpl string) *Route {
-	r.err = r.addRegexpMatcher(tpl, false, true)
+	r.err = r.addRegexpMatcher(tpl, false, true, false)
 	return r
 }
 
 // Query ----------------------------------------------------------------------
 
-// queryMatcher matches the request against URL queries.
-type queryMatcher map[string]string
-
-func (m queryMatcher) Match(r *http.Request, match *RouteMatch) bool {
-	return matchMap(m, r.URL.Query(), false)
-}
-
 // Queries adds a matcher for URL query values.
-// It accepts a sequence of key/value pairs. For example:
+// It accepts a sequence of key/value pairs. Values may define variables.
+// For example:
 //
 //     r := mux.NewRouter()
-//     r.Queries(""foo"", ""bar"", ""baz"", ""ding"")
+//     r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
 //
 // The above route will only match if the URL contains the defined queries
-// values, e.g.: ?foo=bar&baz=ding.
+// values, e.g.: ?foo=bar&id=42.
 //
 // It the value is an empty string, it will match any value if the key is set.
+//
+// Variables can define an optional regexp pattern to me matched:
+//
+// - {name} matches anything until the next slash.
+//
+// - {name:pattern} matches the given regexp pattern.
+
 func (r *Route) Queries(pairs ...string) *Route {
-	if r.err == nil {
-		var queries map[string]string
-		queries, r.err = mapFromPairs(pairs...)
-		return r.addMatcher(queryMatcher(queries))
+	var buf bytes.Buffer
+	var queries map[string]string
+	buf.WriteString("""")
+	queries, r.err = mapFromPairs(pairs...)
+	for k, v := range queries {
+		buf.WriteString(fmt.Sprintf(""%s=%s&"", k, v))
 	}
+	tpl := strings.TrimRight(buf.String(), ""&"")
+	r.err = r.addRegexpMatcher(tpl, false, true, true)
 	return r
 }
 
@@ -498,8 +523,9 @@ func (r *Route) getRegexpGroup() *routeRegexpGroup {
 		} else {
 			// Copy.
 			r.regexp = &routeRegexpGroup{
-				host: regexp.host,
-				path: regexp.path,
+				host:  regexp.host,
+				path:  regexp.path,
+				query: regexp.query,
 			}
 		}
 	}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=65cc9b5df83a841607cf9f88c58cb6cdd8ab0421,https://github.com/gorilla/mux/blob/65cc9b5df83a841607cf9f88c58cb6cdd8ab0421/route.go
136d54f81f00414c45c3c68dd47e98cc97519c5e,8b23c39d397d0986107a4b7b8c4f609f467b5a6f,mux.go,,"Mon, 05 May 2014 13:44:26 GMT",modified,11,5,16,"@@ -109,14 +109,20 @@ func (r *Router) GetRoute(name string) *Route {
 	return r.getNamedRoutes()[name]
 }
 
-// StrictSlash defines the slash behavior for new routes.
+// StrictSlash defines the trailing slash behavior for new routes. The initial
+// value is false.
 //
 // When true, if the route path is ""/path/"", accessing ""/path"" will redirect
-// to the former and vice versa.
+// to the former and vice versa. In other words, your application will always
+// see the path as specified in the route.
 //
-// Special case: when a route sets a path prefix, strict slash is
-// automatically set to false for that route because the redirect behavior
-// can't be determined for prefixes.
+// When false, if the route path is ""/path"", accessing ""/path/"" will not match
+// this route and vice versa.
+//
+// Special case: when a route sets a path prefix using the PathPrefix() method,
+// strict slash is ignored for that route because the redirect behavior can't
+// be determined from a prefix alone. However, any subrouters created from that
+// route inherit the original StrictSlash setting.
 func (r *Router) StrictSlash(value bool) *Router {
 	r.strictSlash = value
 	return r",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=136d54f81f00414c45c3c68dd47e98cc97519c5e,https://github.com/gorilla/mux/blob/136d54f81f00414c45c3c68dd47e98cc97519c5e/mux.go
136d54f81f00414c45c3c68dd47e98cc97519c5e,0e2e48067ae3038c70632953559a548fe4bc9481,mux_test.go,,"Mon, 05 May 2014 13:44:26 GMT",modified,119,25,144,"@@ -13,13 +13,14 @@ import (
 )
 
 type routeTest struct {
-	title       string            // title of the test
-	route       *Route            // the route being tested
-	request     *http.Request     // a request to test the route
-	vars        map[string]string // the expected vars of the match
-	host        string            // the expected host of the match
-	path        string            // the expected path of the match
-	shouldMatch bool              // whether the request is expected to match the route at all
+	title          string            // title of the test
+	route          *Route            // the route being tested
+	request        *http.Request     // a request to test the route
+	vars           map[string]string // the expected vars of the match
+	host           string            // the expected host of the match
+	path           string            // the expected path of the match
+	shouldMatch    bool              // whether the request is expected to match the route at all
+	shouldRedirect bool              // whether the request should result in a redirect
 }
 
 func TestHost(t *testing.T) {
@@ -151,6 +152,33 @@ func TestPath(t *testing.T) {
 			path:        ""/111/222/333"",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Path route, match with trailing slash in request and path"",
+			route:       new(Route).Path(""/111/""),
+			request:     newRequest(""GET"", ""http://localhost/111/""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111/"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route, do not match with trailing slash in path"",
+			route:       new(Route).Path(""/111/""),
+			request:     newRequest(""GET"", ""http://localhost/111""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Path route, do not match with trailing slash in request"",
+			route:       new(Route).Path(""/111""),
+			request:     newRequest(""GET"", ""http://localhost/111/""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111/"",
+			shouldMatch: false,
+		},
 		{
 			title:       ""Path route, wrong path in request in request URL"",
 			route:       new(Route).Path(""/111/222/333""),
@@ -214,6 +242,15 @@ func TestPathPrefix(t *testing.T) {
 			path:        ""/111"",
 			shouldMatch: true,
 		},
+		{
+			title:       ""PathPrefix route, match substring"",
+			route:       new(Route).PathPrefix(""/1""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/1"",
+			shouldMatch: true,
+		},
 		{
 			title:       ""PathPrefix route, URL prefix in request does not match"",
 			route:       new(Route).PathPrefix(""/111""),
@@ -579,26 +616,74 @@ func TestNamedRoutes(t *testing.T) {
 }
 
 func TestStrictSlash(t *testing.T) {
-	var r *Router
-	var req *http.Request
-	var route *Route
-	var match *RouteMatch
-	var matched bool
-
-	// StrictSlash should be ignored for path prefix.
-	// So we register a route ending in slash but it doesn't attempt to add
-	// the slash for a path not ending in slash.
-	r = NewRouter()
+	r := NewRouter()
 	r.StrictSlash(true)
-	route = r.NewRoute().PathPrefix(""/static/"")
-	req, _ = http.NewRequest(""GET"", ""http://localhost/static/logo.png"", nil)
-	match = new(RouteMatch)
-	matched = r.Match(req, match)
-	if !matched {
-		t.Errorf(""Should match request %q -- %v"", req.URL.Path, getRouteTemplate(route))
+
+	tests := []routeTest{
+		{
+			title:          ""Redirect path without slash"",
+			route:          r.NewRoute().Path(""/111/""),
+			request:        newRequest(""GET"", ""http://localhost/111""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/111/"",
+			shouldMatch:    true,
+			shouldRedirect: true,
+		},
+		{
+			title:          ""Do not redirect path with slash"",
+			route:          r.NewRoute().Path(""/111/""),
+			request:        newRequest(""GET"", ""http://localhost/111/""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/111/"",
+			shouldMatch:    true,
+			shouldRedirect: false,
+		},
+		{
+			title:          ""Redirect path with slash"",
+			route:          r.NewRoute().Path(""/111""),
+			request:        newRequest(""GET"", ""http://localhost/111/""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/111"",
+			shouldMatch:    true,
+			shouldRedirect: true,
+		},
+		{
+			title:          ""Do not redirect path without slash"",
+			route:          r.NewRoute().Path(""/111""),
+			request:        newRequest(""GET"", ""http://localhost/111""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/111"",
+			shouldMatch:    true,
+			shouldRedirect: false,
+		},
+		{
+			title:          ""Propagate StrictSlash to subrouters"",
+			route:          r.NewRoute().PathPrefix(""/static/"").Subrouter().Path(""/images/""),
+			request:        newRequest(""GET"", ""http://localhost/static/images""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/static/images/"",
+			shouldMatch:    true,
+			shouldRedirect: true,
+		},
+		{
+			title:          ""Ignore StrictSlash for path prefix"",
+			route:          r.NewRoute().PathPrefix(""/static/""),
+			request:        newRequest(""GET"", ""http://localhost/static/logo.png""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/static/"",
+			shouldMatch:    true,
+			shouldRedirect: false,
+		},
 	}
-	if match.Handler != nil {
-		t.Errorf(""Should not redirect"")
+
+	for _, test := range tests {
+		testRoute(t, test)
 	}
 }
 
@@ -627,6 +712,7 @@ func testRoute(t *testing.T, test routeTest) {
 	host := test.host
 	path := test.path
 	url := test.host + test.path
+	shouldRedirect := test.shouldRedirect
 
 	var match RouteMatch
 	ok := route.Match(request, &match)
@@ -664,6 +750,14 @@ func testRoute(t *testing.T, test routeTest) {
 				return
 			}
 		}
+		if shouldRedirect && match.Handler == nil {
+			t.Errorf(""(%v) Did not redirect"", test.title)
+			return
+		}
+		if !shouldRedirect && match.Handler != nil {
+			t.Errorf(""(%v) Unexpected redirect"", test.title)
+			return
+		}
 	}
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=136d54f81f00414c45c3c68dd47e98cc97519c5e,https://github.com/gorilla/mux/blob/136d54f81f00414c45c3c68dd47e98cc97519c5e/mux_test.go
136d54f81f00414c45c3c68dd47e98cc97519c5e,925f268abefa42313560382de9580f809db62892,regexp.go,,"Mon, 05 May 2014 13:44:26 GMT",modified,10,7,17,"@@ -98,12 +98,13 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 	}
 	// Done!
 	return &routeRegexp{
-		template:  template,
-		matchHost: matchHost,
-		regexp:    reg,
-		reverse:   reverse.String(),
-		varsN:     varsN,
-		varsR:     varsR,
+		template:    template,
+		matchHost:   matchHost,
+		strictSlash: strictSlash,
+		regexp:      reg,
+		reverse:     reverse.String(),
+		varsN:       varsN,
+		varsR:       varsR,
 	}, nil
 }
 
@@ -114,6 +115,8 @@ type routeRegexp struct {
 	template string
 	// True for host match, false for path match.
 	matchHost bool
+	// The strictSlash value defined on the route, but disabled if PathPrefix was used.
+	strictSlash bool
 	// Expanded regexp.
 	regexp *regexp.Regexp
 	// Reverse template.
@@ -216,7 +219,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 				m.Vars[v] = pathVars[k+1]
 			}
 			// Check if we should redirect.
-			if r.strictSlash {
+			if v.path.strictSlash {
 				p1 := strings.HasSuffix(req.URL.Path, ""/"")
 				p2 := strings.HasSuffix(v.path.template, ""/"")
 				if p1 != p2 {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=136d54f81f00414c45c3c68dd47e98cc97519c5e,https://github.com/gorilla/mux/blob/136d54f81f00414c45c3c68dd47e98cc97519c5e/regexp.go
136d54f81f00414c45c3c68dd47e98cc97519c5e,5cb2526d613909a6d622ebb6925490f3e23f0437,route.go,,"Mon, 05 May 2014 13:44:26 GMT",modified,11,3,14,"@@ -259,7 +259,8 @@ func (r *Route) Methods(methods ...string) *Route {
 // Path -----------------------------------------------------------------------
 
 // Path adds a matcher for the URL path.
-// It accepts a template with zero or more URL variables enclosed by {}.
+// It accepts a template with zero or more URL variables enclosed by {}. The
+// template must start with a ""/"".
 // Variables can define an optional regexp pattern to me matched:
 //
 // - {name} matches anything until the next slash.
@@ -283,9 +284,16 @@ func (r *Route) Path(tpl string) *Route {
 
 // PathPrefix -----------------------------------------------------------------
 
-// PathPrefix adds a matcher for the URL path prefix.
+// PathPrefix adds a matcher for the URL path prefix. This matches if the given
+// template is a prefix of the full URL path. See Route.Path() for details on
+// the tpl argument.
+//
+// Note that it does not treat slashes specially (""/foobar/"" will be matched by
+// the prefix ""/foo"") so you may want to use a trailing slash here.
+//
+// Also note that the setting of Router.StrictSlash() has no effect on routes
+// with a PathPrefix matcher.
 func (r *Route) PathPrefix(tpl string) *Route {
-	r.strictSlash = false
 	r.err = r.addRegexpMatcher(tpl, false, true)
 	return r
 }",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=136d54f81f00414c45c3c68dd47e98cc97519c5e,https://github.com/gorilla/mux/blob/136d54f81f00414c45c3c68dd47e98cc97519c5e/route.go
a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622,caa8ad55f2456248ab99a30cb95caa322b9232cf,mux.go,,"Wed, 23 Apr 2014 18:44:16 GMT",modified,7,0,7,"@@ -146,6 +146,13 @@ func (r *Router) getRegexpGroup() *routeRegexpGroup {
 	return nil
 }
 
+func (r *Router) buildVars(m map[string]string) map[string]string {
+	if r.parent != nil {
+		m = r.parent.buildVars(m)
+	}
+	return m
+}
+
 // ----------------------------------------------------------------------------
 // Route factories
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622,https://github.com/gorilla/mux/blob/a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622/mux.go
a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622,b163639d62ddf3110450d3a2166966e66907454c,mux_test.go,,"Wed, 23 Apr 2014 18:44:16 GMT",modified,14,0,14,"@@ -514,6 +514,7 @@ func TestMatcherFunc(t *testing.T) {
 func TestBuildVarsFunc(t *testing.T) {
 	tests := []routeTest{
 		{
+			title: ""BuildVarsFunc set on route"",
 			route: new(Route).Path(`/111/{v1:\d}{v2:.*}`).BuildVarsFunc(func(vars map[string]string) map[string]string {
 				vars[""v1""] = ""3""
 				vars[""v2""] = ""a""
@@ -523,6 +524,19 @@ func TestBuildVarsFunc(t *testing.T) {
 			path:        ""/111/3a"",
 			shouldMatch: true,
 		},
+		{
+			title: ""BuildVarsFunc set on route and parent route"",
+			route: new(Route).PathPrefix(`/{v1:\d}`).BuildVarsFunc(func(vars map[string]string) map[string]string {
+				vars[""v1""] = ""2""
+				return vars
+			}).Subrouter().Path(`/{v2:\w}`).BuildVarsFunc(func(vars map[string]string) map[string]string {
+				vars[""v2""] = ""b""
+				return vars
+			}),
+			request:     newRequest(""GET"", ""http://localhost/1/a""),
+			path:        ""/2/b"",
+			shouldMatch: true,
+		},
 	}
 
 	for _, test := range tests {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622,https://github.com/gorilla/mux/blob/a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622/mux_test.go
a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622,b2900de27d64a084165e4d937bb21c1eb1fcfc83,route.go,,"Wed, 23 Apr 2014 18:44:16 GMT",modified,14,6,20,"@@ -413,7 +413,7 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil {
 		return nil, errors.New(""mux: route doesn't have a host or path"")
 	}
-	values, err := r.buildVars(pairs...)
+	values, err := r.prepareVars(pairs...)
 	if err != nil {
 		return nil, err
 	}
@@ -447,7 +447,7 @@ func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil || r.regexp.host == nil {
 		return nil, errors.New(""mux: route doesn't have a host"")
 	}
-	values, err := r.buildVars(pairs...)
+	values, err := r.prepareVars(pairs...)
 	if err != nil {
 		return nil, err
 	}
@@ -471,7 +471,7 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil || r.regexp.path == nil {
 		return nil, errors.New(""mux: route doesn't have a path"")
 	}
-	values, err := r.buildVars(pairs...)
+	values, err := r.prepareVars(pairs...)
 	if err != nil {
 		return nil, err
 	}
@@ -484,17 +484,24 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	}, nil
 }
 
-// buildVars converts the route variable pairs into a map. If the route has a
+// prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
-func (r *Route) buildVars(pairs ...string) (map[string]string, error) {
+func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
 	m, err := mapFromPairs(pairs...)
 	if err != nil {
 		return nil, err
 	}
+	return r.buildVars(m), nil
+}
+
+func (r *Route) buildVars(m map[string]string) map[string]string {
+	if r.parent != nil {
+		m = r.parent.buildVars(m)
+	}
 	if r.buildVarsFunc != nil {
 		m = r.buildVarsFunc(m)
 	}
-	return m, nil
+	return m
 }
 
 // ----------------------------------------------------------------------------
@@ -505,6 +512,7 @@ func (r *Route) buildVars(pairs ...string) (map[string]string, error) {
 type parentRoute interface {
 	getNamedRoutes() map[string]*Route
 	getRegexpGroup() *routeRegexpGroup
+	buildVars(map[string]string) map[string]string
 }
 
 // getNamedRoutes returns the map where named routes are registered.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622,https://github.com/gorilla/mux/blob/a883d5a9b9d5fb9f3c084dd9858ee6fa11d9c622/route.go
cef3b0cd6d468434914c21146d6e400436f2d0e3,e22dcacce0d57754206f59a0bd46f44154dd3239,mux.go,,"Wed, 23 Apr 2014 18:44:16 GMT",modified,6,0,6,"@@ -218,6 +218,12 @@ func (r *Router) Schemes(schemes ...string) *Route {
 	return r.NewRoute().Schemes(schemes...)
 }
 
+// BuildVars registers a new route with a custom function for modifying
+// route variables before building a URL.
+func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
+	return r.NewRoute().BuildVarsFunc(f)
+}
+
 // ----------------------------------------------------------------------------
 // Context
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=cef3b0cd6d468434914c21146d6e400436f2d0e3,https://github.com/gorilla/mux/blob/cef3b0cd6d468434914c21146d6e400436f2d0e3/mux.go
cef3b0cd6d468434914c21146d6e400436f2d0e3,bd76a019d99b7d95aaf7964a994e4e3fff1fe999,mux_test.go,,"Wed, 23 Apr 2014 18:44:16 GMT",modified,19,0,19,"@@ -511,6 +511,25 @@ func TestMatcherFunc(t *testing.T) {
 	}
 }
 
+func TestBuildVarsFunc(t *testing.T) {
+	tests := []routeTest{
+		{
+			route: new(Route).Path(`/111/{v1:\d}{v2:.*}`).BuildVarsFunc(func(vars map[string]string) map[string]string {
+				vars[""v1""] = ""3""
+				vars[""v2""] = ""a""
+				return vars
+			}),
+			request:     newRequest(""GET"", ""http://localhost/111/2""),
+			path:        ""/111/3a"",
+			shouldMatch: true,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
 func TestSubRouter(t *testing.T) {
 	subrouter1 := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
 	subrouter2 := new(Route).PathPrefix(""/foo/{v1}"").Subrouter()",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=cef3b0cd6d468434914c21146d6e400436f2d0e3,https://github.com/gorilla/mux/blob/cef3b0cd6d468434914c21146d6e400436f2d0e3/mux_test.go
cef3b0cd6d468434914c21146d6e400436f2d0e3,e56f1bb075d8c36de00ce1feaf955a333602964b,regexp.go,,"Wed, 23 Apr 2014 18:44:16 GMT",modified,1,5,6,"@@ -133,11 +133,7 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 }
 
 // url builds a URL part using the given values.
-func (r *routeRegexp) url(pairs ...string) (string, error) {
-	values, err := mapFromPairs(pairs...)
-	if err != nil {
-		return """", err
-	}
+func (r *routeRegexp) url(values map[string]string) (string, error) {
 	urlValues := make([]interface{}, len(r.varsN))
 	for k, v := range r.varsN {
 		value, ok := values[v]",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=cef3b0cd6d468434914c21146d6e400436f2d0e3,https://github.com/gorilla/mux/blob/cef3b0cd6d468434914c21146d6e400436f2d0e3/regexp.go
cef3b0cd6d468434914c21146d6e400436f2d0e3,e79afa737e08556084f04dadfd65b53b52e9d19e,route.go,,"Wed, 23 Apr 2014 18:44:16 GMT",modified,44,5,49,"@@ -31,6 +31,8 @@ type Route struct {
 	name string
 	// Error resulted from building a route.
 	err error
+
+	buildVarsFunc BuildVarsFunc
 }
 
 // Match matches the route against the request.
@@ -336,6 +338,19 @@ func (r *Route) Schemes(schemes ...string) *Route {
 	return r.addMatcher(schemeMatcher(schemes))
 }
 
+// BuildVarsFunc --------------------------------------------------------------
+
+// BuildVarsFunc is the function signature used by custom build variable
+// functions (which can modify route variables before a route's URL is built).
+type BuildVarsFunc func(map[string]string) map[string]string
+
+// BuildVarsFunc adds a custom function to be used to modify build variables
+// before a route's URL is built.
+func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
+	r.buildVarsFunc = f
+	return r
+}
+
 // Subrouter ------------------------------------------------------------------
 
 // Subrouter creates a subrouter for the route.
@@ -398,17 +413,20 @@ func (r *Route) URL(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil {
 		return nil, errors.New(""mux: route doesn't have a host or path"")
 	}
+	values, err := r.buildVars(pairs...)
+	if err != nil {
+		return nil, err
+	}
 	var scheme, host, path string
-	var err error
 	if r.regexp.host != nil {
 		// Set a default scheme.
 		scheme = ""http""
-		if host, err = r.regexp.host.url(pairs...); err != nil {
+		if host, err = r.regexp.host.url(values); err != nil {
 			return nil, err
 		}
 	}
 	if r.regexp.path != nil {
-		if path, err = r.regexp.path.url(pairs...); err != nil {
+		if path, err = r.regexp.path.url(values); err != nil {
 			return nil, err
 		}
 	}
@@ -429,7 +447,11 @@ func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil || r.regexp.host == nil {
 		return nil, errors.New(""mux: route doesn't have a host"")
 	}
-	host, err := r.regexp.host.url(pairs...)
+	values, err := r.buildVars(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	host, err := r.regexp.host.url(values)
 	if err != nil {
 		return nil, err
 	}
@@ -449,7 +471,11 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	if r.regexp == nil || r.regexp.path == nil {
 		return nil, errors.New(""mux: route doesn't have a path"")
 	}
-	path, err := r.regexp.path.url(pairs...)
+	values, err := r.buildVars(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	path, err := r.regexp.path.url(values)
 	if err != nil {
 		return nil, err
 	}
@@ -458,6 +484,19 @@ func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
 	}, nil
 }
 
+// buildVars converts the route variable pairs into a map. If the route has a
+// BuildVarsFunc, it is invoked.
+func (r *Route) buildVars(pairs ...string) (map[string]string, error) {
+	m, err := mapFromPairs(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	if r.buildVarsFunc != nil {
+		m = r.buildVarsFunc(m)
+	}
+	return m, nil
+}
+
 // ----------------------------------------------------------------------------
 // parentRoute
 // ----------------------------------------------------------------------------",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=cef3b0cd6d468434914c21146d6e400436f2d0e3,https://github.com/gorilla/mux/blob/cef3b0cd6d468434914c21146d6e400436f2d0e3/route.go
b864f07c539c7abc16652d65350d070d8e2810de,8b23c39d397d0986107a4b7b8c4f609f467b5a6f,mux.go,,"Wed, 23 Apr 2014 17:53:35 GMT",modified,4,3,7,"@@ -119,9 +119,10 @@ func (r *Router) GetRoute(name string) *Route {
 // When false, if the route path is ""/path"", accessing ""/path/"" will not match
 // this route and vice versa.
 //
-// Special case: when a route sets a path prefix, strict slash is
-// automatically set to false for that route because the redirect behavior
-// can't be determined for prefixes.
+// Special case: when a route sets a path prefix using the PathPrefix() method,
+// strict slash is ignored for that route because the redirect behavior can't
+// be determined from a prefix alone. However, any subrouters created from that
+// route inherit the original StrictSlash setting.
 func (r *Router) StrictSlash(value bool) *Router {
 	r.strictSlash = value
 	return r",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=b864f07c539c7abc16652d65350d070d8e2810de,https://github.com/gorilla/mux/blob/b864f07c539c7abc16652d65350d070d8e2810de/mux.go
b864f07c539c7abc16652d65350d070d8e2810de,0e2e48067ae3038c70632953559a548fe4bc9481,mux_test.go,,"Wed, 23 Apr 2014 17:53:35 GMT",modified,10,0,10,"@@ -660,6 +660,16 @@ func TestStrictSlash(t *testing.T) {
 			shouldMatch:    true,
 			shouldRedirect: false,
 		},
+		{
+			title:          ""Propagate StrictSlash to subrouters"",
+			route:          r.NewRoute().PathPrefix(""/static/"").Subrouter().Path(""/images/""),
+			request:        newRequest(""GET"", ""http://localhost/static/images""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/static/images/"",
+			shouldMatch:    true,
+			shouldRedirect: true,
+		},
 		{
 			title:          ""Ignore StrictSlash for path prefix"",
 			route:          r.NewRoute().PathPrefix(""/static/""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=b864f07c539c7abc16652d65350d070d8e2810de,https://github.com/gorilla/mux/blob/b864f07c539c7abc16652d65350d070d8e2810de/mux_test.go
b864f07c539c7abc16652d65350d070d8e2810de,925f268abefa42313560382de9580f809db62892,regexp.go,,"Wed, 23 Apr 2014 17:53:35 GMT",modified,10,7,17,"@@ -98,12 +98,13 @@ func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*rout
 	}
 	// Done!
 	return &routeRegexp{
-		template:  template,
-		matchHost: matchHost,
-		regexp:    reg,
-		reverse:   reverse.String(),
-		varsN:     varsN,
-		varsR:     varsR,
+		template:    template,
+		matchHost:   matchHost,
+		strictSlash: strictSlash,
+		regexp:      reg,
+		reverse:     reverse.String(),
+		varsN:       varsN,
+		varsR:       varsR,
 	}, nil
 }
 
@@ -114,6 +115,8 @@ type routeRegexp struct {
 	template string
 	// True for host match, false for path match.
 	matchHost bool
+	// The strictSlash value defined on the route, but disabled if PathPrefix was used.
+	strictSlash bool
 	// Expanded regexp.
 	regexp *regexp.Regexp
 	// Reverse template.
@@ -216,7 +219,7 @@ func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route)
 				m.Vars[v] = pathVars[k+1]
 			}
 			// Check if we should redirect.
-			if r.strictSlash {
+			if v.path.strictSlash {
 				p1 := strings.HasSuffix(req.URL.Path, ""/"")
 				p2 := strings.HasSuffix(v.path.template, ""/"")
 				if p1 != p2 {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=b864f07c539c7abc16652d65350d070d8e2810de,https://github.com/gorilla/mux/blob/b864f07c539c7abc16652d65350d070d8e2810de/regexp.go
b864f07c539c7abc16652d65350d070d8e2810de,5cb2526d613909a6d622ebb6925490f3e23f0437,route.go,,"Wed, 23 Apr 2014 17:53:35 GMT",modified,0,1,1,"@@ -294,7 +294,6 @@ func (r *Route) Path(tpl string) *Route {
 // Also note that the setting of Router.StrictSlash() has no effect on routes
 // with a PathPrefix matcher.
 func (r *Route) PathPrefix(tpl string) *Route {
-	r.strictSlash = false
 	r.err = r.addRegexpMatcher(tpl, false, true)
 	return r
 }",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=b864f07c539c7abc16652d65350d070d8e2810de,https://github.com/gorilla/mux/blob/b864f07c539c7abc16652d65350d070d8e2810de/route.go
3509745ae8a2db852c51794a6f6e9f1e533e1632,63bc491495bf4c58ebd48dd596038939e4f08e8c,mux_test.go,,"Wed, 23 Apr 2014 17:27:53 GMT",modified,41,0,41,"@@ -620,11 +620,52 @@ func TestStrictSlash(t *testing.T) {
 	r.StrictSlash(true)
 
 	tests := []routeTest{
+		{
+			title:          ""Redirect path without slash"",
+			route:          r.NewRoute().Path(""/111/""),
+			request:        newRequest(""GET"", ""http://localhost/111""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/111/"",
+			shouldMatch:    true,
+			shouldRedirect: true,
+		},
+		{
+			title:          ""Do not redirect path with slash"",
+			route:          r.NewRoute().Path(""/111/""),
+			request:        newRequest(""GET"", ""http://localhost/111/""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/111/"",
+			shouldMatch:    true,
+			shouldRedirect: false,
+		},
+		{
+			title:          ""Redirect path with slash"",
+			route:          r.NewRoute().Path(""/111""),
+			request:        newRequest(""GET"", ""http://localhost/111/""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/111"",
+			shouldMatch:    true,
+			shouldRedirect: true,
+		},
+		{
+			title:          ""Do not redirect path without slash"",
+			route:          r.NewRoute().Path(""/111""),
+			request:        newRequest(""GET"", ""http://localhost/111""),
+			vars:           map[string]string{},
+			host:           """",
+			path:           ""/111"",
+			shouldMatch:    true,
+			shouldRedirect: false,
+		},
 		{
 			title:          ""Ignore StrictSlash for path prefix"",
 			route:          r.NewRoute().PathPrefix(""/static/""),
 			request:        newRequest(""GET"", ""http://localhost/static/logo.png""),
 			vars:           map[string]string{},
+			host:           """",
 			path:           ""/static/"",
 			shouldMatch:    true,
 			shouldRedirect: false,",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=3509745ae8a2db852c51794a6f6e9f1e533e1632,https://github.com/gorilla/mux/blob/3509745ae8a2db852c51794a6f6e9f1e533e1632/mux_test.go
bac13721298f7a2dbf554446a58826c2035e70e8,a67efeefde1f48dcae6ff7b3b94702faedeacccc,mux_test.go,,"Wed, 23 Apr 2014 17:24:12 GMT",modified,32,25,57,"@@ -13,13 +13,14 @@ import (
 )
 
 type routeTest struct {
-	title       string            // title of the test
-	route       *Route            // the route being tested
-	request     *http.Request     // a request to test the route
-	vars        map[string]string // the expected vars of the match
-	host        string            // the expected host of the match
-	path        string            // the expected path of the match
-	shouldMatch bool              // whether the request is expected to match the route at all
+	title          string            // title of the test
+	route          *Route            // the route being tested
+	request        *http.Request     // a request to test the route
+	vars           map[string]string // the expected vars of the match
+	host           string            // the expected host of the match
+	path           string            // the expected path of the match
+	shouldMatch    bool              // whether the request is expected to match the route at all
+	shouldRedirect bool              // whether the request should result in a redirect
 }
 
 func TestHost(t *testing.T) {
@@ -615,26 +616,23 @@ func TestNamedRoutes(t *testing.T) {
 }
 
 func TestStrictSlash(t *testing.T) {
-	var r *Router
-	var req *http.Request
-	var route *Route
-	var match *RouteMatch
-	var matched bool
-
-	// StrictSlash should be ignored for path prefix.
-	// So we register a route ending in slash but it doesn't attempt to add
-	// the slash for a path not ending in slash.
-	r = NewRouter()
+	r := NewRouter()
 	r.StrictSlash(true)
-	route = r.NewRoute().PathPrefix(""/static/"")
-	req, _ = http.NewRequest(""GET"", ""http://localhost/static/logo.png"", nil)
-	match = new(RouteMatch)
-	matched = r.Match(req, match)
-	if !matched {
-		t.Errorf(""Should match request %q -- %v"", req.URL.Path, getRouteTemplate(route))
+
+	tests := []routeTest{
+		{
+			title:          ""Ignore StrictSlash for path prefix"",
+			route:          r.NewRoute().PathPrefix(""/static/""),
+			request:        newRequest(""GET"", ""http://localhost/static/logo.png""),
+			vars:           map[string]string{},
+			path:           ""/static/"",
+			shouldMatch:    true,
+			shouldRedirect: false,
+		},
 	}
-	if match.Handler != nil {
-		t.Errorf(""Should not redirect"")
+
+	for _, test := range tests {
+		testRoute(t, test)
 	}
 }
 
@@ -663,6 +661,7 @@ func testRoute(t *testing.T, test routeTest) {
 	host := test.host
 	path := test.path
 	url := test.host + test.path
+	shouldRedirect := test.shouldRedirect
 
 	var match RouteMatch
 	ok := route.Match(request, &match)
@@ -700,6 +699,14 @@ func testRoute(t *testing.T, test routeTest) {
 				return
 			}
 		}
+		if shouldRedirect && match.Handler == nil {
+			t.Errorf(""(%v) Did not redirect"", test.title)
+			return
+		}
+		if !shouldRedirect && match.Handler != nil {
+			t.Errorf(""(%v) Unexpected redirect"", test.title)
+			return
+		}
 	}
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=bac13721298f7a2dbf554446a58826c2035e70e8,https://github.com/gorilla/mux/blob/bac13721298f7a2dbf554446a58826c2035e70e8/mux_test.go
033224c12ed48938d1815f4851103f86abcf6201,fa12ffa15cf68ce73b0db8b82cfaf8526a5c5558,mux.go,,"Wed, 23 Apr 2014 16:19:14 GMT",modified,7,2,9,"@@ -109,10 +109,15 @@ func (r *Router) GetRoute(name string) *Route {
 	return r.getNamedRoutes()[name]
 }
 
-// StrictSlash defines the slash behavior for new routes.
+// StrictSlash defines the trailing slash behavior for new routes. The initial
+// value is false.
 //
 // When true, if the route path is ""/path/"", accessing ""/path"" will redirect
-// to the former and vice versa.
+// to the former and vice versa. In other words, your application will always
+// see the path as specified in the route.
+//
+// When false, if the route path is ""/path"", accessing ""/path/"" will not match
+// this route and vice versa.
 //
 // Special case: when a route sets a path prefix, strict slash is
 // automatically set to false for that route because the redirect behavior",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=033224c12ed48938d1815f4851103f86abcf6201,https://github.com/gorilla/mux/blob/033224c12ed48938d1815f4851103f86abcf6201/mux.go
033224c12ed48938d1815f4851103f86abcf6201,29a4ef2d7d4b5399eb2600e6e331395e634fd39d,mux_test.go,,"Wed, 23 Apr 2014 16:19:14 GMT",modified,27,0,27,"@@ -151,6 +151,33 @@ func TestPath(t *testing.T) {
 			path:        ""/111/222/333"",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Path route, match with trailing slash in request and path"",
+			route:       new(Route).Path(""/111/""),
+			request:     newRequest(""GET"", ""http://localhost/111/""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111/"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route, do not match with trailing slash in path"",
+			route:       new(Route).Path(""/111/""),
+			request:     newRequest(""GET"", ""http://localhost/111""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Path route, do not match with trailing slash in request"",
+			route:       new(Route).Path(""/111""),
+			request:     newRequest(""GET"", ""http://localhost/111/""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111/"",
+			shouldMatch: false,
+		},
 		{
 			title:       ""Path route, wrong path in request in request URL"",
 			route:       new(Route).Path(""/111/222/333""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=033224c12ed48938d1815f4851103f86abcf6201,https://github.com/gorilla/mux/blob/033224c12ed48938d1815f4851103f86abcf6201/mux_test.go
033224c12ed48938d1815f4851103f86abcf6201,4ce8c823ae0072b6ec4c0679d9a2098a329b2110,route.go,,"Wed, 23 Apr 2014 16:19:14 GMT",modified,9,4,13,"@@ -284,10 +284,15 @@ func (r *Route) Path(tpl string) *Route {
 
 // PathPrefix -----------------------------------------------------------------
 
-// PathPrefix adds a matcher for the URL path prefix. Note that it does not
-// treat slashes specially (""/foobar/"" will be matched by the prefix ""/foo"") so
-// in most cases you'll want to use a trailing slash here. See Route.Path() for
-// details on the tpl argument.
+// PathPrefix adds a matcher for the URL path prefix. This matches if the given
+// template is a prefix of the full URL path. See Route.Path() for details on
+// the tpl argument.
+//
+// Note that it does not treat slashes specially (""/foobar/"" will be matched by
+// the prefix ""/foo"") so you may want to use a trailing slash here.
+//
+// Also note that the setting of Router.StrictSlash() has no effect on routes
+// with a PathPrefix matcher.
 func (r *Route) PathPrefix(tpl string) *Route {
 	r.strictSlash = false
 	r.err = r.addRegexpMatcher(tpl, false, true)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=033224c12ed48938d1815f4851103f86abcf6201,https://github.com/gorilla/mux/blob/033224c12ed48938d1815f4851103f86abcf6201/route.go
525eff436e45137f9c4ffa422f18bab457a96500,95b894cc9683096f9dcf66efd22e25315fe78094,mux_test.go,,"Wed, 23 Apr 2014 15:40:15 GMT",modified,9,0,9,"@@ -214,6 +214,15 @@ func TestPathPrefix(t *testing.T) {
 			path:        ""/111"",
 			shouldMatch: true,
 		},
+		{
+			title:       ""PathPrefix route, match substring"",
+			route:       new(Route).PathPrefix(""/1""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/1"",
+			shouldMatch: true,
+		},
 		{
 			title:       ""PathPrefix route, URL prefix in request does not match"",
 			route:       new(Route).PathPrefix(""/111""),",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=525eff436e45137f9c4ffa422f18bab457a96500,https://github.com/gorilla/mux/blob/525eff436e45137f9c4ffa422f18bab457a96500/mux_test.go
525eff436e45137f9c4ffa422f18bab457a96500,6bf84ec54de934efc605954ff4b7a2c482056077,route.go,,"Wed, 23 Apr 2014 15:40:15 GMT",modified,6,2,8,"@@ -259,7 +259,8 @@ func (r *Route) Methods(methods ...string) *Route {
 // Path -----------------------------------------------------------------------
 
 // Path adds a matcher for the URL path.
-// It accepts a template with zero or more URL variables enclosed by {}.
+// It accepts a template with zero or more URL variables enclosed by {}. The
+// template must start with a ""/"".
 // Variables can define an optional regexp pattern to me matched:
 //
 // - {name} matches anything until the next slash.
@@ -283,7 +284,10 @@ func (r *Route) Path(tpl string) *Route {
 
 // PathPrefix -----------------------------------------------------------------
 
-// PathPrefix adds a matcher for the URL path prefix.
+// PathPrefix adds a matcher for the URL path prefix. Note that it does not
+// treat slashes specially (""/foobar/"" will be matched by the prefix ""/foo"") so
+// in most cases you'll want to use a trailing slash here. See Route.Path() for
+// details on the tpl argument.
 func (r *Route) PathPrefix(tpl string) *Route {
 	r.strictSlash = false
 	r.err = r.addRegexpMatcher(tpl, false, true)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=525eff436e45137f9c4ffa422f18bab457a96500,https://github.com/gorilla/mux/blob/525eff436e45137f9c4ffa422f18bab457a96500/route.go
270c42505a11c779b5a5aaecfa5ec717adac996e,711630d285a32c171e565da599805a8527d84fee,mux.go,,"Sat, 19 Apr 2014 08:20:04 GMT",modified,1,1,2,"@@ -69,7 +69,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	if p := cleanPath(req.URL.Path); p != req.URL.Path {
 
 		// Added 3 lines (Philip Schlump) - It was droping the query string and #whatever from query.
-		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue: 
+		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
 		// http://code.google.com/p/go/issues/detail?id=5252
 		url := *req.URL
 		url.Path = p",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=270c42505a11c779b5a5aaecfa5ec717adac996e,https://github.com/gorilla/mux/blob/270c42505a11c779b5a5aaecfa5ec717adac996e/mux.go
270c42505a11c779b5a5aaecfa5ec717adac996e,292776d3015953d1ed6c8766365a0bc9826c8168,mux_test.go,,"Sat, 19 Apr 2014 08:20:04 GMT",modified,9,11,20,"@@ -22,7 +22,6 @@ type routeTest struct {
 	shouldMatch bool              // whether the request is expected to match the route at all
 }
 
-
 func TestHost(t *testing.T) {
 	// newRequestHost a new request with a method, url, and host header
 	newRequestHost := func(method, url, host string) *http.Request {
@@ -673,7 +672,7 @@ func testRoute(t *testing.T, test routeTest) {
 func TestKeepContext(t *testing.T) {
 	func1 := func(w http.ResponseWriter, r *http.Request) {}
 
-	r:= NewRouter()
+	r := NewRouter()
 	r.HandleFunc(""/"", func1).Name(""func1"")
 
 	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
@@ -698,21 +697,20 @@ func TestKeepContext(t *testing.T) {
 
 }
 
-
 type TestA301ResponseWriter struct {
-	hh			http.Header
-	status		int
+	hh     http.Header
+	status int
 }
 
 func (ho TestA301ResponseWriter) Header() http.Header {
 	return http.Header(ho.hh)
 }
 
-func (ho TestA301ResponseWriter) Write( b []byte) (int, error) {
+func (ho TestA301ResponseWriter) Write(b []byte) (int, error) {
 	return 0, nil
 }
 
-func (ho TestA301ResponseWriter) WriteHeader( code int ) {
+func (ho TestA301ResponseWriter) WriteHeader(code int) {
 	ho.status = code
 }
 
@@ -722,16 +720,16 @@ func Test301Redirect(t *testing.T) {
 	func1 := func(w http.ResponseWriter, r *http.Request) {}
 	func2 := func(w http.ResponseWriter, r *http.Request) {}
 
-	r:= NewRouter()
+	r := NewRouter()
 	r.HandleFunc(""/api/"", func2).Name(""func2"")
 	r.HandleFunc(""/"", func1).Name(""func1"")
 
 	req, _ := http.NewRequest(""GET"", ""http://localhost//api/?abc=def"", nil)
 
 	res := TestA301ResponseWriter{
-			hh: m,
-			status : 0,
-		}
+		hh:     m,
+		status: 0,
+	}
 	r.ServeHTTP(&res, req)
 
 	if ""http://localhost/api/?abc=def"" != res.hh[""Location""][0] {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=270c42505a11c779b5a5aaecfa5ec717adac996e,https://github.com/gorilla/mux/blob/270c42505a11c779b5a5aaecfa5ec717adac996e/mux_test.go
9ee70e572c1827c6524470f8fd12839bf7b98a39,711630d285a32c171e565da599805a8527d84fee,mux.go,,"Thu, 17 Apr 2014 07:44:35 GMT",modified,1,1,2,"@@ -69,7 +69,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	if p := cleanPath(req.URL.Path); p != req.URL.Path {
 
 		// Added 3 lines (Philip Schlump) - It was droping the query string and #whatever from query.
-		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue: 
+		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
 		// http://code.google.com/p/go/issues/detail?id=5252
 		url := *req.URL
 		url.Path = p",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=9ee70e572c1827c6524470f8fd12839bf7b98a39,https://github.com/gorilla/mux/blob/9ee70e572c1827c6524470f8fd12839bf7b98a39/mux.go
9ee70e572c1827c6524470f8fd12839bf7b98a39,292776d3015953d1ed6c8766365a0bc9826c8168,mux_test.go,,"Thu, 17 Apr 2014 07:44:35 GMT",modified,9,11,20,"@@ -22,7 +22,6 @@ type routeTest struct {
 	shouldMatch bool              // whether the request is expected to match the route at all
 }
 
-
 func TestHost(t *testing.T) {
 	// newRequestHost a new request with a method, url, and host header
 	newRequestHost := func(method, url, host string) *http.Request {
@@ -673,7 +672,7 @@ func testRoute(t *testing.T, test routeTest) {
 func TestKeepContext(t *testing.T) {
 	func1 := func(w http.ResponseWriter, r *http.Request) {}
 
-	r:= NewRouter()
+	r := NewRouter()
 	r.HandleFunc(""/"", func1).Name(""func1"")
 
 	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
@@ -698,21 +697,20 @@ func TestKeepContext(t *testing.T) {
 
 }
 
-
 type TestA301ResponseWriter struct {
-	hh			http.Header
-	status		int
+	hh     http.Header
+	status int
 }
 
 func (ho TestA301ResponseWriter) Header() http.Header {
 	return http.Header(ho.hh)
 }
 
-func (ho TestA301ResponseWriter) Write( b []byte) (int, error) {
+func (ho TestA301ResponseWriter) Write(b []byte) (int, error) {
 	return 0, nil
 }
 
-func (ho TestA301ResponseWriter) WriteHeader( code int ) {
+func (ho TestA301ResponseWriter) WriteHeader(code int) {
 	ho.status = code
 }
 
@@ -722,16 +720,16 @@ func Test301Redirect(t *testing.T) {
 	func1 := func(w http.ResponseWriter, r *http.Request) {}
 	func2 := func(w http.ResponseWriter, r *http.Request) {}
 
-	r:= NewRouter()
+	r := NewRouter()
 	r.HandleFunc(""/api/"", func2).Name(""func2"")
 	r.HandleFunc(""/"", func1).Name(""func1"")
 
 	req, _ := http.NewRequest(""GET"", ""http://localhost//api/?abc=def"", nil)
 
 	res := TestA301ResponseWriter{
-			hh: m,
-			status : 0,
-		}
+		hh:     m,
+		status: 0,
+	}
 	r.ServeHTTP(&res, req)
 
 	if ""http://localhost/api/?abc=def"" != res.hh[""Location""][0] {",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=9ee70e572c1827c6524470f8fd12839bf7b98a39,https://github.com/gorilla/mux/blob/9ee70e572c1827c6524470f8fd12839bf7b98a39/mux_test.go
9ede152210fa25c1377d33e867cb828c19316445,d87d4657686743eff53951131c0831d9aaac0ab3,.travis.yml,,"Thu, 05 Dec 2013 07:18:22 GMT",modified,1,0,1,"@@ -3,4 +3,5 @@ language: go
 go:
   - 1.0
   - 1.1
+  - 1.2
   - tip",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=9ede152210fa25c1377d33e867cb828c19316445,https://github.com/gorilla/mux/blob/9ede152210fa25c1377d33e867cb828c19316445/.travis.yml
c4e0d8b3719dc4b032bb2b98720f55b30c6310d4,ca51a011d0270d3d3fe1903781d97939ea70f3cf,mux.go,,"Sat, 30 Nov 2013 22:10:54 GMT",modified,8,0,8,"@@ -67,6 +67,14 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	// Clean path to canonical form and redirect.
 	if p := cleanPath(req.URL.Path); p != req.URL.Path {
+
+		// Added 3 lines (Philip Schlump) - It was droping the query string and #whatever from query.
+		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue: 
+		// http://code.google.com/p/go/issues/detail?id=5252
+		url := *req.URL
+		url.Path = p
+		p = url.String()
+
 		w.Header().Set(""Location"", p)
 		w.WriteHeader(http.StatusMovedPermanently)
 		return",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=c4e0d8b3719dc4b032bb2b98720f55b30c6310d4,https://github.com/gorilla/mux/blob/c4e0d8b3719dc4b032bb2b98720f55b30c6310d4/mux.go
c4e0d8b3719dc4b032bb2b98720f55b30c6310d4,1a2a092dfd4c73f0c335b54d2e4ab5a226579996,mux_test.go,,"Sat, 30 Nov 2013 22:10:54 GMT",modified,52,1,53,"@@ -22,6 +22,7 @@ type routeTest struct {
 	shouldMatch bool              // whether the request is expected to match the route at all
 }
 
+
 func TestHost(t *testing.T) {
 	// newRequestHost a new request with a method, url, and host header
 	newRequestHost := func(method, url, host string) *http.Request {
@@ -416,6 +417,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route, match with a query string"",
+			route:       new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route, bad query"",
 			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
@@ -663,7 +673,7 @@ func testRoute(t *testing.T, test routeTest) {
 func TestKeepContext(t *testing.T) {
 	func1 := func(w http.ResponseWriter, r *http.Request) {}
 
-	r := NewRouter()
+	r:= NewRouter()
 	r.HandleFunc(""/"", func1).Name(""func1"")
 
 	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
@@ -688,6 +698,47 @@ func TestKeepContext(t *testing.T) {
 
 }
 
+
+type TestA301ResponseWriter struct {
+	hh			http.Header
+	status		int
+}
+
+func (ho TestA301ResponseWriter) Header() http.Header {
+	return http.Header(ho.hh)
+}
+
+func (ho TestA301ResponseWriter) Write( b []byte) (int, error) {
+	return 0, nil
+}
+
+func (ho TestA301ResponseWriter) WriteHeader( code int ) {
+	ho.status = code
+}
+
+func Test301Redirect(t *testing.T) {
+	m := make(http.Header)
+
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+	func2 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r:= NewRouter()
+	r.HandleFunc(""/api/"", func2).Name(""func2"")
+	r.HandleFunc(""/"", func1).Name(""func1"")
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost//api/?abc=def"", nil)
+
+	res := TestA301ResponseWriter{
+			hh: m,
+			status : 0,
+		}
+	r.ServeHTTP(&res, req)
+
+	if ""http://localhost/api/?abc=def"" != res.hh[""Location""][0] {
+		t.Errorf(""Should have complete URL with query string"")
+	}
+}
+
 // https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
 func TestSubrouterHeader(t *testing.T) {
 	expected := ""func1 response""",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=c4e0d8b3719dc4b032bb2b98720f55b30c6310d4,https://github.com/gorilla/mux/blob/c4e0d8b3719dc4b032bb2b98720f55b30c6310d4/mux_test.go
e807f7c33833c2264798b00c24fce1cfb6d6b298,e60301b033632079f2efa772f0bfb13c0848e843,README.md,,"Sat, 30 Nov 2013 21:26:46 GMT",modified,1,0,1,"@@ -1,5 +1,6 @@
 mux
 ===
+[![Build Status](https://travis-ci.org/gorilla/mux.png?branch=master)](https://travis-ci.org/gorilla/mux)
 
 gorilla/mux is a powerful URL router and dispatcher.
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=e807f7c33833c2264798b00c24fce1cfb6d6b298,https://github.com/gorilla/mux/blob/e807f7c33833c2264798b00c24fce1cfb6d6b298/README.md
3829d74241c40bf4b132a413fddeb190b061dc95,70e012b81e44deacc5925ba65c74e4dd5294cad9,.travis.yml,,"Sat, 30 Nov 2013 21:24:27 GMT",added,6,0,6,"@@ -0,0 +1,6 @@
+language: go
+
+go:
+  - 1.0
+  - 1.1
+  - tip",https://api.github.com/repos/gorilla/mux/contents/.travis.yml?ref=3829d74241c40bf4b132a413fddeb190b061dc95,https://github.com/gorilla/mux/blob/3829d74241c40bf4b132a413fddeb190b061dc95/.travis.yml
db86729398c8fbcbdcbba60d6a9b7d8af635764b,42530590e77888adcf26d590df8a4846e1393f77,old_test.go,,"Sat, 30 Nov 2013 00:28:40 GMT",modified,4,4,8,"@@ -96,8 +96,8 @@ func TestRouteMatchers(t *testing.T) {
 		method = ""GET""
 		headers = map[string]string{""X-Requested-With"": ""XMLHttpRequest""}
 		resultVars = map[bool]map[string]string{
-			true:  map[string]string{""var1"": ""www"", ""var2"": ""product"", ""var3"": ""42""},
-			false: map[string]string{},
+			true:  {""var1"": ""www"", ""var2"": ""product"", ""var3"": ""42""},
+			false: {},
 		}
 	}
 
@@ -110,8 +110,8 @@ func TestRouteMatchers(t *testing.T) {
 		method = ""POST""
 		headers = map[string]string{""Content-Type"": ""application/json""}
 		resultVars = map[bool]map[string]string{
-			true:  map[string]string{""var4"": ""google"", ""var5"": ""product"", ""var6"": ""42""},
-			false: map[string]string{},
+			true:  {""var4"": ""google"", ""var5"": ""product"", ""var6"": ""42""},
+			false: {},
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=db86729398c8fbcbdcbba60d6a9b7d8af635764b,https://github.com/gorilla/mux/blob/db86729398c8fbcbdcbba60d6a9b7d8af635764b/old_test.go
cebebed6c46dc99617b23015fa96ef1f78d93ee4,42530590e77888adcf26d590df8a4846e1393f77,old_test.go,,"Sat, 30 Nov 2013 00:23:25 GMT",modified,4,4,8,"@@ -96,8 +96,8 @@ func TestRouteMatchers(t *testing.T) {
 		method = ""GET""
 		headers = map[string]string{""X-Requested-With"": ""XMLHttpRequest""}
 		resultVars = map[bool]map[string]string{
-			true:  map[string]string{""var1"": ""www"", ""var2"": ""product"", ""var3"": ""42""},
-			false: map[string]string{},
+			true:  {""var1"": ""www"", ""var2"": ""product"", ""var3"": ""42""},
+			false: {},
 		}
 	}
 
@@ -110,8 +110,8 @@ func TestRouteMatchers(t *testing.T) {
 		method = ""POST""
 		headers = map[string]string{""Content-Type"": ""application/json""}
 		resultVars = map[bool]map[string]string{
-			true:  map[string]string{""var4"": ""google"", ""var5"": ""product"", ""var6"": ""42""},
-			false: map[string]string{},
+			true:  {""var4"": ""google"", ""var5"": ""product"", ""var6"": ""42""},
+			false: {},
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=cebebed6c46dc99617b23015fa96ef1f78d93ee4,https://github.com/gorilla/mux/blob/cebebed6c46dc99617b23015fa96ef1f78d93ee4/old_test.go
ab8ae247f17a9f1bbe9bda321aa6719600eb4775,1a2a092dfd4c73f0c335b54d2e4ab5a226579996,mux_test.go,,"Mon, 18 Nov 2013 18:53:02 GMT",modified,2,2,4,"@@ -419,8 +419,8 @@ func TestQueries(t *testing.T) {
 		},
 		{
 			title:       ""Queries route, match with a query string"",
-			route:       new(Route).Host(""www.2cwhy.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request:     newRequest(""GET"", ""http://www.2cwhy.com/api?foo=bar&baz=ding""),
+			route:       new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
 			vars:        map[string]string{},
 			host:        """",
 			path:        """",",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=ab8ae247f17a9f1bbe9bda321aa6719600eb4775,https://github.com/gorilla/mux/blob/ab8ae247f17a9f1bbe9bda321aa6719600eb4775/mux_test.go
6689ee8243e28381f38fff95d65c84a575fa86f8,35f003758792aecea9b074f48cbd0e08d2cd088f,mux_test.go,,"Mon, 18 Nov 2013 17:54:45 GMT",modified,2,28,30,"@@ -8,7 +8,6 @@ import (
 	""fmt""
 	""net/http""
 	""testing""
-//	""encoding/json""				// Philip Schlump
 
 	""github.com/gorilla/context""
 )
@@ -23,17 +22,6 @@ type routeTest struct {
 	shouldMatch bool              // whether the request is expected to match the route at all
 }
 
-// Philip Schlump - added to understand the results from tests.
-//func dumpVar ( v interface{} ) {
-//	// s, err := json.Marshal ( v )
-//	s, err := json.MarshalIndent ( v, """", ""\t"" )
-//	if ( err != nil ) {
-//		fmt.Printf ( ""Error: %s\n"", err )
-//	} else {
-//		fmt.Printf ( ""%s\n"", s )
-//	}
-//}
-
 
 func TestHost(t *testing.T) {
 	// newRequestHost a new request with a method, url, and host header
@@ -430,7 +418,7 @@ func TestQueries(t *testing.T) {
 			shouldMatch: true,
 		},
 		{
-			title:       ""Queries route, match (ToDo - with redirect 301) (Philip Schlump added)"",
+			title:       ""Queries route, match with a query string"",
 			route:       new(Route).Host(""www.2cwhy.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:     newRequest(""GET"", ""http://www.2cwhy.com/api?foo=bar&baz=ding""),
 			vars:        map[string]string{},
@@ -677,8 +665,6 @@ func testRoute(t *testing.T, test routeTest) {
 				return
 			}
 		}
-		// Philip Schlump - Added to understand what match is returning.
-		// dumpVar ( match )
 	}
 }
 
@@ -719,17 +705,14 @@ type TestA301ResponseWriter struct {
 }
 
 func (ho TestA301ResponseWriter) Header() http.Header {
-	// fmt.Printf ( ""Header() called\n"" );
 	return http.Header(ho.hh)
 }
 
 func (ho TestA301ResponseWriter) Write( b []byte) (int, error) {
-	// fmt.Printf ( ""Write called %v\n"", b );
 	return 0, nil
 }
 
 func (ho TestA301ResponseWriter) WriteHeader( code int ) {
-	// fmt.Printf ( ""WriteHeader called code=%d\n"", code );
 	ho.status = code
 }
 
@@ -751,20 +734,11 @@ func Test301Redirect(t *testing.T) {
 		}
 	r.ServeHTTP(&res, req)
 
-	//fmt.Printf ( ""This one %v\n"", res );
-	//fmt.Printf ( ""res[\""Location\""] = ///%v///\n"", res.hh[""Location""] );
-	//fmt.Printf ( ""res[\""Location\""][0] = ///%v///\n"", res.hh[""Location""][0] );
 	if ""http://localhost/api/?abc=def"" != res.hh[""Location""][0] {
 		t.Errorf(""Should have complete URL with query string"")
 	}
-	// OK - I don't understand why this check on ""status is not working.
-	// (p.s. the real answer is I am still learning go)
-	//if 301 != res.status {
-	//	t.Errorf(""Should have status of 301, got %d"", res.status )
-	//}
-	//fmt.Printf ( ""Done\n"" );
-
 }
+
 // https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
 func TestSubrouterHeader(t *testing.T) {
 	expected := ""func1 response""",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=6689ee8243e28381f38fff95d65c84a575fa86f8,https://github.com/gorilla/mux/blob/6689ee8243e28381f38fff95d65c84a575fa86f8/mux_test.go
1a2411f44a858576b750ffb9d5c0975570ef1f2d,4cbd55dd7a72a4c635adb05e3175977b747ed595,mux_test.go,,"Mon, 18 Nov 2013 17:14:28 GMT",modified,78,1,79,"@@ -8,6 +8,7 @@ import (
 	""fmt""
 	""net/http""
 	""testing""
+//	""encoding/json""				// Philip Schlump
 
 	""github.com/gorilla/context""
 )
@@ -22,6 +23,18 @@ type routeTest struct {
 	shouldMatch bool              // whether the request is expected to match the route at all
 }
 
+// Philip Schlump - added to understand the results from tests.
+//func dumpVar ( v interface{} ) {
+//	// s, err := json.Marshal ( v )
+//	s, err := json.MarshalIndent ( v, """", ""\t"" )
+//	if ( err != nil ) {
+//		fmt.Printf ( ""Error: %s\n"", err )
+//	} else {
+//		fmt.Printf ( ""%s\n"", s )
+//	}
+//}
+
+
 func TestHost(t *testing.T) {
 	// newRequestHost a new request with a method, url, and host header
 	newRequestHost := func(method, url, host string) *http.Request {
@@ -416,6 +429,15 @@ func TestQueries(t *testing.T) {
 			path:        """",
 			shouldMatch: true,
 		},
+		{
+			title:       ""Queries route, match (ToDo - with redirect 301) (Philip Schlump added)"",
+			route:       new(Route).Host(""www.2cwhy.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://www.2cwhy.com/api?foo=bar&baz=ding""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
 			title:       ""Queries route, bad query"",
 			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
@@ -655,6 +677,8 @@ func testRoute(t *testing.T, test routeTest) {
 				return
 			}
 		}
+		// Philip Schlump - Added to understand what match is returning.
+		// dumpVar ( match )
 	}
 }
 
@@ -663,7 +687,7 @@ func testRoute(t *testing.T, test routeTest) {
 func TestKeepContext(t *testing.T) {
 	func1 := func(w http.ResponseWriter, r *http.Request) {}
 
-	r := NewRouter()
+	r:= NewRouter()
 	r.HandleFunc(""/"", func1).Name(""func1"")
 
 	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
@@ -688,6 +712,59 @@ func TestKeepContext(t *testing.T) {
 
 }
 
+
+type TestA301ResponseWriter struct {
+	hh			http.Header
+	status		int
+}
+
+func (ho TestA301ResponseWriter) Header() http.Header {
+	// fmt.Printf ( ""Header() called\n"" );
+	return http.Header(ho.hh)
+}
+
+func (ho TestA301ResponseWriter) Write( b []byte) (int, error) {
+	// fmt.Printf ( ""Write called %v\n"", b );
+	return 0, nil
+}
+
+func (ho TestA301ResponseWriter) WriteHeader( code int ) {
+	// fmt.Printf ( ""WriteHeader called code=%d\n"", code );
+	ho.status = code
+}
+
+func Test301Redirect(t *testing.T) {
+	m := make(http.Header)
+
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+	func2 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r:= NewRouter()
+	r.HandleFunc(""/api/"", func2).Name(""func2"")
+	r.HandleFunc(""/"", func1).Name(""func1"")
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost//api/?abc=def"", nil)
+
+	res := TestA301ResponseWriter{
+			hh: m,
+			status : 0,
+		}
+	r.ServeHTTP(&res, req)
+
+	//fmt.Printf ( ""This one %v\n"", res );
+	//fmt.Printf ( ""res[\""Location\""] = ///%v///\n"", res.hh[""Location""] );
+	//fmt.Printf ( ""res[\""Location\""][0] = ///%v///\n"", res.hh[""Location""][0] );
+	if ""http://localhost/api/?abc=def"" != res.hh[""Location""][0] {
+		t.Errorf(""Should have complete URL with query string"")
+	}
+	// OK - I don't understand why this check on ""status is not working.
+	// (p.s. the real answer is I am still learning go)
+	//if 301 != res.status {
+	//	t.Errorf(""Should have status of 301, got %d"", res.status )
+	//}
+	//fmt.Printf ( ""Done\n"" );
+
+}
 // https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
 func TestSubrouterHeader(t *testing.T) {
 	expected := ""func1 response""",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=1a2411f44a858576b750ffb9d5c0975570ef1f2d,https://github.com/gorilla/mux/blob/1a2411f44a858576b750ffb9d5c0975570ef1f2d/mux_test.go
d10d5466f2db2758bb616f627775692d2f69fe8a,ca51a011d0270d3d3fe1903781d97939ea70f3cf,mux.go,,"Fri, 15 Nov 2013 02:27:38 GMT",modified,8,0,8,"@@ -67,6 +67,14 @@ func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	// Clean path to canonical form and redirect.
 	if p := cleanPath(req.URL.Path); p != req.URL.Path {
+
+		// Added 3 lines (Philip Schlump) - It was droping the query string and #whatever from query.
+		// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue: 
+		// http://code.google.com/p/go/issues/detail?id=5252
+		url := *req.URL
+		url.Path = p
+		p = url.String()
+
 		w.Header().Set(""Location"", p)
 		w.WriteHeader(http.StatusMovedPermanently)
 		return",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=d10d5466f2db2758bb616f627775692d2f69fe8a,https://github.com/gorilla/mux/blob/d10d5466f2db2758bb616f627775692d2f69fe8a/mux.go
42cbcc5a246f176e74a0a29f1afc00a2cfd3d11d,b2deed34c47fcbc337a3f0ba001e9b1e61c37e5b,doc.go,,"Sun, 10 Nov 2013 06:54:15 GMT",modified,1,1,2,"@@ -134,7 +134,7 @@ the inner routes use it as base for their paths:
 	// ""/products/{key}/""
 	s.HandleFunc(""/{key}/"", ProductHandler)
 	// ""/products/{key}/details""
-	s.HandleFunc(""/{key}/details""), ProductDetailsHandler)
+	s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 
 Now let's see how to build registered URLs.
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=42cbcc5a246f176e74a0a29f1afc00a2cfd3d11d,https://github.com/gorilla/mux/blob/42cbcc5a246f176e74a0a29f1afc00a2cfd3d11d/doc.go
9d99a927754de25f584c08c423866c12207ce9e3,b2deed34c47fcbc337a3f0ba001e9b1e61c37e5b,doc.go,,"Sun, 10 Nov 2013 04:22:06 GMT",modified,1,1,2,"@@ -134,7 +134,7 @@ the inner routes use it as base for their paths:
 	// ""/products/{key}/""
 	s.HandleFunc(""/{key}/"", ProductHandler)
 	// ""/products/{key}/details""
-	s.HandleFunc(""/{key}/details""), ProductDetailsHandler)
+	s.HandleFunc(""/{key}/details"", ProductDetailsHandler)
 
 Now let's see how to build registered URLs.
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=9d99a927754de25f584c08c423866c12207ce9e3,https://github.com/gorilla/mux/blob/9d99a927754de25f584c08c423866c12207ce9e3/doc.go
b08c5fcf14d01cb0c20ddf70157f54d4a2c3a38a,ddc1acc63f00f742c5b2e0b5c2561227bff2ca8c,mux.go,,"Wed, 11 Sep 2013 20:10:56 GMT",modified,1,1,2,"@@ -46,7 +46,7 @@ type Router struct {
 	namedRoutes map[string]*Route
 	// See Router.StrictSlash(). This defines the flag for new routes.
 	strictSlash bool
-	// If true, do not clear the the request context after handling the request
+	// If true, do not clear the request context after handling the request
 	KeepContext bool
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=b08c5fcf14d01cb0c20ddf70157f54d4a2c3a38a,https://github.com/gorilla/mux/blob/b08c5fcf14d01cb0c20ddf70157f54d4a2c3a38a/mux.go
0ae6d35b080d1dcbc5744904e4aec8504283115d,ddc1acc63f00f742c5b2e0b5c2561227bff2ca8c,mux.go,,"Wed, 11 Sep 2013 18:33:30 GMT",modified,1,1,2,"@@ -46,7 +46,7 @@ type Router struct {
 	namedRoutes map[string]*Route
 	// See Router.StrictSlash(). This defines the flag for new routes.
 	strictSlash bool
-	// If true, do not clear the the request context after handling the request
+	// If true, do not clear the request context after handling the request
 	KeepContext bool
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=0ae6d35b080d1dcbc5744904e4aec8504283115d,https://github.com/gorilla/mux/blob/0ae6d35b080d1dcbc5744904e4aec8504283115d/mux.go
ea1bb06e006eada8e54ad4116dfdabcb8520862c,7766254d5270f56c5a41459f62283cb52213f823,route.go,,"Thu, 29 Aug 2013 16:41:54 GMT",modified,1,1,2,"@@ -328,7 +328,7 @@ func (m schemeMatcher) Match(r *http.Request, match *RouteMatch) bool {
 }
 
 // Schemes adds a matcher for URL schemes.
-// It accepts a sequence schemes to be matched, e.g.: ""http"", ""https"".
+// It accepts a sequence of schemes to be matched, e.g.: ""http"", ""https"".
 func (r *Route) Schemes(schemes ...string) *Route {
 	for k, v := range schemes {
 		schemes[k] = strings.ToLower(v)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=ea1bb06e006eada8e54ad4116dfdabcb8520862c,https://github.com/gorilla/mux/blob/ea1bb06e006eada8e54ad4116dfdabcb8520862c/route.go
04a79835ae36db13cbcc39e8420082a48549a42a,7766254d5270f56c5a41459f62283cb52213f823,route.go,,"Thu, 29 Aug 2013 16:05:40 GMT",modified,1,1,2,"@@ -328,7 +328,7 @@ func (m schemeMatcher) Match(r *http.Request, match *RouteMatch) bool {
 }
 
 // Schemes adds a matcher for URL schemes.
-// It accepts a sequence schemes to be matched, e.g.: ""http"", ""https"".
+// It accepts a sequence of schemes to be matched, e.g.: ""http"", ""https"".
 func (r *Route) Schemes(schemes ...string) *Route {
 	for k, v := range schemes {
 		schemes[k] = strings.ToLower(v)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=04a79835ae36db13cbcc39e8420082a48549a42a,https://github.com/gorilla/mux/blob/04a79835ae36db13cbcc39e8420082a48549a42a/route.go
e718e932ee606838744df844eb75064959eb74bc,6136ab9371e207a93604e8ec19b2ccc927bd45b4,mux.go,,"Wed, 10 Jul 2013 04:15:18 GMT",modified,6,2,8,"@@ -14,7 +14,7 @@ import (
 
 // NewRouter returns a new router instance.
 func NewRouter() *Router {
-	return &Router{namedRoutes: make(map[string]*Route)}
+	return &Router{namedRoutes: make(map[string]*Route), KeepContext: false}
 }
 
 // Router registers routes to be matched and dispatches a handler.
@@ -46,6 +46,8 @@ type Router struct {
 	namedRoutes map[string]*Route
 	// See Router.StrictSlash(). This defines the flag for new routes.
 	strictSlash bool
+	// If true, do not clear the the request context after handling the request
+	KeepContext bool
 }
 
 // Match matches registered routes against the request.
@@ -82,7 +84,9 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		}
 		handler = r.NotFoundHandler
 	}
-	defer context.Clear(req)
+	if !r.KeepContext {
+		defer context.Clear(req)
+	}
 	handler.ServeHTTP(w, req)
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=e718e932ee606838744df844eb75064959eb74bc,https://github.com/gorilla/mux/blob/e718e932ee606838744df844eb75064959eb74bc/mux.go
e718e932ee606838744df844eb75064959eb74bc,8789697f5130085bbb80286012d1431bc945b3ab,mux_test.go,,"Wed, 10 Jul 2013 04:15:18 GMT",modified,32,0,32,"@@ -8,6 +8,8 @@ import (
 	""fmt""
 	""net/http""
 	""testing""
+
+	""github.com/gorilla/context""
 )
 
 type routeTest struct {
@@ -656,6 +658,36 @@ func testRoute(t *testing.T, test routeTest) {
 	}
 }
 
+// Tests that the context is cleared or not cleared properly depending on
+// the configuration of the router
+func TestKeepContext(t *testing.T) {
+	func1 := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/"", func1).Name(""func1"")
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
+	context.Set(req, ""t"", 1)
+
+	res := new(http.ResponseWriter)
+	r.ServeHTTP(*res, req)
+
+	if _, ok := context.GetOk(req, ""t""); ok {
+		t.Error(""Context should have been cleared at end of request"")
+	}
+
+	r.KeepContext = true
+
+	req, _ = http.NewRequest(""GET"", ""http://localhost/"", nil)
+	context.Set(req, ""t"", 1)
+
+	r.ServeHTTP(*res, req)
+	if _, ok := context.GetOk(req, ""t""); !ok {
+		t.Error(""Context should NOT have been cleared at end of request"")
+	}
+
+}
+
 // https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
 func TestSubrouterHeader(t *testing.T) {
 	expected := ""func1 response""",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e718e932ee606838744df844eb75064959eb74bc,https://github.com/gorilla/mux/blob/e718e932ee606838744df844eb75064959eb74bc/mux_test.go
9b36453141c35697401168b07f2c09fcff7721ce,f6db41ad81d920e88183eea58e7d3619954d4ded,README.md,,"Mon, 08 Apr 2013 12:01:04 GMT",modified,5,1,6,"@@ -1,2 +1,6 @@
 mux
-===
\ No newline at end of file
+===
+
+gorilla/mux is a powerful URL router and dispatcher.
+
+Read the full documentation here: http://www.gorillatoolkit.org/pkg/mux",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=9b36453141c35697401168b07f2c09fcff7721ce,https://github.com/gorilla/mux/blob/9b36453141c35697401168b07f2c09fcff7721ce/README.md
b9f42e6d55989960ba207c48c8796e1eb9300433,8ee5540a4f900615272897ced1b07d6b35d5d685,doc.go,,"Mon, 25 Mar 2013 22:02:51 GMT",modified,1,1,2,"@@ -89,7 +89,7 @@ There are several other matchers that can be added. To match path prefixes:
 
 	r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
 		return r.ProtoMajor == 0
-        })
+    })
 
 ...and finally, it is possible to combine several matchers in a single route:
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=b9f42e6d55989960ba207c48c8796e1eb9300433,https://github.com/gorilla/mux/blob/b9f42e6d55989960ba207c48c8796e1eb9300433/doc.go
36205eb8f163300ce74c2930f1dd0ca4cbfce815,d6c597940a7d91e67512291eb5574f691fc6ea6f,doc.go,,"Mon, 25 Mar 2013 22:01:14 GMT",modified,3,1,4,"@@ -87,7 +87,9 @@ There are several other matchers that can be added. To match path prefixes:
 
 ...or to use a custom matcher function:
 
-	r.MatcherFunc(myFunc)
+	r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
+		return r.ProtoMajor == 0
+        })
 
 ...and finally, it is possible to combine several matchers in a single route:
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=36205eb8f163300ce74c2930f1dd0ca4cbfce815,https://github.com/gorilla/mux/blob/36205eb8f163300ce74c2930f1dd0ca4cbfce815/doc.go
bb851ab75f24e4a2ad8593bda4ce72a76164ec26,d6c597940a7d91e67512291eb5574f691fc6ea6f,doc.go,,"Mon, 25 Mar 2013 21:52:38 GMT",modified,3,1,4,"@@ -87,7 +87,9 @@ There are several other matchers that can be added. To match path prefixes:
 
 ...or to use a custom matcher function:
 
-	r.MatcherFunc(myFunc)
+	r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
+		return r.ProtoMajor == 0
+        })
 
 ...and finally, it is possible to combine several matchers in a single route:
 ",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=bb851ab75f24e4a2ad8593bda4ce72a76164ec26,https://github.com/gorilla/mux/blob/bb851ab75f24e4a2ad8593bda4ce72a76164ec26/doc.go
51a7bc30e9ae0df47f723814a4b0ab92109ea7eb,385717394c90acd7ddcf897fa9199345d59b06d7,mux.go,,"Sun, 03 Feb 2013 09:13:21 GMT",modified,2,2,4,"@@ -51,7 +51,7 @@ type Router struct {
 // Match matches registered routes against the request.
 func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 	for _, route := range r.routes {
-		if matched := route.Match(req, match); matched {
+		if route.Match(req, match) {
 			return true
 		}
 	}
@@ -71,7 +71,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	}
 	var match RouteMatch
 	var handler http.Handler
-	if matched := r.Match(req, &match); matched {
+	if r.Match(req, &match) {
 		handler = match.Handler
 		setVars(req, match.Vars)
 		setCurrentRoute(req, match.Route)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=51a7bc30e9ae0df47f723814a4b0ab92109ea7eb,https://github.com/gorilla/mux/blob/51a7bc30e9ae0df47f723814a4b0ab92109ea7eb/mux.go
38545dbae82fbb96b45986dcda1fcb87114904e2,385717394c90acd7ddcf897fa9199345d59b06d7,mux.go,,"Sun, 03 Feb 2013 02:48:19 GMT",modified,2,2,4,"@@ -51,7 +51,7 @@ type Router struct {
 // Match matches registered routes against the request.
 func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
 	for _, route := range r.routes {
-		if matched := route.Match(req, match); matched {
+		if route.Match(req, match) {
 			return true
 		}
 	}
@@ -71,7 +71,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	}
 	var match RouteMatch
 	var handler http.Handler
-	if matched := r.Match(req, &match); matched {
+	if r.Match(req, &match) {
 		handler = match.Handler
 		setVars(req, match.Vars)
 		setCurrentRoute(req, match.Route)",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=38545dbae82fbb96b45986dcda1fcb87114904e2,https://github.com/gorilla/mux/blob/38545dbae82fbb96b45986dcda1fcb87114904e2/mux.go
2d12ebab422784600e293e3d197f9cec45255c54,27d759182862ebc430e485196f78657d7825252f,mux.go,,"Thu, 17 Jan 2013 09:15:30 GMT",modified,1,1,2,"@@ -154,7 +154,7 @@ func (r *Router) Handle(path string, handler http.Handler) *Route {
 // HandleFunc registers a new route with a matcher for the URL path.
 // See Route.Path() and Route.HandlerFunc().
 func (r *Router) HandleFunc(path string, f func(http.ResponseWriter,
-	*http.Request),) *Route {
+	*http.Request)) *Route {
 	return r.NewRoute().Path(path).HandlerFunc(f)
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=2d12ebab422784600e293e3d197f9cec45255c54,https://github.com/gorilla/mux/blob/2d12ebab422784600e293e3d197f9cec45255c54/mux.go
78f60492585e9f21942b155e870e019a401937ef,27d759182862ebc430e485196f78657d7825252f,mux.go,,"Thu, 17 Jan 2013 08:52:41 GMT",modified,1,1,2,"@@ -154,7 +154,7 @@ func (r *Router) Handle(path string, handler http.Handler) *Route {
 // HandleFunc registers a new route with a matcher for the URL path.
 // See Route.Path() and Route.HandlerFunc().
 func (r *Router) HandleFunc(path string, f func(http.ResponseWriter,
-	*http.Request),) *Route {
+	*http.Request)) *Route {
 	return r.NewRoute().Path(path).HandlerFunc(f)
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=78f60492585e9f21942b155e870e019a401937ef,https://github.com/gorilla/mux/blob/78f60492585e9f21942b155e870e019a401937ef/mux.go
a8ad2b0f1353d35106d769d0b98d55eeee970594,55159bd10d35ef3bd3ebf7a60560ac72819871b0,mux_test.go,,"Thu, 27 Dec 2012 08:28:03 GMT",modified,13,5,18,"@@ -657,24 +657,32 @@ func testRoute(t *testing.T, test routeTest) {
 }
 
 // https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
-func testSubrouterHeader(t *testing.T, test routeTest) {
-	func1 := func(http.ResponseWriter, *http.Request) {}
+func TestSubrouterHeader(t *testing.T) {
+	expected := ""func1 response""
+	func1 := func(w http.ResponseWriter, r *http.Request) {
+		fmt.Fprint(w, expected)
+	}
 	func2 := func(http.ResponseWriter, *http.Request) {}
 
 	r := NewRouter()
-	s := r.Headers(""SomeSpecialHeader"").Subrouter()
+	s := r.Headers(""SomeSpecialHeader"", """").Subrouter()
 	s.HandleFunc(""/"", func1).Name(""func1"")
 	r.HandleFunc(""/"", func2).Name(""func2"")
 
 	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
-	req.Header.Add(""SomeSpecialHeader"", """")
+	req.Header.Add(""SomeSpecialHeader"", ""foo"")
 	match := new(RouteMatch)
 	matched := r.Match(req, match)
 	if !matched {
 		t.Errorf(""Should match request"")
 	}
 	if match.Route.GetName() != ""func1"" {
-		t.Errorf(""Expecting func1 handler"")
+		t.Errorf(""Expecting func1 handler, got %s"", match.Route.GetName())
+	}
+	resp := NewRecorder()
+	match.Handler.ServeHTTP(resp, req)
+	if resp.Body.String() != expected {
+		t.Errorf(""Expecting %q"", expected)
 	}
 }
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=a8ad2b0f1353d35106d769d0b98d55eeee970594,https://github.com/gorilla/mux/blob/a8ad2b0f1353d35106d769d0b98d55eeee970594/mux_test.go
b20a198901ae3876ded3120faac0b5feec7fab76,5ff0fe1d9136a66f83931c853e02cc99b4c49af7,mux_test.go,,"Thu, 27 Dec 2012 08:12:28 GMT",modified,22,0,22,"@@ -656,6 +656,28 @@ func testRoute(t *testing.T, test routeTest) {
 	}
 }
 
+// https://plus.google.com/101022900381697718949/posts/eWy6DjFJ6uW
+func testSubrouterHeader(t *testing.T, test routeTest) {
+	func1 := func(http.ResponseWriter, *http.Request) {}
+	func2 := func(http.ResponseWriter, *http.Request) {}
+
+	r := NewRouter()
+	s := r.Headers(""SomeSpecialHeader"").Subrouter()
+	s.HandleFunc(""/"", func1).Name(""func1"")
+	r.HandleFunc(""/"", func2).Name(""func2"")
+
+	req, _ := http.NewRequest(""GET"", ""http://localhost/"", nil)
+	req.Header.Add(""SomeSpecialHeader"", """")
+	match := new(RouteMatch)
+	matched := r.Match(req, match)
+	if !matched {
+		t.Errorf(""Should match request"")
+	}
+	if match.Route.GetName() != ""func1"" {
+		t.Errorf(""Expecting func1 handler"")
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=b20a198901ae3876ded3120faac0b5feec7fab76,https://github.com/gorilla/mux/blob/b20a198901ae3876ded3120faac0b5feec7fab76/mux_test.go
99a7fbf24450ad77ca5bbaaafa0b3d5978031d82,0ae175f0678102b610e7c3468c5c143b87e08a0d,mux_test.go,,"Tue, 16 Oct 2012 18:26:53 GMT",modified,542,478,1020,"@@ -10,492 +10,538 @@ import (
 	""testing""
 )
 
-// helper function to create a new request with a method and url
-func newRequest(method, url string) *http.Request {
-	req, err := http.NewRequest(method, url, nil)
-	if err != nil {
-		panic(err)
+type routeTest struct {
+	title       string            // title of the test
+	route       *Route            // the route being tested
+	request     *http.Request     // a request to test the route
+	vars        map[string]string // the expected vars of the match
+	host        string            // the expected host of the match
+	path        string            // the expected path of the match
+	shouldMatch bool              // whether the request is expected to match the route at all
+}
+
+func TestHost(t *testing.T) {
+	// newRequestHost a new request with a method, url, and host header
+	newRequestHost := func(method, url, host string) *http.Request {
+		req, err := http.NewRequest(method, url, nil)
+		if err != nil {
+			panic(err)
+		}
+		req.Host = host
+		return req
+	}
+
+	tests := []routeTest{
+		{
+			title:       ""Host route match"",
+			route:       new(Route).Host(""aaa.bbb.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route, wrong host in request URL"",
+			route:       new(Route).Host(""aaa.bbb.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host route with port, match"",
+			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc:1234"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with port, wrong port in request URL"",
+			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc:1234"",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host route, match with host in request header"",
+			route:       new(Route).Host(""aaa.bbb.ccc""),
+			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route, wrong host in request header"",
+			route:       new(Route).Host(""aaa.bbb.ccc""),
+			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: false,
+		},
+		// BUG {new(Route).Host(""aaa.bbb.ccc:1234""), newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""), map[string]string{}, ""aaa.bbb.ccc:1234"", """", true},
+		{
+			title:       ""Host route with port, wrong host in request header"",
+			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
+			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc:1234"",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host route with pattern, match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with pattern, wrong host in request URL"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host route with multiple patterns, match"",
+			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with multiple patterns, wrong host in request URL"",
+			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: false,
+		},
+	}
+	for _, test := range tests {
+		testRoute(t, test)
 	}
-	return req
 }
 
-// helper function to create a new request with a method, url, and host header
-func newRequestHost(method, url, host string) *http.Request {
-	req, err := http.NewRequest(method, url, nil)
-	if err != nil {
-		panic(err)
+func TestPath(t *testing.T) {
+	tests := []routeTest{
+		{
+			title:       ""Path route, match"",
+			route:       new(Route).Path(""/111/222/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route, wrong path in request in request URL"",
+			route:       new(Route).Path(""/111/222/333""),
+			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Path route with pattern, match"",
+			route:       new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v1"": ""222""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with pattern, URL in request does not match"",
+			route:       new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:        map[string]string{""v1"": ""222""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Path route with multiple patterns, match"",
+			route:       new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple patterns, URL in request does not match"",
+			route:       new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
 	}
-	req.Host = host
-	return req
 }
 
-// helper function to create a new request with a method, url, and headers
-func newRequestHeaders(method, url string, headers map[string]string) *http.Request {
-	req, err := http.NewRequest(method, url, nil)
-	if err != nil {
-		panic(err)
+func TestPathPrefix(t *testing.T) {
+	tests := []routeTest{
+		{
+			title:       ""PathPrefix route, match"",
+			route:       new(Route).PathPrefix(""/111""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""PathPrefix route, URL prefix in request does not match"",
+			route:       new(Route).PathPrefix(""/111""),
+			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""PathPrefix route with pattern, match"",
+			route:       new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v1"": ""222""},
+			host:        """",
+			path:        ""/111/222"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""PathPrefix route with pattern, URL prefix in request does not match"",
+			route:       new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:        map[string]string{""v1"": ""222""},
+			host:        """",
+			path:        ""/111/222"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""PathPrefix route with multiple patterns, match"",
+			route:       new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:        """",
+			path:        ""/111/222"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
+			route:       new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:        """",
+			path:        ""/111/222"",
+			shouldMatch: false,
+		},
 	}
-	for k, v := range headers {
-		req.Header.Add(k, v)
+
+	for _, test := range tests {
+		testRoute(t, test)
 	}
-	return req
 }
 
-// Tests for Route
-func TestRoute(t *testing.T) {
-	// match function for Custom tests
-	m := func(r *http.Request, m *RouteMatch) bool {
-		if r.URL.Host == ""aaa.bbb.ccc"" {
-			return true
+func TestHostPath(t *testing.T) {
+	tests := []routeTest{
+		{
+			title:       ""Host and Path route, match"",
+			route:       new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host and Path route, wrong host in request URL"",
+			route:       new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host and Path route with pattern, match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:        ""aaa.bbb.ccc"",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host and Path route with pattern, URL in request does not match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:        ""aaa.bbb.ccc"",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host and Path route with multiple patterns, match"",
+			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:        ""aaa.bbb.ccc"",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host and Path route with multiple patterns, URL in request does not match"",
+			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:        ""aaa.bbb.ccc"",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
+func TestHeaders(t *testing.T) {
+	// newRequestHeaders creates a new request with a method, url, and headers
+	newRequestHeaders := func(method, url string, headers map[string]string) *http.Request {
+		req, err := http.NewRequest(method, url, nil)
+		if err != nil {
+			panic(err)
 		}
-		return false
+		for k, v := range headers {
+			req.Header.Add(k, v)
+		}
+		return req
 	}
 
-	// the tests
-	tests := []struct {
-		title   string            // title of the test
-		route   *Route            // the route being tested
-		request *http.Request     // a request to test the route
-		vars    map[string]string // the expected vars of the match
-		host    string            // the expected host of the match
-		path    string            // the expected path of the match
-		match   bool              // whether the request is expected to match the route at all
-	}{
-		// Host
-		{
-			title:   ""Host route match"",
-			route:   new(Route).Host(""aaa.bbb.ccc""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route, wrong host in request URL"",
-			route:   new(Route).Host(""aaa.bbb.ccc""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host route with port, match"",
-			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc:1234"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route with port, wrong port in request URL"",
-			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc:1234"",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host route, match with host in request header"",
-			route:   new(Route).Host(""aaa.bbb.ccc""),
-			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route, wrong host in request header"",
-			route:   new(Route).Host(""aaa.bbb.ccc""),
-			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   false,
+	tests := []routeTest{
+		{
+			title:       ""Headers route, match"",
+			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
-		// BUG {new(Route).Host(""aaa.bbb.ccc:1234""), newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""), map[string]string{}, ""aaa.bbb.ccc:1234"", """", true},
 		{
-			title:   ""Host route with port, wrong host in request header"",
-			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
-			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc:1234"",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host route with pattern, match"",
-			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""bbb""},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route with pattern, wrong host in request URL"",
-			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""bbb""},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host route with multiple patterns, match"",
-			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route with multiple patterns, wrong host in request URL"",
-			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   false,
-		},
-
-		// Path
-		{
-			title:   ""Path route, match"",
-			route:   new(Route).Path(""/111/222/333""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Path route, wrong path in request in request URL"",
-			route:   new(Route).Path(""/111/222/333""),
-			request: newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-		{
-			title:   ""Path route with pattern, match"",
-			route:   new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{""v1"": ""222""},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Path route with pattern, URL in request does not match"",
-			route:   new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:    map[string]string{""v1"": ""222""},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-		{
-			title:   ""Path route with multiple patterns, match"",
-			route:   new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Path route with multiple patterns, URL in request does not match"",
-			route:   new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-
-		// PathPrefix
-		{
-			title:   ""PathPrefix route, match"",
-			route:   new(Route).PathPrefix(""/111""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    ""/111"",
-			match:   true,
-		},
-		{
-			title:   ""PathPrefix route, URL prefix in request does not match"",
-			route:   new(Route).PathPrefix(""/111""),
-			request: newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    ""/111"",
-			match:   false,
-		},
-		{
-			title:   ""PathPrefix route with pattern, match"",
-			route:   new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{""v1"": ""222""},
-			host:    """",
-			path:    ""/111/222"",
-			match:   true,
-		},
-		{
-			title:   ""PathPrefix route with pattern, URL prefix in request does not match"",
-			route:   new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:    map[string]string{""v1"": ""222""},
-			host:    """",
-			path:    ""/111/222"",
-			match:   false,
-		},
-		{
-			title:   ""PathPrefix route with multiple patterns, match"",
-			route:   new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:    """",
-			path:    ""/111/222"",
-			match:   true,
-		},
-		{
-			title:   ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
-			route:   new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:    """",
-			path:    ""/111/222"",
-			match:   false,
-		},
-
-		// Host + Path
-		{
-			title:   ""Host and Path route, match"",
-			route:   new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host and Path route, wrong host in request URL"",
-			route:   new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host and Path route with pattern, match"",
-			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:    ""aaa.bbb.ccc"",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Host and Path route with pattern, URL in request does not match"",
-			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:    ""aaa.bbb.ccc"",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-		{
-			title:   ""Host and Path route with multiple patterns, match"",
-			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:    ""aaa.bbb.ccc"",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Host and Path route with multiple patterns, URL in request does not match"",
-			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:    ""aaa.bbb.ccc"",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-
-		// Headers
-		{
-			title:   ""Headers route, match"",
-			route:   new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
-			request: newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Headers route, bad header values"",
-			route:   new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
-			request: newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
-		},
-
-		// Methods
-		{
-			title:   ""Methods route, match GET"",
-			route:   new(Route).Methods(""GET"", ""POST""),
-			request: newRequest(""GET"", ""http://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
-		},
+			title:       ""Headers route, bad header values"",
+			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+
+}
+
+func TestMethods(t *testing.T) {
+	tests := []routeTest{
 		{
-			title:   ""Methods route, match POST"",
-			route:   new(Route).Methods(""GET"", ""POST""),
-			request: newRequest(""POST"", ""http://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""Methods route, match GET"",
+			route:       new(Route).Methods(""GET"", ""POST""),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""Methods route, bad method"",
-			route:   new(Route).Methods(""GET"", ""POST""),
-			request: newRequest(""PUT"", ""http://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
-		},
-
-		// Queries
+			title:       ""Methods route, match POST"",
+			route:       new(Route).Methods(""GET"", ""POST""),
+			request:     newRequest(""POST"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
-			title:   ""Queries route, match"",
-			route:   new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request: newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""Methods route, bad method"",
+			route:       new(Route).Methods(""GET"", ""POST""),
+			request:     newRequest(""PUT"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
+func TestQueries(t *testing.T) {
+	tests := []routeTest{
+		{
+			title:       ""Queries route, match"",
+			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""Queries route, bad query"",
-			route:   new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request: newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
+			title:       ""Queries route, bad query"",
+			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
 		},
+	}
 
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
+func TestSchemes(t *testing.T) {
+	tests := []routeTest{
 		// Schemes
 		{
-			title:   ""Schemes route, match https"",
-			route:   new(Route).Schemes(""https"", ""ftp""),
-			request: newRequest(""GET"", ""https://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""Schemes route, match https"",
+			route:       new(Route).Schemes(""https"", ""ftp""),
+			request:     newRequest(""GET"", ""https://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""Schemes route, match ftp"",
-			route:   new(Route).Schemes(""https"", ""ftp""),
-			request: newRequest(""GET"", ""ftp://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""Schemes route, match ftp"",
+			route:       new(Route).Schemes(""https"", ""ftp""),
+			request:     newRequest(""GET"", ""ftp://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""Schemes route, bad scheme"",
-			route:   new(Route).Schemes(""https"", ""ftp""),
-			request: newRequest(""GET"", ""http://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
+			title:       ""Schemes route, bad scheme"",
+			route:       new(Route).Schemes(""https"", ""ftp""),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
 		},
+	}
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
+func TestMatcherFunc(t *testing.T) {
+	m := func(r *http.Request, m *RouteMatch) bool {
+		if r.URL.Host == ""aaa.bbb.ccc"" {
+			return true
+		}
+		return false
+	}
 
-		// Custom
+	tests := []routeTest{
 		{
-			title:   ""MatchFunc route, match"",
-			route:   new(Route).MatcherFunc(m),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""MatchFunc route, match"",
+			route:       new(Route).MatcherFunc(m),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""MatchFunc route, non-match"",
-			route:   new(Route).MatcherFunc(m),
-			request: newRequest(""GET"", ""http://aaa.222.ccc""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
+			title:       ""MatchFunc route, non-match"",
+			route:       new(Route).MatcherFunc(m),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
 		},
 	}
 
-	for i, test := range tests {
-		testRoute(t, fmt.Sprintf(""%v: %s"", i, test.title), test.match, test.route, test.request, test.vars, test.host, test.path, test.host+test.path)
+	for _, test := range tests {
+		testRoute(t, test)
 	}
 }
 
 func TestSubRouter(t *testing.T) {
-	var route *Route
-	var request *http.Request
-	var vars map[string]string
-	var host, path, url string
-
-	subrouter := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
-
-	// Setup an id so we can see which test failed. :)
-	var idValue int
-	id := func() int {
-		idValue++
-		return idValue
-	}
-
-	// ------------------------------------------------------------------------
-
-	route = subrouter.Path(""/{v2:[a-z]+}"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.google.com/bbb"", nil)
-	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""}
-	host = ""aaa.google.com""
-	path = ""/bbb""
-	url = host + path
-	testRoute(t, string(id()), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://111.google.com/111"", nil)
-	testRoute(t, string(id()), false, route, request, vars, host, path, url)
-
-	// ------------------------------------------------------------------------
-
-	subrouter = new(Route).PathPrefix(""/foo/{v1}"").Subrouter()
-	route = subrouter.Path(""/baz/{v2}"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/bar/baz/ding"", nil)
-	vars = map[string]string{""v1"": ""bar"", ""v2"": ""ding""}
-	host = """"
-	path = ""/foo/bar/baz/ding""
-	url = host + path
-	testRoute(t, string(id()), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/bar"", nil)
-	testRoute(t, string(id()), false, route, request, vars, host, path, url)
+	subrouter1 := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
+	subrouter2 := new(Route).PathPrefix(""/foo/{v1}"").Subrouter()
+
+	tests := []routeTest{
+		{
+			route:       subrouter1.Path(""/{v2:[a-z]+}""),
+			request:     newRequest(""GET"", ""http://aaa.google.com/bbb""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:        ""aaa.google.com"",
+			path:        ""/bbb"",
+			shouldMatch: true,
+		},
+		{
+			route:       subrouter1.Path(""/{v2:[a-z]+}""),
+			request:     newRequest(""GET"", ""http://111.google.com/111""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:        ""aaa.google.com"",
+			path:        ""/bbb"",
+			shouldMatch: false,
+		},
+		{
+			route:       subrouter2.Path(""/baz/{v2}""),
+			request:     newRequest(""GET"", ""http://localhost/foo/bar/baz/ding""),
+			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:        """",
+			path:        ""/foo/bar/baz/ding"",
+			shouldMatch: true,
+		},
+		{
+			route:       subrouter2.Path(""/baz/{v2}""),
+			request:     newRequest(""GET"", ""http://localhost/foo/bar""),
+			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:        """",
+			path:        ""/foo/bar/baz/ding"",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
 }
 
 func TestNamedRoutes(t *testing.T) {
@@ -521,6 +567,30 @@ func TestNamedRoutes(t *testing.T) {
 	}
 }
 
+func TestStrictSlash(t *testing.T) {
+	var r *Router
+	var req *http.Request
+	var route *Route
+	var match *RouteMatch
+	var matched bool
+
+	// StrictSlash should be ignored for path prefix.
+	// So we register a route ending in slash but it doesn't attempt to add
+	// the slash for a path not ending in slash.
+	r = NewRouter()
+	r.StrictSlash(true)
+	route = r.NewRoute().PathPrefix(""/static/"")
+	req, _ = http.NewRequest(""GET"", ""http://localhost/static/logo.png"", nil)
+	match = new(RouteMatch)
+	matched = r.Match(req, match)
+	if !matched {
+		t.Errorf(""Should match request %q -- %v"", req.URL.Path, getRouteTemplate(route))
+	}
+	if match.Handler != nil {
+		t.Errorf(""Should not redirect"")
+	}
+}
+
 // ----------------------------------------------------------------------------
 // Helpers
 // ----------------------------------------------------------------------------
@@ -538,71 +608,55 @@ func getRouteTemplate(route *Route) string {
 	return fmt.Sprintf(""Host: %v, Path: %v"", host, path)
 }
 
-func testRoute(t *testing.T, id string, shouldMatch bool, route *Route,
-	request *http.Request, vars map[string]string, host, path, url string) {
+func testRoute(t *testing.T, test routeTest) {
+	request := test.request
+	route := test.route
+	vars := test.vars
+	shouldMatch := test.shouldMatch
+	host := test.host
+	path := test.path
+	url := test.host + test.path
+
 	var match RouteMatch
 	ok := route.Match(request, &match)
 	if ok != shouldMatch {
 		msg := ""Should match""
 		if !shouldMatch {
 			msg = ""Should not match""
 		}
-		t.Errorf(""(%v) %v:\nRoute: %#v\nRequest: %#v\nVars: %v\n"", id, msg, route, request, vars)
+		t.Errorf(""(%v) %v:\nRoute: %#v\nRequest: %#v\nVars: %v\n"", test.title, msg, route, request, vars)
 		return
 	}
 	if shouldMatch {
-		if vars != nil && !stringMapEqual(vars, match.Vars) {
-			t.Errorf(""(%v) Vars not equal: expected %v, got %v"", id, vars, match.Vars)
+		if test.vars != nil && !stringMapEqual(test.vars, match.Vars) {
+			t.Errorf(""(%v) Vars not equal: expected %v, got %v"", test.title, vars, match.Vars)
 			return
 		}
 		if host != """" {
-			u, _ := route.URLHost(mapToPairs(match.Vars)...)
+			u, _ := test.route.URLHost(mapToPairs(match.Vars)...)
 			if host != u.Host {
-				t.Errorf(""(%v) URLHost not equal: expected %v, got %v -- %v"", id, host, u.Host, getRouteTemplate(route))
+				t.Errorf(""(%v) URLHost not equal: expected %v, got %v -- %v"", test.title, host, u.Host, getRouteTemplate(route))
 				return
 			}
 		}
 		if path != """" {
 			u, _ := route.URLPath(mapToPairs(match.Vars)...)
 			if path != u.Path {
-				t.Errorf(""(%v) URLPath not equal: expected %v, got %v -- %v"", id, path, u.Path, getRouteTemplate(route))
+				t.Errorf(""(%v) URLPath not equal: expected %v, got %v -- %v"", test.title, path, u.Path, getRouteTemplate(route))
 				return
 			}
 		}
 		if url != """" {
 			u, _ := route.URL(mapToPairs(match.Vars)...)
 			if url != u.Host+u.Path {
-				t.Errorf(""(%v) URL not equal: expected %v, got %v -- %v"", id, url, u.Host+u.Path, getRouteTemplate(route))
+				t.Errorf(""(%v) URL not equal: expected %v, got %v -- %v"", test.title, url, u.Host+u.Path, getRouteTemplate(route))
 				return
 			}
 		}
 	}
 }
 
-func TestStrictSlash(t *testing.T) {
-	var r *Router
-	var req *http.Request
-	var route *Route
-	var match *RouteMatch
-	var matched bool
-
-	// StrictSlash should be ignored for path prefix.
-	// So we register a route ending in slash but it doesn't attempt to add
-	// the slash for a path not ending in slash.
-	r = NewRouter()
-	r.StrictSlash(true)
-	route = r.NewRoute().PathPrefix(""/static/"")
-	req, _ = http.NewRequest(""GET"", ""http://localhost/static/logo.png"", nil)
-	match = new(RouteMatch)
-	matched = r.Match(req, match)
-	if !matched {
-		t.Errorf(""Should match request %q -- %v"", req.URL.Path, getRouteTemplate(route))
-	}
-	if match.Handler != nil {
-		t.Errorf(""Should not redirect"")
-	}
-}
-
+// mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int
 	p := make([]string, len(m)*2)
@@ -614,6 +668,7 @@ func mapToPairs(m map[string]string) []string {
 	return p
 }
 
+// stringMapEqual checks the equality of two string maps
 func stringMapEqual(m1, m2 map[string]string) bool {
 	nil1 := m1 == nil
 	nil2 := m2 == nil
@@ -627,3 +682,12 @@ func stringMapEqual(m1, m2 map[string]string) bool {
 	}
 	return true
 }
+
+// newRequest is a helper function to create a new request with a method and url
+func newRequest(method, url string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
+	}
+	return req
+}",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=99a7fbf24450ad77ca5bbaaafa0b3d5978031d82,https://github.com/gorilla/mux/blob/99a7fbf24450ad77ca5bbaaafa0b3d5978031d82/mux_test.go
f89494aed121356fbc0ab4c1143cfdf7256477ae,0ae175f0678102b610e7c3468c5c143b87e08a0d,mux_test.go,,"Sun, 14 Oct 2012 21:37:14 GMT",modified,542,478,1020,"@@ -10,492 +10,538 @@ import (
 	""testing""
 )
 
-// helper function to create a new request with a method and url
-func newRequest(method, url string) *http.Request {
-	req, err := http.NewRequest(method, url, nil)
-	if err != nil {
-		panic(err)
+type routeTest struct {
+	title       string            // title of the test
+	route       *Route            // the route being tested
+	request     *http.Request     // a request to test the route
+	vars        map[string]string // the expected vars of the match
+	host        string            // the expected host of the match
+	path        string            // the expected path of the match
+	shouldMatch bool              // whether the request is expected to match the route at all
+}
+
+func TestHost(t *testing.T) {
+	// newRequestHost a new request with a method, url, and host header
+	newRequestHost := func(method, url, host string) *http.Request {
+		req, err := http.NewRequest(method, url, nil)
+		if err != nil {
+			panic(err)
+		}
+		req.Host = host
+		return req
+	}
+
+	tests := []routeTest{
+		{
+			title:       ""Host route match"",
+			route:       new(Route).Host(""aaa.bbb.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route, wrong host in request URL"",
+			route:       new(Route).Host(""aaa.bbb.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host route with port, match"",
+			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc:1234"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with port, wrong port in request URL"",
+			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc:1234"",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host route, match with host in request header"",
+			route:       new(Route).Host(""aaa.bbb.ccc""),
+			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route, wrong host in request header"",
+			route:       new(Route).Host(""aaa.bbb.ccc""),
+			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: false,
+		},
+		// BUG {new(Route).Host(""aaa.bbb.ccc:1234""), newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""), map[string]string{}, ""aaa.bbb.ccc:1234"", """", true},
+		{
+			title:       ""Host route with port, wrong host in request header"",
+			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
+			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
+			vars:        map[string]string{},
+			host:        ""aaa.bbb.ccc:1234"",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host route with pattern, match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with pattern, wrong host in request URL"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host route with multiple patterns, match"",
+			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host route with multiple patterns, wrong host in request URL"",
+			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:        ""aaa.bbb.ccc"",
+			path:        """",
+			shouldMatch: false,
+		},
+	}
+	for _, test := range tests {
+		testRoute(t, test)
 	}
-	return req
 }
 
-// helper function to create a new request with a method, url, and host header
-func newRequestHost(method, url, host string) *http.Request {
-	req, err := http.NewRequest(method, url, nil)
-	if err != nil {
-		panic(err)
+func TestPath(t *testing.T) {
+	tests := []routeTest{
+		{
+			title:       ""Path route, match"",
+			route:       new(Route).Path(""/111/222/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route, wrong path in request in request URL"",
+			route:       new(Route).Path(""/111/222/333""),
+			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Path route with pattern, match"",
+			route:       new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v1"": ""222""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with pattern, URL in request does not match"",
+			route:       new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:        map[string]string{""v1"": ""222""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Path route with multiple patterns, match"",
+			route:       new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Path route with multiple patterns, URL in request does not match"",
+			route:       new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:        """",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
 	}
-	req.Host = host
-	return req
 }
 
-// helper function to create a new request with a method, url, and headers
-func newRequestHeaders(method, url string, headers map[string]string) *http.Request {
-	req, err := http.NewRequest(method, url, nil)
-	if err != nil {
-		panic(err)
+func TestPathPrefix(t *testing.T) {
+	tests := []routeTest{
+		{
+			title:       ""PathPrefix route, match"",
+			route:       new(Route).PathPrefix(""/111""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""PathPrefix route, URL prefix in request does not match"",
+			route:       new(Route).PathPrefix(""/111""),
+			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        ""/111"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""PathPrefix route with pattern, match"",
+			route:       new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v1"": ""222""},
+			host:        """",
+			path:        ""/111/222"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""PathPrefix route with pattern, URL prefix in request does not match"",
+			route:       new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:        map[string]string{""v1"": ""222""},
+			host:        """",
+			path:        ""/111/222"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""PathPrefix route with multiple patterns, match"",
+			route:       new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:        """",
+			path:        ""/111/222"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
+			route:       new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:        map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:        """",
+			path:        ""/111/222"",
+			shouldMatch: false,
+		},
 	}
-	for k, v := range headers {
-		req.Header.Add(k, v)
+
+	for _, test := range tests {
+		testRoute(t, test)
 	}
-	return req
 }
 
-// Tests for Route
-func TestRoute(t *testing.T) {
-	// match function for Custom tests
-	m := func(r *http.Request, m *RouteMatch) bool {
-		if r.URL.Host == ""aaa.bbb.ccc"" {
-			return true
+func TestHostPath(t *testing.T) {
+	tests := []routeTest{
+		{
+			title:       ""Host and Path route, match"",
+			route:       new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host and Path route, wrong host in request URL"",
+			route:       new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host and Path route with pattern, match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:        ""aaa.bbb.ccc"",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host and Path route with pattern, URL in request does not match"",
+			route:       new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:        ""aaa.bbb.ccc"",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+		{
+			title:       ""Host and Path route with multiple patterns, match"",
+			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:        ""aaa.bbb.ccc"",
+			path:        ""/111/222/333"",
+			shouldMatch: true,
+		},
+		{
+			title:       ""Host and Path route with multiple patterns, URL in request does not match"",
+			route:       new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:        ""aaa.bbb.ccc"",
+			path:        ""/111/222/333"",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
+func TestHeaders(t *testing.T) {
+	// newRequestHeaders creates a new request with a method, url, and headers
+	newRequestHeaders := func(method, url string, headers map[string]string) *http.Request {
+		req, err := http.NewRequest(method, url, nil)
+		if err != nil {
+			panic(err)
 		}
-		return false
+		for k, v := range headers {
+			req.Header.Add(k, v)
+		}
+		return req
 	}
 
-	// the tests
-	tests := []struct {
-		title   string            // title of the test
-		route   *Route            // the route being tested
-		request *http.Request     // a request to test the route
-		vars    map[string]string // the expected vars of the match
-		host    string            // the expected host of the match
-		path    string            // the expected path of the match
-		match   bool              // whether the request is expected to match the route at all
-	}{
-		// Host
-		{
-			title:   ""Host route match"",
-			route:   new(Route).Host(""aaa.bbb.ccc""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route, wrong host in request URL"",
-			route:   new(Route).Host(""aaa.bbb.ccc""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host route with port, match"",
-			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc:1234"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route with port, wrong port in request URL"",
-			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc:1234"",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host route, match with host in request header"",
-			route:   new(Route).Host(""aaa.bbb.ccc""),
-			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route, wrong host in request header"",
-			route:   new(Route).Host(""aaa.bbb.ccc""),
-			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   false,
+	tests := []routeTest{
+		{
+			title:       ""Headers route, match"",
+			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
-		// BUG {new(Route).Host(""aaa.bbb.ccc:1234""), newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""), map[string]string{}, ""aaa.bbb.ccc:1234"", """", true},
 		{
-			title:   ""Host route with port, wrong host in request header"",
-			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
-			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
-			vars:    map[string]string{},
-			host:    ""aaa.bbb.ccc:1234"",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host route with pattern, match"",
-			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""bbb""},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route with pattern, wrong host in request URL"",
-			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""bbb""},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host route with multiple patterns, match"",
-			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host route with multiple patterns, wrong host in request URL"",
-			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
-			host:    ""aaa.bbb.ccc"",
-			path:    """",
-			match:   false,
-		},
-
-		// Path
-		{
-			title:   ""Path route, match"",
-			route:   new(Route).Path(""/111/222/333""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Path route, wrong path in request in request URL"",
-			route:   new(Route).Path(""/111/222/333""),
-			request: newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-		{
-			title:   ""Path route with pattern, match"",
-			route:   new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{""v1"": ""222""},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Path route with pattern, URL in request does not match"",
-			route:   new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
-			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:    map[string]string{""v1"": ""222""},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-		{
-			title:   ""Path route with multiple patterns, match"",
-			route:   new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Path route with multiple patterns, URL in request does not match"",
-			route:   new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
-			host:    """",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-
-		// PathPrefix
-		{
-			title:   ""PathPrefix route, match"",
-			route:   new(Route).PathPrefix(""/111""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    ""/111"",
-			match:   true,
-		},
-		{
-			title:   ""PathPrefix route, URL prefix in request does not match"",
-			route:   new(Route).PathPrefix(""/111""),
-			request: newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    ""/111"",
-			match:   false,
-		},
-		{
-			title:   ""PathPrefix route with pattern, match"",
-			route:   new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{""v1"": ""222""},
-			host:    """",
-			path:    ""/111/222"",
-			match:   true,
-		},
-		{
-			title:   ""PathPrefix route with pattern, URL prefix in request does not match"",
-			route:   new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:    map[string]string{""v1"": ""222""},
-			host:    """",
-			path:    ""/111/222"",
-			match:   false,
-		},
-		{
-			title:   ""PathPrefix route with multiple patterns, match"",
-			route:   new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:    """",
-			path:    ""/111/222"",
-			match:   true,
-		},
-		{
-			title:   ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
-			route:   new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
-			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222""},
-			host:    """",
-			path:    ""/111/222"",
-			match:   false,
-		},
-
-		// Host + Path
-		{
-			title:   ""Host and Path route, match"",
-			route:   new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Host and Path route, wrong host in request URL"",
-			route:   new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
-		},
-		{
-			title:   ""Host and Path route with pattern, match"",
-			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:    ""aaa.bbb.ccc"",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Host and Path route with pattern, URL in request does not match"",
-			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
-			host:    ""aaa.bbb.ccc"",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-		{
-			title:   ""Host and Path route with multiple patterns, match"",
-			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:    ""aaa.bbb.ccc"",
-			path:    ""/111/222/333"",
-			match:   true,
-		},
-		{
-			title:   ""Host and Path route with multiple patterns, URL in request does not match"",
-			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
-			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
-			host:    ""aaa.bbb.ccc"",
-			path:    ""/111/222/333"",
-			match:   false,
-		},
-
-		// Headers
-		{
-			title:   ""Headers route, match"",
-			route:   new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
-			request: newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
-		},
-		{
-			title:   ""Headers route, bad header values"",
-			route:   new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
-			request: newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
-		},
-
-		// Methods
-		{
-			title:   ""Methods route, match GET"",
-			route:   new(Route).Methods(""GET"", ""POST""),
-			request: newRequest(""GET"", ""http://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
-		},
+			title:       ""Headers route, bad header values"",
+			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+
+}
+
+func TestMethods(t *testing.T) {
+	tests := []routeTest{
 		{
-			title:   ""Methods route, match POST"",
-			route:   new(Route).Methods(""GET"", ""POST""),
-			request: newRequest(""POST"", ""http://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""Methods route, match GET"",
+			route:       new(Route).Methods(""GET"", ""POST""),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""Methods route, bad method"",
-			route:   new(Route).Methods(""GET"", ""POST""),
-			request: newRequest(""PUT"", ""http://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
-		},
-
-		// Queries
+			title:       ""Methods route, match POST"",
+			route:       new(Route).Methods(""GET"", ""POST""),
+			request:     newRequest(""POST"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
+		},
 		{
-			title:   ""Queries route, match"",
-			route:   new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request: newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""Methods route, bad method"",
+			route:       new(Route).Methods(""GET"", ""POST""),
+			request:     newRequest(""PUT"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
+func TestQueries(t *testing.T) {
+	tests := []routeTest{
+		{
+			title:       ""Queries route, match"",
+			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""Queries route, bad query"",
-			route:   new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
-			request: newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
+			title:       ""Queries route, bad query"",
+			route:       new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request:     newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
 		},
+	}
 
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
+func TestSchemes(t *testing.T) {
+	tests := []routeTest{
 		// Schemes
 		{
-			title:   ""Schemes route, match https"",
-			route:   new(Route).Schemes(""https"", ""ftp""),
-			request: newRequest(""GET"", ""https://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""Schemes route, match https"",
+			route:       new(Route).Schemes(""https"", ""ftp""),
+			request:     newRequest(""GET"", ""https://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""Schemes route, match ftp"",
-			route:   new(Route).Schemes(""https"", ""ftp""),
-			request: newRequest(""GET"", ""ftp://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""Schemes route, match ftp"",
+			route:       new(Route).Schemes(""https"", ""ftp""),
+			request:     newRequest(""GET"", ""ftp://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""Schemes route, bad scheme"",
-			route:   new(Route).Schemes(""https"", ""ftp""),
-			request: newRequest(""GET"", ""http://localhost""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
+			title:       ""Schemes route, bad scheme"",
+			route:       new(Route).Schemes(""https"", ""ftp""),
+			request:     newRequest(""GET"", ""http://localhost""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
 		},
+	}
+	for _, test := range tests {
+		testRoute(t, test)
+	}
+}
+
+func TestMatcherFunc(t *testing.T) {
+	m := func(r *http.Request, m *RouteMatch) bool {
+		if r.URL.Host == ""aaa.bbb.ccc"" {
+			return true
+		}
+		return false
+	}
 
-		// Custom
+	tests := []routeTest{
 		{
-			title:   ""MatchFunc route, match"",
-			route:   new(Route).MatcherFunc(m),
-			request: newRequest(""GET"", ""http://aaa.bbb.ccc""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   true,
+			title:       ""MatchFunc route, match"",
+			route:       new(Route).MatcherFunc(m),
+			request:     newRequest(""GET"", ""http://aaa.bbb.ccc""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: true,
 		},
 		{
-			title:   ""MatchFunc route, non-match"",
-			route:   new(Route).MatcherFunc(m),
-			request: newRequest(""GET"", ""http://aaa.222.ccc""),
-			vars:    map[string]string{},
-			host:    """",
-			path:    """",
-			match:   false,
+			title:       ""MatchFunc route, non-match"",
+			route:       new(Route).MatcherFunc(m),
+			request:     newRequest(""GET"", ""http://aaa.222.ccc""),
+			vars:        map[string]string{},
+			host:        """",
+			path:        """",
+			shouldMatch: false,
 		},
 	}
 
-	for i, test := range tests {
-		testRoute(t, fmt.Sprintf(""%v: %s"", i, test.title), test.match, test.route, test.request, test.vars, test.host, test.path, test.host+test.path)
+	for _, test := range tests {
+		testRoute(t, test)
 	}
 }
 
 func TestSubRouter(t *testing.T) {
-	var route *Route
-	var request *http.Request
-	var vars map[string]string
-	var host, path, url string
-
-	subrouter := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
-
-	// Setup an id so we can see which test failed. :)
-	var idValue int
-	id := func() int {
-		idValue++
-		return idValue
-	}
-
-	// ------------------------------------------------------------------------
-
-	route = subrouter.Path(""/{v2:[a-z]+}"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.google.com/bbb"", nil)
-	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""}
-	host = ""aaa.google.com""
-	path = ""/bbb""
-	url = host + path
-	testRoute(t, string(id()), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://111.google.com/111"", nil)
-	testRoute(t, string(id()), false, route, request, vars, host, path, url)
-
-	// ------------------------------------------------------------------------
-
-	subrouter = new(Route).PathPrefix(""/foo/{v1}"").Subrouter()
-	route = subrouter.Path(""/baz/{v2}"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/bar/baz/ding"", nil)
-	vars = map[string]string{""v1"": ""bar"", ""v2"": ""ding""}
-	host = """"
-	path = ""/foo/bar/baz/ding""
-	url = host + path
-	testRoute(t, string(id()), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/bar"", nil)
-	testRoute(t, string(id()), false, route, request, vars, host, path, url)
+	subrouter1 := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
+	subrouter2 := new(Route).PathPrefix(""/foo/{v1}"").Subrouter()
+
+	tests := []routeTest{
+		{
+			route:       subrouter1.Path(""/{v2:[a-z]+}""),
+			request:     newRequest(""GET"", ""http://aaa.google.com/bbb""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:        ""aaa.google.com"",
+			path:        ""/bbb"",
+			shouldMatch: true,
+		},
+		{
+			route:       subrouter1.Path(""/{v2:[a-z]+}""),
+			request:     newRequest(""GET"", ""http://111.google.com/111""),
+			vars:        map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""},
+			host:        ""aaa.google.com"",
+			path:        ""/bbb"",
+			shouldMatch: false,
+		},
+		{
+			route:       subrouter2.Path(""/baz/{v2}""),
+			request:     newRequest(""GET"", ""http://localhost/foo/bar/baz/ding""),
+			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:        """",
+			path:        ""/foo/bar/baz/ding"",
+			shouldMatch: true,
+		},
+		{
+			route:       subrouter2.Path(""/baz/{v2}""),
+			request:     newRequest(""GET"", ""http://localhost/foo/bar""),
+			vars:        map[string]string{""v1"": ""bar"", ""v2"": ""ding""},
+			host:        """",
+			path:        ""/foo/bar/baz/ding"",
+			shouldMatch: false,
+		},
+	}
+
+	for _, test := range tests {
+		testRoute(t, test)
+	}
 }
 
 func TestNamedRoutes(t *testing.T) {
@@ -521,6 +567,30 @@ func TestNamedRoutes(t *testing.T) {
 	}
 }
 
+func TestStrictSlash(t *testing.T) {
+	var r *Router
+	var req *http.Request
+	var route *Route
+	var match *RouteMatch
+	var matched bool
+
+	// StrictSlash should be ignored for path prefix.
+	// So we register a route ending in slash but it doesn't attempt to add
+	// the slash for a path not ending in slash.
+	r = NewRouter()
+	r.StrictSlash(true)
+	route = r.NewRoute().PathPrefix(""/static/"")
+	req, _ = http.NewRequest(""GET"", ""http://localhost/static/logo.png"", nil)
+	match = new(RouteMatch)
+	matched = r.Match(req, match)
+	if !matched {
+		t.Errorf(""Should match request %q -- %v"", req.URL.Path, getRouteTemplate(route))
+	}
+	if match.Handler != nil {
+		t.Errorf(""Should not redirect"")
+	}
+}
+
 // ----------------------------------------------------------------------------
 // Helpers
 // ----------------------------------------------------------------------------
@@ -538,71 +608,55 @@ func getRouteTemplate(route *Route) string {
 	return fmt.Sprintf(""Host: %v, Path: %v"", host, path)
 }
 
-func testRoute(t *testing.T, id string, shouldMatch bool, route *Route,
-	request *http.Request, vars map[string]string, host, path, url string) {
+func testRoute(t *testing.T, test routeTest) {
+	request := test.request
+	route := test.route
+	vars := test.vars
+	shouldMatch := test.shouldMatch
+	host := test.host
+	path := test.path
+	url := test.host + test.path
+
 	var match RouteMatch
 	ok := route.Match(request, &match)
 	if ok != shouldMatch {
 		msg := ""Should match""
 		if !shouldMatch {
 			msg = ""Should not match""
 		}
-		t.Errorf(""(%v) %v:\nRoute: %#v\nRequest: %#v\nVars: %v\n"", id, msg, route, request, vars)
+		t.Errorf(""(%v) %v:\nRoute: %#v\nRequest: %#v\nVars: %v\n"", test.title, msg, route, request, vars)
 		return
 	}
 	if shouldMatch {
-		if vars != nil && !stringMapEqual(vars, match.Vars) {
-			t.Errorf(""(%v) Vars not equal: expected %v, got %v"", id, vars, match.Vars)
+		if test.vars != nil && !stringMapEqual(test.vars, match.Vars) {
+			t.Errorf(""(%v) Vars not equal: expected %v, got %v"", test.title, vars, match.Vars)
 			return
 		}
 		if host != """" {
-			u, _ := route.URLHost(mapToPairs(match.Vars)...)
+			u, _ := test.route.URLHost(mapToPairs(match.Vars)...)
 			if host != u.Host {
-				t.Errorf(""(%v) URLHost not equal: expected %v, got %v -- %v"", id, host, u.Host, getRouteTemplate(route))
+				t.Errorf(""(%v) URLHost not equal: expected %v, got %v -- %v"", test.title, host, u.Host, getRouteTemplate(route))
 				return
 			}
 		}
 		if path != """" {
 			u, _ := route.URLPath(mapToPairs(match.Vars)...)
 			if path != u.Path {
-				t.Errorf(""(%v) URLPath not equal: expected %v, got %v -- %v"", id, path, u.Path, getRouteTemplate(route))
+				t.Errorf(""(%v) URLPath not equal: expected %v, got %v -- %v"", test.title, path, u.Path, getRouteTemplate(route))
 				return
 			}
 		}
 		if url != """" {
 			u, _ := route.URL(mapToPairs(match.Vars)...)
 			if url != u.Host+u.Path {
-				t.Errorf(""(%v) URL not equal: expected %v, got %v -- %v"", id, url, u.Host+u.Path, getRouteTemplate(route))
+				t.Errorf(""(%v) URL not equal: expected %v, got %v -- %v"", test.title, url, u.Host+u.Path, getRouteTemplate(route))
 				return
 			}
 		}
 	}
 }
 
-func TestStrictSlash(t *testing.T) {
-	var r *Router
-	var req *http.Request
-	var route *Route
-	var match *RouteMatch
-	var matched bool
-
-	// StrictSlash should be ignored for path prefix.
-	// So we register a route ending in slash but it doesn't attempt to add
-	// the slash for a path not ending in slash.
-	r = NewRouter()
-	r.StrictSlash(true)
-	route = r.NewRoute().PathPrefix(""/static/"")
-	req, _ = http.NewRequest(""GET"", ""http://localhost/static/logo.png"", nil)
-	match = new(RouteMatch)
-	matched = r.Match(req, match)
-	if !matched {
-		t.Errorf(""Should match request %q -- %v"", req.URL.Path, getRouteTemplate(route))
-	}
-	if match.Handler != nil {
-		t.Errorf(""Should not redirect"")
-	}
-}
-
+// mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int
 	p := make([]string, len(m)*2)
@@ -614,6 +668,7 @@ func mapToPairs(m map[string]string) []string {
 	return p
 }
 
+// stringMapEqual checks the equality of two string maps
 func stringMapEqual(m1, m2 map[string]string) bool {
 	nil1 := m1 == nil
 	nil2 := m2 == nil
@@ -627,3 +682,12 @@ func stringMapEqual(m1, m2 map[string]string) bool {
 	}
 	return true
 }
+
+// newRequest is a helper function to create a new request with a method and url
+func newRequest(method, url string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
+	}
+	return req
+}",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=f89494aed121356fbc0ab4c1143cfdf7256477ae,https://github.com/gorilla/mux/blob/f89494aed121356fbc0ab4c1143cfdf7256477ae/mux_test.go
67d903c9a44618fd26fb4f8d0936b12904bd1c75,1277022932955626e6fd29fc4f720dcf0209f44b,mux_test.go,,"Fri, 05 Oct 2012 09:28:35 GMT",modified,438,226,664,"@@ -10,237 +10,449 @@ import (
 	""testing""
 )
 
-func TestRoute(t *testing.T) {
-	var route *Route
-	var request *http.Request
-	var vars map[string]string
-	var host, path, url string
-
-	// Setup an id so we can see which test failed. :)
-	var idValue int
-	id := func() int {
-		idValue++
-		return idValue
+// helper function to create a new request with a method and url
+func newRequest(method, url string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
 	}
+	return req
+}
 
-	// Host -------------------------------------------------------------------
-
-	route = new(Route).Host(""aaa.bbb.ccc"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{}
-	host = ""aaa.bbb.ccc""
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""bbb""}
-	host = ""aaa.bbb.ccc""
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""}
-	host = ""aaa.bbb.ccc""
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Path -------------------------------------------------------------------
-
-	route = new(Route).Path(""/111/222/333"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/1/2/3"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Path(""/111/{v1:[0-9]{3}}/333"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""222""}
-	host = """"
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""}
-	host = """"
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// PathPrefix -------------------------------------------------------------
-
-	route = new(Route).PathPrefix(""/111"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = ""/111""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/1/2/3"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).PathPrefix(""/111/{v1:[0-9]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""222""}
-	host = """"
-	path = ""/111/222""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""111"", ""v2"": ""222""}
-	host = """"
-	path = ""/111/222""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Host + Path ------------------------------------------------------------
-
-	route = new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""bbb"", ""v2"": ""222""}
-	host = ""aaa.bbb.ccc""
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""}
-	host = ""aaa.bbb.ccc""
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Headers ----------------------------------------------------------------
-
-	route = new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
-	request.Header.Add(""foo"", ""bar"")
-	request.Header.Add(""baz"", ""ding"")
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
-	request.Header.Add(""foo"", ""bar"")
-	request.Header.Add(""baz"", ""dong"")
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Methods ----------------------------------------------------------------
-
-	route = new(Route).Methods(""GET"", ""POST"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	request, _ = http.NewRequest(""POST"", ""http://localhost"", nil)
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""PUT"", ""http://localhost"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Queries ----------------------------------------------------------------
-
-	route = new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost?foo=bar&baz=ding"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost?foo=bar&baz=dong"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Schemes ----------------------------------------------------------------
-
-	route = new(Route).Schemes(""https"", ""ftp"")
-	request, _ = http.NewRequest(""GET"", ""https://localhost"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	request, _ = http.NewRequest(""GET"", ""ftp://localhost"", nil)
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
+// helper function to create a new request with a method, url, and host header
+func newRequestHost(method, url, host string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
+	}
+	req.Host = host
+	return req
+}
 
-	// Custom -----------------------------------------------------------------
+// helper function to create a new request with a method, url, and headers
+func newRequestHeaders(method, url string, headers map[string]string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
+	}
+	for k, v := range headers {
+		req.Header.Add(k, v)
+	}
+	return req
+}
 
+// Tests for Route
+func TestRoute(t *testing.T) {
+	// match function for Custom tests
 	m := func(r *http.Request, m *RouteMatch) bool {
 		if r.URL.Host == ""aaa.bbb.ccc"" {
 			return true
 		}
 		return false
 	}
-	route = new(Route).MatcherFunc(m)
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.ccc.bbb"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// the tests
+	tests := []struct {
+		title   string            // title of the test
+		route   *Route            // the route being tested
+		request *http.Request     // a request to test the route
+		vars    map[string]string // the expected vars of the match
+		host    string            // the expected host of the match
+		path    string            // the expected path of the match
+		match   bool              // whether the request is expected to match the route at all
+	}{
+		// Host
+		{
+			title:   ""Host route match"",
+			route:   new(Route).Host(""aaa.bbb.ccc""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route, wrong host in request URL"",
+			route:   new(Route).Host(""aaa.bbb.ccc""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host route with port, match"",
+			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc:1234"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route with port, wrong port in request URL"",
+			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc:1234"",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host route, match with host in request header"",
+			route:   new(Route).Host(""aaa.bbb.ccc""),
+			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route, wrong host in request header"",
+			route:   new(Route).Host(""aaa.bbb.ccc""),
+			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   false,
+		},
+		// BUG {new(Route).Host(""aaa.bbb.ccc:1234""), newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""), map[string]string{}, ""aaa.bbb.ccc:1234"", """", true},
+		{
+			title:   ""Host route with port, wrong host in request header"",
+			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
+			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc:1234"",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host route with pattern, match"",
+			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""bbb""},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route with pattern, wrong host in request URL"",
+			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""bbb""},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host route with multiple patterns, match"",
+			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route with multiple patterns, wrong host in request URL"",
+			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   false,
+		},
+
+		// Path
+		{
+			title:   ""Path route, match"",
+			route:   new(Route).Path(""/111/222/333""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Path route, wrong path in request in request URL"",
+			route:   new(Route).Path(""/111/222/333""),
+			request: newRequest(""GET"", ""http://localhost/1/2/3""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+		{
+			title:   ""Path route with pattern, match"",
+			route:   new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{""v1"": ""222""},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Path route with pattern, URL in request does not match"",
+			route:   new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:    map[string]string{""v1"": ""222""},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+		{
+			title:   ""Path route with multiple patterns, match"",
+			route:   new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Path route with multiple patterns, URL in request does not match"",
+			route:   new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+
+		// PathPrefix
+		{
+			title:   ""PathPrefix route, match"",
+			route:   new(Route).PathPrefix(""/111""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    ""/111"",
+			match:   true,
+		},
+		{
+			title:   ""PathPrefix route, URL prefix in request does not match"",
+			route:   new(Route).PathPrefix(""/111""),
+			request: newRequest(""GET"", ""http://localhost/1/2/3""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    ""/111"",
+			match:   false,
+		},
+		{
+			title:   ""PathPrefix route with pattern, match"",
+			route:   new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{""v1"": ""222""},
+			host:    """",
+			path:    ""/111/222"",
+			match:   true,
+		},
+		{
+			title:   ""PathPrefix route with pattern, URL prefix in request does not match"",
+			route:   new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:    map[string]string{""v1"": ""222""},
+			host:    """",
+			path:    ""/111/222"",
+			match:   false,
+		},
+		{
+			title:   ""PathPrefix route with multiple patterns, match"",
+			route:   new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:    """",
+			path:    ""/111/222"",
+			match:   true,
+		},
+		{
+			title:   ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
+			route:   new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:    """",
+			path:    ""/111/222"",
+			match:   false,
+		},
+
+		// Host + Path
+		{
+			title:   ""Host and Path route, match"",
+			route:   new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host and Path route, wrong host in request URL"",
+			route:   new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host and Path route with pattern, match"",
+			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:    ""aaa.bbb.ccc"",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Host and Path route with pattern, URL in request does not match"",
+			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:    ""aaa.bbb.ccc"",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+		{
+			title:   ""Host and Path route with multiple patterns, match"",
+			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:    ""aaa.bbb.ccc"",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Host and Path route with multiple patterns, URL in request does not match"",
+			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:    ""aaa.bbb.ccc"",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+
+		// Headers
+		{
+			title:   ""Headers route, match"",
+			route:   new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
+			request: newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Headers route, bad header values"",
+			route:   new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
+			request: newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+
+		// Methods
+		{
+			title:   ""Methods route, match GET"",
+			route:   new(Route).Methods(""GET"", ""POST""),
+			request: newRequest(""GET"", ""http://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Methods route, match POST"",
+			route:   new(Route).Methods(""GET"", ""POST""),
+			request: newRequest(""POST"", ""http://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Methods route, bad method"",
+			route:   new(Route).Methods(""GET"", ""POST""),
+			request: newRequest(""PUT"", ""http://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+
+		// Queries
+		{
+			title:   ""Queries route, match"",
+			route:   new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request: newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Queries route, bad query"",
+			route:   new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request: newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+
+		// Schemes
+		{
+			title:   ""Schemes route, match https"",
+			route:   new(Route).Schemes(""https"", ""ftp""),
+			request: newRequest(""GET"", ""https://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Schemes route, match ftp"",
+			route:   new(Route).Schemes(""https"", ""ftp""),
+			request: newRequest(""GET"", ""ftp://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Schemes route, bad scheme"",
+			route:   new(Route).Schemes(""https"", ""ftp""),
+			request: newRequest(""GET"", ""http://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+
+		// Custom
+		{
+			title:   ""MatchFunc route, match"",
+			route:   new(Route).MatcherFunc(m),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""MatchFunc route, non-match"",
+			route:   new(Route).MatcherFunc(m),
+			request: newRequest(""GET"", ""http://aaa.222.ccc""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+	}
+
+	for i, test := range tests {
+		testRoute(t, fmt.Sprintf(""%v: %s"", i, test.title), test.match, test.route, test.request, test.vars, test.host, test.path, test.host+test.path)
+	}
 }
 
 func TestSubRouter(t *testing.T) {
@@ -266,10 +478,10 @@ func TestSubRouter(t *testing.T) {
 	host = ""aaa.google.com""
 	path = ""/bbb""
 	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
+	testRoute(t, string(id()), true, route, request, vars, host, path, url)
 	// Non-match for the same config.
 	request, _ = http.NewRequest(""GET"", ""http://111.google.com/111"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
+	testRoute(t, string(id()), false, route, request, vars, host, path, url)
 
 	// ------------------------------------------------------------------------
 
@@ -280,10 +492,10 @@ func TestSubRouter(t *testing.T) {
 	host = """"
 	path = ""/foo/bar/baz/ding""
 	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
+	testRoute(t, string(id()), true, route, request, vars, host, path, url)
 	// Non-match for the same config.
 	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/bar"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
+	testRoute(t, string(id()), false, route, request, vars, host, path, url)
 }
 
 func TestNamedRoutes(t *testing.T) {
@@ -326,7 +538,7 @@ func getRouteTemplate(route *Route) string {
 	return fmt.Sprintf(""Host: %v, Path: %v"", host, path)
 }
 
-func testRoute(t *testing.T, id int, shouldMatch bool, route *Route,
+func testRoute(t *testing.T, id string, shouldMatch bool, route *Route,
 	request *http.Request, vars map[string]string, host, path, url string) {
 	var match RouteMatch
 	ok := route.Match(request, &match)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=67d903c9a44618fd26fb4f8d0936b12904bd1c75,https://github.com/gorilla/mux/blob/67d903c9a44618fd26fb4f8d0936b12904bd1c75/mux_test.go
bcb4f4bcdcd397e47609704f9b88c327db9eaa90,1277022932955626e6fd29fc4f720dcf0209f44b,mux_test.go,,"Fri, 05 Oct 2012 06:08:44 GMT",modified,438,226,664,"@@ -10,237 +10,449 @@ import (
 	""testing""
 )
 
-func TestRoute(t *testing.T) {
-	var route *Route
-	var request *http.Request
-	var vars map[string]string
-	var host, path, url string
-
-	// Setup an id so we can see which test failed. :)
-	var idValue int
-	id := func() int {
-		idValue++
-		return idValue
+// helper function to create a new request with a method and url
+func newRequest(method, url string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
 	}
+	return req
+}
 
-	// Host -------------------------------------------------------------------
-
-	route = new(Route).Host(""aaa.bbb.ccc"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{}
-	host = ""aaa.bbb.ccc""
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""bbb""}
-	host = ""aaa.bbb.ccc""
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""}
-	host = ""aaa.bbb.ccc""
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Path -------------------------------------------------------------------
-
-	route = new(Route).Path(""/111/222/333"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/1/2/3"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Path(""/111/{v1:[0-9]{3}}/333"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""222""}
-	host = """"
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""}
-	host = """"
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// PathPrefix -------------------------------------------------------------
-
-	route = new(Route).PathPrefix(""/111"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = ""/111""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/1/2/3"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).PathPrefix(""/111/{v1:[0-9]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""222""}
-	host = """"
-	path = ""/111/222""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""111"", ""v2"": ""222""}
-	host = """"
-	path = ""/111/222""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Host + Path ------------------------------------------------------------
-
-	route = new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""bbb"", ""v2"": ""222""}
-	host = ""aaa.bbb.ccc""
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	route = new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}"")
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
-	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""}
-	host = ""aaa.bbb.ccc""
-	path = ""/111/222/333""
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Headers ----------------------------------------------------------------
-
-	route = new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
-	request.Header.Add(""foo"", ""bar"")
-	request.Header.Add(""baz"", ""ding"")
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
-	request.Header.Add(""foo"", ""bar"")
-	request.Header.Add(""baz"", ""dong"")
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Methods ----------------------------------------------------------------
-
-	route = new(Route).Methods(""GET"", ""POST"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	request, _ = http.NewRequest(""POST"", ""http://localhost"", nil)
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""PUT"", ""http://localhost"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Queries ----------------------------------------------------------------
-
-	route = new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding"")
-	request, _ = http.NewRequest(""GET"", ""http://localhost?foo=bar&baz=ding"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost?foo=bar&baz=dong"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
-
-	// Schemes ----------------------------------------------------------------
-
-	route = new(Route).Schemes(""https"", ""ftp"")
-	request, _ = http.NewRequest(""GET"", ""https://localhost"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	request, _ = http.NewRequest(""GET"", ""ftp://localhost"", nil)
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
+// helper function to create a new request with a method, url, and host header
+func newRequestHost(method, url, host string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
+	}
+	req.Host = host
+	return req
+}
 
-	// Custom -----------------------------------------------------------------
+// helper function to create a new request with a method, url, and headers
+func newRequestHeaders(method, url string, headers map[string]string) *http.Request {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		panic(err)
+	}
+	for k, v := range headers {
+		req.Header.Add(k, v)
+	}
+	return req
+}
 
+// Tests for Route
+func TestRoute(t *testing.T) {
+	// match function for Custom tests
 	m := func(r *http.Request, m *RouteMatch) bool {
 		if r.URL.Host == ""aaa.bbb.ccc"" {
 			return true
 		}
 		return false
 	}
-	route = new(Route).MatcherFunc(m)
-	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc"", nil)
-	vars = map[string]string{}
-	host = """"
-	path = """"
-	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
-	// Non-match for the same config.
-	request, _ = http.NewRequest(""GET"", ""http://aaa.ccc.bbb"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// the tests
+	tests := []struct {
+		title   string            // title of the test
+		route   *Route            // the route being tested
+		request *http.Request     // a request to test the route
+		vars    map[string]string // the expected vars of the match
+		host    string            // the expected host of the match
+		path    string            // the expected path of the match
+		match   bool              // whether the request is expected to match the route at all
+	}{
+		// Host
+		{
+			title:   ""Host route match"",
+			route:   new(Route).Host(""aaa.bbb.ccc""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route, wrong host in request URL"",
+			route:   new(Route).Host(""aaa.bbb.ccc""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host route with port, match"",
+			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc:1234"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route with port, wrong port in request URL"",
+			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc:1234"",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host route, match with host in request header"",
+			route:   new(Route).Host(""aaa.bbb.ccc""),
+			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route, wrong host in request header"",
+			route:   new(Route).Host(""aaa.bbb.ccc""),
+			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   false,
+		},
+		// BUG {new(Route).Host(""aaa.bbb.ccc:1234""), newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""), map[string]string{}, ""aaa.bbb.ccc:1234"", """", true},
+		{
+			title:   ""Host route with port, wrong host in request header"",
+			route:   new(Route).Host(""aaa.bbb.ccc:1234""),
+			request: newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
+			vars:    map[string]string{},
+			host:    ""aaa.bbb.ccc:1234"",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host route with pattern, match"",
+			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""bbb""},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route with pattern, wrong host in request URL"",
+			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""bbb""},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host route with multiple patterns, match"",
+			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host route with multiple patterns, wrong host in request URL"",
+			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""},
+			host:    ""aaa.bbb.ccc"",
+			path:    """",
+			match:   false,
+		},
+
+		// Path
+		{
+			title:   ""Path route, match"",
+			route:   new(Route).Path(""/111/222/333""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Path route, wrong path in request in request URL"",
+			route:   new(Route).Path(""/111/222/333""),
+			request: newRequest(""GET"", ""http://localhost/1/2/3""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+		{
+			title:   ""Path route with pattern, match"",
+			route:   new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{""v1"": ""222""},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Path route with pattern, URL in request does not match"",
+			route:   new(Route).Path(""/111/{v1:[0-9]{3}}/333""),
+			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:    map[string]string{""v1"": ""222""},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+		{
+			title:   ""Path route with multiple patterns, match"",
+			route:   new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Path route with multiple patterns, URL in request does not match"",
+			route:   new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""},
+			host:    """",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+
+		// PathPrefix
+		{
+			title:   ""PathPrefix route, match"",
+			route:   new(Route).PathPrefix(""/111""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    ""/111"",
+			match:   true,
+		},
+		{
+			title:   ""PathPrefix route, URL prefix in request does not match"",
+			route:   new(Route).PathPrefix(""/111""),
+			request: newRequest(""GET"", ""http://localhost/1/2/3""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    ""/111"",
+			match:   false,
+		},
+		{
+			title:   ""PathPrefix route with pattern, match"",
+			route:   new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{""v1"": ""222""},
+			host:    """",
+			path:    ""/111/222"",
+			match:   true,
+		},
+		{
+			title:   ""PathPrefix route with pattern, URL prefix in request does not match"",
+			route:   new(Route).PathPrefix(""/111/{v1:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:    map[string]string{""v1"": ""222""},
+			host:    """",
+			path:    ""/111/222"",
+			match:   false,
+		},
+		{
+			title:   ""PathPrefix route with multiple patterns, match"",
+			route:   new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/222/333""),
+			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:    """",
+			path:    ""/111/222"",
+			match:   true,
+		},
+		{
+			title:   ""PathPrefix route with multiple patterns, URL prefix in request does not match"",
+			route:   new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://localhost/111/aaa/333""),
+			vars:    map[string]string{""v1"": ""111"", ""v2"": ""222""},
+			host:    """",
+			path:    ""/111/222"",
+			match:   false,
+		},
+
+		// Host + Path
+		{
+			title:   ""Host and Path route, match"",
+			route:   new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Host and Path route, wrong host in request URL"",
+			route:   new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+		{
+			title:   ""Host and Path route with pattern, match"",
+			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:    ""aaa.bbb.ccc"",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Host and Path route with pattern, URL in request does not match"",
+			route:   new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""bbb"", ""v2"": ""222""},
+			host:    ""aaa.bbb.ccc"",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+		{
+			title:   ""Host and Path route with multiple patterns, match"",
+			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:    ""aaa.bbb.ccc"",
+			path:    ""/111/222/333"",
+			match:   true,
+		},
+		{
+			title:   ""Host and Path route with multiple patterns, URL in request does not match"",
+			route:   new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}""),
+			request: newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
+			vars:    map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""},
+			host:    ""aaa.bbb.ccc"",
+			path:    ""/111/222/333"",
+			match:   false,
+		},
+
+		// Headers
+		{
+			title:   ""Headers route, match"",
+			route:   new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
+			request: newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Headers route, bad header values"",
+			route:   new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
+			request: newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+
+		// Methods
+		{
+			title:   ""Methods route, match GET"",
+			route:   new(Route).Methods(""GET"", ""POST""),
+			request: newRequest(""GET"", ""http://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Methods route, match POST"",
+			route:   new(Route).Methods(""GET"", ""POST""),
+			request: newRequest(""POST"", ""http://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Methods route, bad method"",
+			route:   new(Route).Methods(""GET"", ""POST""),
+			request: newRequest(""PUT"", ""http://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+
+		// Queries
+		{
+			title:   ""Queries route, match"",
+			route:   new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request: newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Queries route, bad query"",
+			route:   new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
+			request: newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+
+		// Schemes
+		{
+			title:   ""Schemes route, match https"",
+			route:   new(Route).Schemes(""https"", ""ftp""),
+			request: newRequest(""GET"", ""https://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Schemes route, match ftp"",
+			route:   new(Route).Schemes(""https"", ""ftp""),
+			request: newRequest(""GET"", ""ftp://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""Schemes route, bad scheme"",
+			route:   new(Route).Schemes(""https"", ""ftp""),
+			request: newRequest(""GET"", ""http://localhost""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+
+		// Custom
+		{
+			title:   ""MatchFunc route, match"",
+			route:   new(Route).MatcherFunc(m),
+			request: newRequest(""GET"", ""http://aaa.bbb.ccc""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   true,
+		},
+		{
+			title:   ""MatchFunc route, non-match"",
+			route:   new(Route).MatcherFunc(m),
+			request: newRequest(""GET"", ""http://aaa.222.ccc""),
+			vars:    map[string]string{},
+			host:    """",
+			path:    """",
+			match:   false,
+		},
+	}
+
+	for i, test := range tests {
+		testRoute(t, fmt.Sprintf(""%v: %s"", i, test.title), test.match, test.route, test.request, test.vars, test.host, test.path, test.host+test.path)
+	}
 }
 
 func TestSubRouter(t *testing.T) {
@@ -266,10 +478,10 @@ func TestSubRouter(t *testing.T) {
 	host = ""aaa.google.com""
 	path = ""/bbb""
 	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
+	testRoute(t, string(id()), true, route, request, vars, host, path, url)
 	// Non-match for the same config.
 	request, _ = http.NewRequest(""GET"", ""http://111.google.com/111"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
+	testRoute(t, string(id()), false, route, request, vars, host, path, url)
 
 	// ------------------------------------------------------------------------
 
@@ -280,10 +492,10 @@ func TestSubRouter(t *testing.T) {
 	host = """"
 	path = ""/foo/bar/baz/ding""
 	url = host + path
-	testRoute(t, id(), true, route, request, vars, host, path, url)
+	testRoute(t, string(id()), true, route, request, vars, host, path, url)
 	// Non-match for the same config.
 	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/bar"", nil)
-	testRoute(t, id(), false, route, request, vars, host, path, url)
+	testRoute(t, string(id()), false, route, request, vars, host, path, url)
 }
 
 func TestNamedRoutes(t *testing.T) {
@@ -326,7 +538,7 @@ func getRouteTemplate(route *Route) string {
 	return fmt.Sprintf(""Host: %v, Path: %v"", host, path)
 }
 
-func testRoute(t *testing.T, id int, shouldMatch bool, route *Route,
+func testRoute(t *testing.T, id string, shouldMatch bool, route *Route,
 	request *http.Request, vars map[string]string, host, path, url string) {
 	var match RouteMatch
 	ok := route.Match(request, &match)",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=bcb4f4bcdcd397e47609704f9b88c327db9eaa90,https://github.com/gorilla/mux/blob/bcb4f4bcdcd397e47609704f9b88c327db9eaa90/mux_test.go
eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,0e5fb872800da9557f75a5650bb9d80c1c2cf715,LICENSE,,"Wed, 03 Oct 2012 04:48:17 GMT",added,27,0,27,"@@ -0,0 +1,27 @@
+Copyright (c) 2012 Rodrigo Moraes. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+	 * Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+	 * Redistributions in binary form must reproduce the above
+copyright notice, this list of conditions and the following disclaimer
+in the documentation and/or other materials provided with the
+distribution.
+	 * Neither the name of Google Inc. nor the names of its
+contributors may be used to endorse or promote products derived from
+this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",https://api.github.com/repos/gorilla/mux/contents/LICENSE?ref=eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,https://github.com/gorilla/mux/blob/eac83ba2c004bb759a2875b1f1dbb032adf8bb4a/LICENSE
eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,c5f97b2b2a80b42d6cd21f2b3de9f9a0d3f5e788,bench_test.go,,"Wed, 03 Oct 2012 04:48:17 GMT",added,21,0,21,"@@ -0,0 +1,21 @@
+// Copyright 2012 The Gorilla Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mux
+
+import (
+	""net/http""
+	""testing""
+)
+
+func BenchmarkMux(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/v1/{v1}"", handler)
+
+	request, _ := http.NewRequest(""GET"", ""/v1/anything"", nil)
+	for i := 0; i < b.N; i++ {
+		router.ServeHTTP(nil, request)
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,https://github.com/gorilla/mux/blob/eac83ba2c004bb759a2875b1f1dbb032adf8bb4a/bench_test.go
eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,217e948fc1b2e1b812bf97312686e7764e02983b,doc.go,,"Wed, 03 Oct 2012 04:48:17 GMT",added,197,0,197,"@@ -0,0 +1,197 @@
+// Copyright 2012 The Gorilla Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+/*
+Package gorilla/mux implements a request router and dispatcher.
+
+The name mux stands for ""HTTP request multiplexer"". Like the standard
+http.ServeMux, mux.Router matches incoming requests against a list of
+registered routes and calls a handler for the route that matches the URL
+or other conditions. The main features are:
+
+	* Requests can be matched based on URL host, path, path prefix, schemes,
+	  header and query values, HTTP methods or using custom matchers.
+	* URL hosts and paths can have variables with an optional regular
+	  expression.
+	* Registered URLs can be built, or ""reversed"", which helps maintaining
+	  references to resources.
+	* Routes can be used as subrouters: nested routes are only tested if the
+	  parent route matches. This is useful to define groups of routes that
+	  share common conditions like a host, a path prefix or other repeated
+	  attributes. As a bonus, this optimizes request matching.
+	* It implements the http.Handler interface so it is compatible with the
+	  standard http.ServeMux.
+
+Let's start registering a couple of URL paths and handlers:
+
+	func main() {
+		r := mux.NewRouter()
+		r.HandleFunc(""/"", HomeHandler)
+		r.HandleFunc(""/products"", ProductsHandler)
+		r.HandleFunc(""/articles"", ArticlesHandler)
+		http.Handle(""/"", r)
+	}
+
+Here we register three routes mapping URL paths to handlers. This is
+equivalent to how http.HandleFunc() works: if an incoming request URL matches
+one of the paths, the corresponding handler is called passing
+(http.ResponseWriter, *http.Request) as parameters.
+
+Paths can have variables. They are defined using the format {name} or
+{name:pattern}. If a regular expression pattern is not defined, the matched
+variable will be anything until the next slash. For example:
+
+	r := mux.NewRouter()
+	r.HandleFunc(""/products/{key}"", ProductHandler)
+	r.HandleFunc(""/articles/{category}/"", ArticlesCategoryHandler)
+	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler)
+
+The names are used to create a map of route variables which can be retrieved
+calling mux.Vars():
+
+	vars := mux.Vars(request)
+	category := vars[""category""]
+
+And this is all you need to know about the basic usage. More advanced options
+are explained below.
+
+Routes can also be restricted to a domain or subdomain. Just define a host
+pattern to be matched. They can also have variables:
+
+	r := mux.NewRouter()
+	// Only matches if domain is ""www.domain.com"".
+	r.Host(""www.domain.com"")
+	// Matches a dynamic subdomain.
+	r.Host(""{subdomain:[a-z]+}.domain.com"")
+
+There are several other matchers that can be added. To match path prefixes:
+
+	r.PathPrefix(""/products/"")
+
+...or HTTP methods:
+
+	r.Methods(""GET"", ""POST"")
+
+...or URL schemes:
+
+	r.Schemes(""https"")
+
+...or header values:
+
+	r.Headers(""X-Requested-With"", ""XMLHttpRequest"")
+
+...or query values:
+
+	r.Queries(""key"", ""value"")
+
+...or to use a custom matcher function:
+
+	r.MatcherFunc(myFunc)
+
+...and finally, it is possible to combine several matchers in a single route:
+
+	r.HandleFunc(""/products"", ProductsHandler).
+	  Host(""www.domain.com"").
+	  Methods(""GET"").
+	  Schemes(""http"")
+
+Setting the same matching conditions again and again can be boring, so we have
+a way to group several routes that share the same requirements.
+We call it ""subrouting"".
+
+For example, let's say we have several URLs that should only match when the
+host is ""www.domain.com"". Create a route for that host and get a ""subrouter""
+from it:
+
+	r := mux.NewRouter()
+	s := r.Host(""www.domain.com"").Subrouter()
+
+Then register routes in the subrouter:
+
+	s.HandleFunc(""/products/"", ProductsHandler)
+	s.HandleFunc(""/products/{key}"", ProductHandler)
+	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+
+The three URL paths we registered above will only be tested if the domain is
+""www.domain.com"", because the subrouter is tested first. This is not
+only convenient, but also optimizes request matching. You can create
+subrouters combining any attribute matchers accepted by a route.
+
+Subrouters can be used to create domain or path ""namespaces"": you define
+subrouters in a central place and then parts of the app can register its
+paths relatively to a given subrouter.
+
+There's one more thing about subroutes. When a subrouter has a path prefix,
+the inner routes use it as base for their paths:
+
+	r := mux.NewRouter()
+	s := r.PathPrefix(""/products"").Subrouter()
+	// ""/products/""
+	s.HandleFunc(""/"", ProductsHandler)
+	// ""/products/{key}/""
+	s.HandleFunc(""/{key}/"", ProductHandler)
+	// ""/products/{key}/details""
+	s.HandleFunc(""/{key}/details""), ProductDetailsHandler)
+
+Now let's see how to build registered URLs.
+
+Routes can be named. All routes that define a name can have their URLs built,
+or ""reversed"". We define a name calling Name() on a route. For example:
+
+	r := mux.NewRouter()
+	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+	  Name(""article"")
+
+To build a URL, get the route and call the URL() method, passing a sequence of
+key/value pairs for the route variables. For the previous route, we would do:
+
+	url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+
+...and the result will be a url.URL with the following path:
+
+	""/articles/technology/42""
+
+This also works for host variables:
+
+	r := mux.NewRouter()
+	r.Host(""{subdomain}.domain.com"").
+	  Path(""/articles/{category}/{id:[0-9]+}"").
+	  HandlerFunc(ArticleHandler).
+	  Name(""article"")
+
+	// url.String() will be ""http://news.domain.com/articles/technology/42""
+	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+									 ""category"", ""technology"",
+									 ""id"", ""42"")
+
+All variables defined in the route are required, and their values must
+conform to the corresponding patterns. These requirements guarantee that a
+generated URL will always match a registered route -- the only exception is
+for explicitly defined ""build-only"" routes which never match.
+
+There's also a way to build only the URL host or path for a route:
+use the methods URLHost() or URLPath() instead. For the previous route,
+we would do:
+
+	// ""http://news.domain.com/""
+	host, err := r.Get(""article"").URLHost(""subdomain"", ""news"")
+
+	// ""/articles/technology/42""
+	path, err := r.Get(""article"").URLPath(""category"", ""technology"", ""id"", ""42"")
+
+And if you use subrouters, host and path defined separately can be built
+as well:
+
+	r := mux.NewRouter()
+	s := r.Host(""{subdomain}.domain.com"").Subrouter()
+	s.Path(""/articles/{category}/{id:[0-9]+}"").
+	  HandlerFunc(ArticleHandler).
+	  Name(""article"")
+
+	// ""http://news.domain.com/articles/technology/42""
+	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+									 ""category"", ""technology"",
+									 ""id"", ""42"")
+*/
+package mux",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,https://github.com/gorilla/mux/blob/eac83ba2c004bb759a2875b1f1dbb032adf8bb4a/doc.go
eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,62f00e84bbef8250a67b5fbe26af1b49fafc4b34,mux.go,,"Wed, 03 Oct 2012 04:48:17 GMT",added,335,0,335,"@@ -0,0 +1,335 @@
+// Copyright 2012 The Gorilla Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mux
+
+import (
+	""fmt""
+	""net/http""
+	""path""
+
+	""github.com/gorilla/context""
+)
+
+// NewRouter returns a new router instance.
+func NewRouter() *Router {
+	return &Router{namedRoutes: make(map[string]*Route)}
+}
+
+// Router registers routes to be matched and dispatches a handler.
+//
+// It implements the http.Handler interface, so it can be registered to serve
+// requests:
+//
+//     var router = mux.NewRouter()
+//
+//     func main() {
+//         http.Handle(""/"", router)
+//     }
+//
+// Or, for Google App Engine, register it in a init() function:
+//
+//     func init() {
+//         http.Handle(""/"", router)
+//     }
+//
+// This will send all incoming requests to the router.
+type Router struct {
+	// Configurable Handler to be used when no route matches.
+	NotFoundHandler http.Handler
+	// Parent route, if this is a subrouter.
+	parent parentRoute
+	// Routes to be matched, in order.
+	routes []*Route
+	// Routes by name for URL building.
+	namedRoutes map[string]*Route
+	// See Router.StrictSlash(). This defines the flag for new routes.
+	strictSlash bool
+}
+
+// Match matches registered routes against the request.
+func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
+	for _, route := range r.routes {
+		if matched := route.Match(req, match); matched {
+			return true
+		}
+	}
+	return false
+}
+
+// ServeHTTP dispatches the handler registered in the matched route.
+//
+// When there is a match, the route variables can be retrieved calling
+// mux.Vars(request).
+func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
+	// Clean path to canonical form and redirect.
+	if p := cleanPath(req.URL.Path); p != req.URL.Path {
+		w.Header().Set(""Location"", p)
+		w.WriteHeader(http.StatusMovedPermanently)
+		return
+	}
+	var match RouteMatch
+	var handler http.Handler
+	if matched := r.Match(req, &match); matched {
+		handler = match.Handler
+		setVars(req, match.Vars)
+		setCurrentRoute(req, match.Route)
+	}
+	if handler == nil {
+		if r.NotFoundHandler == nil {
+			r.NotFoundHandler = http.NotFoundHandler()
+		}
+		handler = r.NotFoundHandler
+	}
+	defer context.Clear(req)
+	handler.ServeHTTP(w, req)
+}
+
+// Get returns a route registered with the given name.
+func (r *Router) Get(name string) *Route {
+	return r.getNamedRoutes()[name]
+}
+
+// GetRoute returns a route registered with the given name. This method
+// was renamed to Get() and remains here for backwards compatibility.
+func (r *Router) GetRoute(name string) *Route {
+	return r.getNamedRoutes()[name]
+}
+
+// StrictSlash defines the slash behavior for new routes.
+//
+// When true, if the route path is ""/path/"", accessing ""/path"" will redirect
+// to the former and vice versa.
+//
+// Special case: when a route sets a path prefix, strict slash is
+// automatically set to false for that route because the redirect behavior
+// can't be determined for prefixes.
+func (r *Router) StrictSlash(value bool) *Router {
+	r.strictSlash = value
+	return r
+}
+
+// ----------------------------------------------------------------------------
+// parentRoute
+// ----------------------------------------------------------------------------
+
+// getNamedRoutes returns the map where named routes are registered.
+func (r *Router) getNamedRoutes() map[string]*Route {
+	if r.namedRoutes == nil {
+		if r.parent != nil {
+			r.namedRoutes = r.parent.getNamedRoutes()
+		} else {
+			r.namedRoutes = make(map[string]*Route)
+		}
+	}
+	return r.namedRoutes
+}
+
+// getRegexpGroup returns regexp definitions from the parent route, if any.
+func (r *Router) getRegexpGroup() *routeRegexpGroup {
+	if r.parent != nil {
+		return r.parent.getRegexpGroup()
+	}
+	return nil
+}
+
+// ----------------------------------------------------------------------------
+// Route factories
+// ----------------------------------------------------------------------------
+
+// NewRoute registers an empty route.
+func (r *Router) NewRoute() *Route {
+	route := &Route{parent: r, strictSlash: r.strictSlash}
+	r.routes = append(r.routes, route)
+	return route
+}
+
+// Handle registers a new route with a matcher for the URL path.
+// See Route.Path() and Route.Handler().
+func (r *Router) Handle(path string, handler http.Handler) *Route {
+	return r.NewRoute().Path(path).Handler(handler)
+}
+
+// HandleFunc registers a new route with a matcher for the URL path.
+// See Route.Path() and Route.HandlerFunc().
+func (r *Router) HandleFunc(path string, f func(http.ResponseWriter,
+	*http.Request),) *Route {
+	return r.NewRoute().Path(path).HandlerFunc(f)
+}
+
+// Headers registers a new route with a matcher for request header values.
+// See Route.Headers().
+func (r *Router) Headers(pairs ...string) *Route {
+	return r.NewRoute().Headers(pairs...)
+}
+
+// Host registers a new route with a matcher for the URL host.
+// See Route.Host().
+func (r *Router) Host(tpl string) *Route {
+	return r.NewRoute().Host(tpl)
+}
+
+// MatcherFunc registers a new route with a custom matcher function.
+// See Route.MatcherFunc().
+func (r *Router) MatcherFunc(f MatcherFunc) *Route {
+	return r.NewRoute().MatcherFunc(f)
+}
+
+// Methods registers a new route with a matcher for HTTP methods.
+// See Route.Methods().
+func (r *Router) Methods(methods ...string) *Route {
+	return r.NewRoute().Methods(methods...)
+}
+
+// Path registers a new route with a matcher for the URL path.
+// See Route.Path().
+func (r *Router) Path(tpl string) *Route {
+	return r.NewRoute().Path(tpl)
+}
+
+// PathPrefix registers a new route with a matcher for the URL path prefix.
+// See Route.PathPrefix().
+func (r *Router) PathPrefix(tpl string) *Route {
+	return r.NewRoute().PathPrefix(tpl)
+}
+
+// Queries registers a new route with a matcher for URL query values.
+// See Route.Queries().
+func (r *Router) Queries(pairs ...string) *Route {
+	return r.NewRoute().Queries(pairs...)
+}
+
+// Schemes registers a new route with a matcher for URL schemes.
+// See Route.Schemes().
+func (r *Router) Schemes(schemes ...string) *Route {
+	return r.NewRoute().Schemes(schemes...)
+}
+
+// ----------------------------------------------------------------------------
+// Context
+// ----------------------------------------------------------------------------
+
+// RouteMatch stores information about a matched route.
+type RouteMatch struct {
+	Route   *Route
+	Handler http.Handler
+	Vars    map[string]string
+}
+
+type contextKey int
+
+const (
+	varsKey contextKey = iota
+	routeKey
+)
+
+// Vars returns the route variables for the current request, if any.
+func Vars(r *http.Request) map[string]string {
+	if rv := context.Get(r, varsKey); rv != nil {
+		return rv.(map[string]string)
+	}
+	return nil
+}
+
+// CurrentRoute returns the matched route for the current request, if any.
+func CurrentRoute(r *http.Request) *Route {
+	if rv := context.Get(r, routeKey); rv != nil {
+		return rv.(*Route)
+	}
+	return nil
+}
+
+func setVars(r *http.Request, val interface{}) {
+	context.Set(r, varsKey, val)
+}
+
+func setCurrentRoute(r *http.Request, val interface{}) {
+	context.Set(r, routeKey, val)
+}
+
+// ----------------------------------------------------------------------------
+// Helpers
+// ----------------------------------------------------------------------------
+
+// cleanPath returns the canonical path for p, eliminating . and .. elements.
+// Borrowed from the net/http package.
+func cleanPath(p string) string {
+	if p == """" {
+		return ""/""
+	}
+	if p[0] != '/' {
+		p = ""/"" + p
+	}
+	np := path.Clean(p)
+	// path.Clean removes trailing slash except for root;
+	// put the trailing slash back if necessary.
+	if p[len(p)-1] == '/' && np != ""/"" {
+		np += ""/""
+	}
+	return np
+}
+
+// uniqueVars returns an error if two slices contain duplicated strings.
+func uniqueVars(s1, s2 []string) error {
+	for _, v1 := range s1 {
+		for _, v2 := range s2 {
+			if v1 == v2 {
+				return fmt.Errorf(""mux: duplicated route variable %q"", v2)
+			}
+		}
+	}
+	return nil
+}
+
+// mapFromPairs converts variadic string parameters to a string map.
+func mapFromPairs(pairs ...string) (map[string]string, error) {
+	length := len(pairs)
+	if length%2 != 0 {
+		return nil, fmt.Errorf(
+			""mux: number of parameters must be multiple of 2, got %v"", pairs)
+	}
+	m := make(map[string]string, length/2)
+	for i := 0; i < length; i += 2 {
+		m[pairs[i]] = pairs[i+1]
+	}
+	return m, nil
+}
+
+// matchInArray returns true if the given string value is in the array.
+func matchInArray(arr []string, value string) bool {
+	for _, v := range arr {
+		if v == value {
+			return true
+		}
+	}
+	return false
+}
+
+// matchMap returns true if the given key/value pairs exist in a given map.
+func matchMap(toCheck map[string]string, toMatch map[string][]string,
+	canonicalKey bool) bool {
+	for k, v := range toCheck {
+		// Check if key exists.
+		if canonicalKey {
+			k = http.CanonicalHeaderKey(k)
+		}
+		if values := toMatch[k]; values == nil {
+			return false
+		} else if v != """" {
+			// If value was defined as an empty string we only check that the
+			// key exists. Otherwise we also check for equality.
+			valueExists := false
+			for _, value := range values {
+				if v == value {
+					valueExists = true
+					break
+				}
+			}
+			if !valueExists {
+				return false
+			}
+		}
+	}
+	return true
+}",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,https://github.com/gorilla/mux/blob/eac83ba2c004bb759a2875b1f1dbb032adf8bb4a/mux.go
eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,19e0daf1dfbea7e76bd8d6dc62b84d57be55751a,mux_test.go,,"Wed, 03 Oct 2012 04:48:17 GMT",added,417,0,417,"@@ -0,0 +1,417 @@
+// Copyright 2012 The Gorilla Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mux
+
+import (
+	""fmt""
+	""net/http""
+	""testing""
+)
+
+func TestRoute(t *testing.T) {
+	var route *Route
+	var request *http.Request
+	var vars map[string]string
+	var host, path, url string
+
+	// Setup an id so we can see which test failed. :)
+	var idValue int
+	id := func() int {
+		idValue++
+		return idValue
+	}
+
+	// Host -------------------------------------------------------------------
+
+	route = new(Route).Host(""aaa.bbb.ccc"")
+	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
+	vars = map[string]string{}
+	host = ""aaa.bbb.ccc""
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	route = new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"")
+	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
+	vars = map[string]string{""v1"": ""bbb""}
+	host = ""aaa.bbb.ccc""
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	route = new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"")
+	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
+	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc""}
+	host = ""aaa.bbb.ccc""
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// Path -------------------------------------------------------------------
+
+	route = new(Route).Path(""/111/222/333"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
+	vars = map[string]string{}
+	host = """"
+	path = ""/111/222/333""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost/1/2/3"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	route = new(Route).Path(""/111/{v1:[0-9]{3}}/333"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
+	vars = map[string]string{""v1"": ""222""}
+	host = """"
+	path = ""/111/222/333""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	route = new(Route).Path(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}/{v3:[0-9]{3}}"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
+	vars = map[string]string{""v1"": ""111"", ""v2"": ""222"", ""v3"": ""333""}
+	host = """"
+	path = ""/111/222/333""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// PathPrefix -------------------------------------------------------------
+
+	route = new(Route).PathPrefix(""/111"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
+	vars = map[string]string{}
+	host = """"
+	path = ""/111""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost/1/2/3"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	route = new(Route).PathPrefix(""/111/{v1:[0-9]{3}}"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
+	vars = map[string]string{""v1"": ""222""}
+	host = """"
+	path = ""/111/222""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	route = new(Route).PathPrefix(""/{v1:[0-9]{3}}/{v2:[0-9]{3}}"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/222/333"", nil)
+	vars = map[string]string{""v1"": ""111"", ""v2"": ""222""}
+	host = """"
+	path = ""/111/222""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost/111/aaa/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// Host + Path ------------------------------------------------------------
+
+	route = new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333"")
+	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
+	vars = map[string]string{}
+	host = """"
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	route = new(Route).Host(""aaa.{v1:[a-z]{3}}.ccc"").Path(""/111/{v2:[0-9]{3}}/333"")
+	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
+	vars = map[string]string{""v1"": ""bbb"", ""v2"": ""222""}
+	host = ""aaa.bbb.ccc""
+	path = ""/111/222/333""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	route = new(Route).Host(""{v1:[a-z]{3}}.{v2:[a-z]{3}}.{v3:[a-z]{3}}"").Path(""/{v4:[0-9]{3}}/{v5:[0-9]{3}}/{v6:[0-9]{3}}"")
+	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333"", nil)
+	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb"", ""v3"": ""ccc"", ""v4"": ""111"", ""v5"": ""222"", ""v6"": ""333""}
+	host = ""aaa.bbb.ccc""
+	path = ""/111/222/333""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://aaa.222.ccc/111/222/333"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// Headers ----------------------------------------------------------------
+
+	route = new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
+	request.Header.Add(""foo"", ""bar"")
+	request.Header.Add(""baz"", ""ding"")
+	vars = map[string]string{}
+	host = """"
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
+	request.Header.Add(""foo"", ""bar"")
+	request.Header.Add(""baz"", ""dong"")
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// Methods ----------------------------------------------------------------
+
+	route = new(Route).Methods(""GET"", ""POST"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
+	vars = map[string]string{}
+	host = """"
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	request, _ = http.NewRequest(""POST"", ""http://localhost"", nil)
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""PUT"", ""http://localhost"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// Queries ----------------------------------------------------------------
+
+	route = new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost?foo=bar&baz=ding"", nil)
+	vars = map[string]string{}
+	host = """"
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost?foo=bar&baz=dong"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// Schemes ----------------------------------------------------------------
+
+	route = new(Route).Schemes(""https"", ""ftp"")
+	request, _ = http.NewRequest(""GET"", ""https://localhost"", nil)
+	vars = map[string]string{}
+	host = """"
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	request, _ = http.NewRequest(""GET"", ""ftp://localhost"", nil)
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// Custom -----------------------------------------------------------------
+
+	m := func(r *http.Request, m *RouteMatch) bool {
+		if r.URL.Host == ""aaa.bbb.ccc"" {
+			return true
+		}
+		return false
+	}
+	route = new(Route).MatcherFunc(m)
+	request, _ = http.NewRequest(""GET"", ""http://aaa.bbb.ccc"", nil)
+	vars = map[string]string{}
+	host = """"
+	path = """"
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://aaa.ccc.bbb"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+}
+
+func TestSubRouter(t *testing.T) {
+	var route *Route
+	var request *http.Request
+	var vars map[string]string
+	var host, path, url string
+
+	subrouter := new(Route).Host(""{v1:[a-z]+}.google.com"").Subrouter()
+
+	// Setup an id so we can see which test failed. :)
+	var idValue int
+	id := func() int {
+		idValue++
+		return idValue
+	}
+
+	// ------------------------------------------------------------------------
+
+	route = subrouter.Path(""/{v2:[a-z]+}"")
+	request, _ = http.NewRequest(""GET"", ""http://aaa.google.com/bbb"", nil)
+	vars = map[string]string{""v1"": ""aaa"", ""v2"": ""bbb""}
+	host = ""aaa.google.com""
+	path = ""/bbb""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://111.google.com/111"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+
+	// ------------------------------------------------------------------------
+
+	subrouter = new(Route).PathPrefix(""/foo/{v1}"").Subrouter()
+	route = subrouter.Path(""/baz/{v2}"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/bar/baz/ding"", nil)
+	vars = map[string]string{""v1"": ""bar"", ""v2"": ""ding""}
+	host = """"
+	path = ""/foo/bar/baz/ding""
+	url = host + path
+	testRoute(t, id(), true, route, request, vars, host, path, url)
+	// Non-match for the same config.
+	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/bar"", nil)
+	testRoute(t, id(), false, route, request, vars, host, path, url)
+}
+
+func TestNamedRoutes(t *testing.T) {
+	r1 := NewRouter()
+	r1.NewRoute().Name(""a"")
+	r1.NewRoute().Name(""b"")
+	r1.NewRoute().Name(""c"")
+
+	r2 := r1.NewRoute().Subrouter()
+	r2.NewRoute().Name(""d"")
+	r2.NewRoute().Name(""e"")
+	r2.NewRoute().Name(""f"")
+
+	r3 := r2.NewRoute().Subrouter()
+	r3.NewRoute().Name(""g"")
+	r3.NewRoute().Name(""h"")
+	r3.NewRoute().Name(""i"")
+
+	if r1.namedRoutes == nil || len(r1.namedRoutes) != 9 {
+		t.Errorf(""Expected 9 named routes, got %v"", r1.namedRoutes)
+	} else if r1.Get(""i"") == nil {
+		t.Errorf(""Subroute name not registered"")
+	}
+}
+
+// ----------------------------------------------------------------------------
+// Helpers
+// ----------------------------------------------------------------------------
+
+func getRouteTemplate(route *Route) string {
+	host, path := ""none"", ""none""
+	if route.regexp != nil {
+		if route.regexp.host != nil {
+			host = route.regexp.host.template
+		}
+		if route.regexp.path != nil {
+			path = route.regexp.path.template
+		}
+	}
+	return fmt.Sprintf(""Host: %v, Path: %v"", host, path)
+}
+
+func testRoute(t *testing.T, id int, shouldMatch bool, route *Route,
+	request *http.Request, vars map[string]string, host, path, url string) {
+	var match RouteMatch
+	ok := route.Match(request, &match)
+	if ok != shouldMatch {
+		msg := ""Should match""
+		if !shouldMatch {
+			msg = ""Should not match""
+		}
+		t.Errorf(""(%v) %v:\nRoute: %#v\nRequest: %#v\nVars: %v\n"", id, msg, route, request, vars)
+		return
+	}
+	if shouldMatch {
+		if vars != nil && !stringMapEqual(vars, match.Vars) {
+			t.Errorf(""(%v) Vars not equal: expected %v, got %v"", id, vars, match.Vars)
+			return
+		}
+		if host != """" {
+			u, _ := route.URLHost(mapToPairs(match.Vars)...)
+			if host != u.Host {
+				t.Errorf(""(%v) URLHost not equal: expected %v, got %v -- %v"", id, host, u.Host, getRouteTemplate(route))
+				return
+			}
+		}
+		if path != """" {
+			u, _ := route.URLPath(mapToPairs(match.Vars)...)
+			if path != u.Path {
+				t.Errorf(""(%v) URLPath not equal: expected %v, got %v -- %v"", id, path, u.Path, getRouteTemplate(route))
+				return
+			}
+		}
+		if url != """" {
+			u, _ := route.URL(mapToPairs(match.Vars)...)
+			if url != u.Host+u.Path {
+				t.Errorf(""(%v) URL not equal: expected %v, got %v -- %v"", id, url, u.Host+u.Path, getRouteTemplate(route))
+				return
+			}
+		}
+	}
+}
+
+func TestStrictSlash(t *testing.T) {
+	var r *Router
+	var req *http.Request
+	var route *Route
+	var match *RouteMatch
+	var matched bool
+
+	// StrictSlash should be ignored for path prefix.
+	// So we register a route ending in slash but it doesn't attempt to add
+	// the slash for a path not ending in slash.
+	r = NewRouter()
+	r.StrictSlash(true)
+	route = r.NewRoute().PathPrefix(""/static/"")
+	req, _ = http.NewRequest(""GET"", ""http://localhost/static/logo.png"", nil)
+	match = new(RouteMatch)
+	matched = r.Match(req, match)
+	if !matched {
+		t.Errorf(""Should match request %q -- %v"", req.URL.Path, getRouteTemplate(route))
+	}
+	if match.Handler != nil {
+		t.Errorf(""Should not redirect"")
+	}
+}
+
+func mapToPairs(m map[string]string) []string {
+	var i int
+	p := make([]string, len(m)*2)
+	for k, v := range m {
+		p[i] = k
+		p[i+1] = v
+		i += 2
+	}
+	return p
+}
+
+func stringMapEqual(m1, m2 map[string]string) bool {
+	nil1 := m1 == nil
+	nil2 := m2 == nil
+	if nil1 != nil2 || len(m1) != len(m2) {
+		return false
+	}
+	for k, v := range m1 {
+		if v != m2[k] {
+			return false
+		}
+	}
+	return true
+}",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,https://github.com/gorilla/mux/blob/eac83ba2c004bb759a2875b1f1dbb032adf8bb4a/mux_test.go
eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,7e266bb6954e641f75f1ad5e73f3e7c8dcec9f9d,old_test.go,,"Wed, 03 Oct 2012 04:48:17 GMT",added,758,0,758,"@@ -0,0 +1,758 @@
+// Old tests ported to Go1. This is a mess. Want to drop it one day.
+
+// Copyright 2011 Gorilla Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mux
+
+import (
+	""bytes""
+	""net/http""
+	""testing""
+)
+
+// ----------------------------------------------------------------------------
+// ResponseRecorder
+// ----------------------------------------------------------------------------
+// Copyright 2009 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// ResponseRecorder is an implementation of http.ResponseWriter that
+// records its mutations for later inspection in tests.
+type ResponseRecorder struct {
+	Code      int           // the HTTP response code from WriteHeader
+	HeaderMap http.Header   // the HTTP response headers
+	Body      *bytes.Buffer // if non-nil, the bytes.Buffer to append written data to
+	Flushed   bool
+}
+
+// NewRecorder returns an initialized ResponseRecorder.
+func NewRecorder() *ResponseRecorder {
+	return &ResponseRecorder{
+		HeaderMap: make(http.Header),
+		Body:      new(bytes.Buffer),
+	}
+}
+
+// DefaultRemoteAddr is the default remote address to return in RemoteAddr if
+// an explicit DefaultRemoteAddr isn't set on ResponseRecorder.
+const DefaultRemoteAddr = ""1.2.3.4""
+
+// Header returns the response headers.
+func (rw *ResponseRecorder) Header() http.Header {
+	return rw.HeaderMap
+}
+
+// Write always succeeds and writes to rw.Body, if not nil.
+func (rw *ResponseRecorder) Write(buf []byte) (int, error) {
+	if rw.Body != nil {
+		rw.Body.Write(buf)
+	}
+	if rw.Code == 0 {
+		rw.Code = http.StatusOK
+	}
+	return len(buf), nil
+}
+
+// WriteHeader sets rw.Code.
+func (rw *ResponseRecorder) WriteHeader(code int) {
+	rw.Code = code
+}
+
+// Flush sets rw.Flushed to true.
+func (rw *ResponseRecorder) Flush() {
+	rw.Flushed = true
+}
+
+// ----------------------------------------------------------------------------
+
+func TestRouteMatchers(t *testing.T) {
+	var scheme, host, path, query, method string
+	var headers map[string]string
+	var resultVars map[bool]map[string]string
+
+	router := NewRouter()
+	router.NewRoute().Host(""{var1}.google.com"").
+		Path(""/{var2:[a-z]+}/{var3:[0-9]+}"").
+		Queries(""foo"", ""bar"").
+		Methods(""GET"").
+		Schemes(""https"").
+		Headers(""x-requested-with"", ""XMLHttpRequest"")
+	router.NewRoute().Host(""www.{var4}.com"").
+		PathPrefix(""/foo/{var5:[a-z]+}/{var6:[0-9]+}"").
+		Queries(""baz"", ""ding"").
+		Methods(""POST"").
+		Schemes(""http"").
+		Headers(""Content-Type"", ""application/json"")
+
+	reset := func() {
+		// Everything match.
+		scheme = ""https""
+		host = ""www.google.com""
+		path = ""/product/42""
+		query = ""?foo=bar""
+		method = ""GET""
+		headers = map[string]string{""X-Requested-With"": ""XMLHttpRequest""}
+		resultVars = map[bool]map[string]string{
+			true:  map[string]string{""var1"": ""www"", ""var2"": ""product"", ""var3"": ""42""},
+			false: map[string]string{},
+		}
+	}
+
+	reset2 := func() {
+		// Everything match.
+		scheme = ""http""
+		host = ""www.google.com""
+		path = ""/foo/product/42/path/that/is/ignored""
+		query = ""?baz=ding""
+		method = ""POST""
+		headers = map[string]string{""Content-Type"": ""application/json""}
+		resultVars = map[bool]map[string]string{
+			true:  map[string]string{""var4"": ""google"", ""var5"": ""product"", ""var6"": ""42""},
+			false: map[string]string{},
+		}
+	}
+
+	match := func(shouldMatch bool) {
+		url := scheme + ""://"" + host + path + query
+		request, _ := http.NewRequest(method, url, nil)
+		for key, value := range headers {
+			request.Header.Add(key, value)
+		}
+
+		var routeMatch RouteMatch
+		matched := router.Match(request, &routeMatch)
+		if matched != shouldMatch {
+			// Need better messages. :)
+			if matched {
+				t.Errorf(""Should match."")
+			} else {
+				t.Errorf(""Should not match."")
+			}
+		}
+
+		if matched {
+			currentRoute := routeMatch.Route
+			if currentRoute == nil {
+				t.Errorf(""Expected a current route."")
+			}
+			vars := routeMatch.Vars
+			expectedVars := resultVars[shouldMatch]
+			if len(vars) != len(expectedVars) {
+				t.Errorf(""Expected vars: %v Got: %v."", expectedVars, vars)
+			}
+			for name, value := range vars {
+				if expectedVars[name] != value {
+					t.Errorf(""Expected vars: %v Got: %v."", expectedVars, vars)
+				}
+			}
+		}
+	}
+
+	// 1st route --------------------------------------------------------------
+
+	// Everything match.
+	reset()
+	match(true)
+
+	// Scheme doesn't match.
+	reset()
+	scheme = ""http""
+	match(false)
+
+	// Host doesn't match.
+	reset()
+	host = ""www.mygoogle.com""
+	match(false)
+
+	// Path doesn't match.
+	reset()
+	path = ""/product/notdigits""
+	match(false)
+
+	// Query doesn't match.
+	reset()
+	query = ""?foo=baz""
+	match(false)
+
+	// Method doesn't match.
+	reset()
+	method = ""POST""
+	match(false)
+
+	// Header doesn't match.
+	reset()
+	headers = map[string]string{}
+	match(false)
+
+	// Everything match, again.
+	reset()
+	match(true)
+
+	// 2nd route --------------------------------------------------------------
+
+	// Everything match.
+	reset2()
+	match(true)
+
+	// Scheme doesn't match.
+	reset2()
+	scheme = ""https""
+	match(false)
+
+	// Host doesn't match.
+	reset2()
+	host = ""sub.google.com""
+	match(false)
+
+	// Path doesn't match.
+	reset2()
+	path = ""/bar/product/42""
+	match(false)
+
+	// Query doesn't match.
+	reset2()
+	query = ""?foo=baz""
+	match(false)
+
+	// Method doesn't match.
+	reset2()
+	method = ""GET""
+	match(false)
+
+	// Header doesn't match.
+	reset2()
+	headers = map[string]string{}
+	match(false)
+
+	// Everything match, again.
+	reset2()
+	match(true)
+}
+
+type headerMatcherTest struct {
+	matcher headerMatcher
+	headers map[string]string
+	result  bool
+}
+
+var headerMatcherTests = []headerMatcherTest{
+	{
+		matcher: headerMatcher(map[string]string{""x-requested-with"": ""XMLHttpRequest""}),
+		headers: map[string]string{""X-Requested-With"": ""XMLHttpRequest""},
+		result:  true,
+	},
+	{
+		matcher: headerMatcher(map[string]string{""x-requested-with"": """"}),
+		headers: map[string]string{""X-Requested-With"": ""anything""},
+		result:  true,
+	},
+	{
+		matcher: headerMatcher(map[string]string{""x-requested-with"": ""XMLHttpRequest""}),
+		headers: map[string]string{},
+		result:  false,
+	},
+}
+
+type hostMatcherTest struct {
+	matcher *Route
+	url     string
+	vars    map[string]string
+	result  bool
+}
+
+var hostMatcherTests = []hostMatcherTest{
+	{
+		matcher: NewRouter().NewRoute().Host(""{foo:[a-z][a-z][a-z]}.{bar:[a-z][a-z][a-z]}.{baz:[a-z][a-z][a-z]}""),
+		url:     ""http://abc.def.ghi/"",
+		vars:    map[string]string{""foo"": ""abc"", ""bar"": ""def"", ""baz"": ""ghi""},
+		result:  true,
+	},
+	{
+		matcher: NewRouter().NewRoute().Host(""{foo:[a-z][a-z][a-z]}.{bar:[a-z][a-z][a-z]}.{baz:[a-z][a-z][a-z]}""),
+		url:     ""http://a.b.c/"",
+		vars:    map[string]string{""foo"": ""abc"", ""bar"": ""def"", ""baz"": ""ghi""},
+		result:  false,
+	},
+}
+
+type methodMatcherTest struct {
+	matcher methodMatcher
+	method  string
+	result  bool
+}
+
+var methodMatcherTests = []methodMatcherTest{
+	{
+		matcher: methodMatcher([]string{""GET"", ""POST"", ""PUT""}),
+		method:  ""GET"",
+		result:  true,
+	},
+	{
+		matcher: methodMatcher([]string{""GET"", ""POST"", ""PUT""}),
+		method:  ""POST"",
+		result:  true,
+	},
+	{
+		matcher: methodMatcher([]string{""GET"", ""POST"", ""PUT""}),
+		method:  ""PUT"",
+		result:  true,
+	},
+	{
+		matcher: methodMatcher([]string{""GET"", ""POST"", ""PUT""}),
+		method:  ""DELETE"",
+		result:  false,
+	},
+}
+
+type pathMatcherTest struct {
+	matcher *Route
+	url     string
+	vars    map[string]string
+	result  bool
+}
+
+var pathMatcherTests = []pathMatcherTest{
+	{
+		matcher: NewRouter().NewRoute().Path(""/{foo:[0-9][0-9][0-9]}/{bar:[0-9][0-9][0-9]}/{baz:[0-9][0-9][0-9]}""),
+		url:     ""http://localhost:8080/123/456/789"",
+		vars:    map[string]string{""foo"": ""123"", ""bar"": ""456"", ""baz"": ""789""},
+		result:  true,
+	},
+	{
+		matcher: NewRouter().NewRoute().Path(""/{foo:[0-9][0-9][0-9]}/{bar:[0-9][0-9][0-9]}/{baz:[0-9][0-9][0-9]}""),
+		url:     ""http://localhost:8080/1/2/3"",
+		vars:    map[string]string{""foo"": ""123"", ""bar"": ""456"", ""baz"": ""789""},
+		result:  false,
+	},
+}
+
+type queryMatcherTest struct {
+	matcher queryMatcher
+	url     string
+	result  bool
+}
+
+var queryMatcherTests = []queryMatcherTest{
+	{
+		matcher: queryMatcher(map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
+		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
+		result:  true,
+	},
+	{
+		matcher: queryMatcher(map[string]string{""foo"": """", ""baz"": """"}),
+		url:     ""http://localhost:8080/?foo=anything&baz=anything"",
+		result:  true,
+	},
+	{
+		matcher: queryMatcher(map[string]string{""foo"": ""ding"", ""baz"": ""bar""}),
+		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
+		result:  false,
+	},
+	{
+		matcher: queryMatcher(map[string]string{""bar"": ""foo"", ""ding"": ""baz""}),
+		url:     ""http://localhost:8080/?foo=bar&baz=ding"",
+		result:  false,
+	},
+}
+
+type schemeMatcherTest struct {
+	matcher schemeMatcher
+	url     string
+	result  bool
+}
+
+var schemeMatcherTests = []schemeMatcherTest{
+	{
+		matcher: schemeMatcher([]string{""http"", ""https""}),
+		url:     ""http://localhost:8080/"",
+		result:  true,
+	},
+	{
+		matcher: schemeMatcher([]string{""http"", ""https""}),
+		url:     ""https://localhost:8080/"",
+		result:  true,
+	},
+	{
+		matcher: schemeMatcher([]string{""https""}),
+		url:     ""http://localhost:8080/"",
+		result:  false,
+	},
+	{
+		matcher: schemeMatcher([]string{""http""}),
+		url:     ""https://localhost:8080/"",
+		result:  false,
+	},
+}
+
+type urlBuildingTest struct {
+	route *Route
+	vars  []string
+	url   string
+}
+
+var urlBuildingTests = []urlBuildingTest{
+	{
+		route: new(Route).Host(""foo.domain.com""),
+		vars:  []string{},
+		url:   ""http://foo.domain.com"",
+	},
+	{
+		route: new(Route).Host(""{subdomain}.domain.com""),
+		vars:  []string{""subdomain"", ""bar""},
+		url:   ""http://bar.domain.com"",
+	},
+	{
+		route: new(Route).Host(""foo.domain.com"").Path(""/articles""),
+		vars:  []string{},
+		url:   ""http://foo.domain.com/articles"",
+	},
+	{
+		route: new(Route).Path(""/articles""),
+		vars:  []string{},
+		url:   ""/articles"",
+	},
+	{
+		route: new(Route).Path(""/articles/{category}/{id:[0-9]+}""),
+		vars:  []string{""category"", ""technology"", ""id"", ""42""},
+		url:   ""/articles/technology/42"",
+	},
+	{
+		route: new(Route).Host(""{subdomain}.domain.com"").Path(""/articles/{category}/{id:[0-9]+}""),
+		vars:  []string{""subdomain"", ""foo"", ""category"", ""technology"", ""id"", ""42""},
+		url:   ""http://foo.domain.com/articles/technology/42"",
+	},
+}
+
+func TestHeaderMatcher(t *testing.T) {
+	for _, v := range headerMatcherTests {
+		request, _ := http.NewRequest(""GET"", ""http://localhost:8080/"", nil)
+		for key, value := range v.headers {
+			request.Header.Add(key, value)
+		}
+		var routeMatch RouteMatch
+		result := v.matcher.Match(request, &routeMatch)
+		if result != v.result {
+			if v.result {
+				t.Errorf(""%#v: should match %v."", v.matcher, request.Header)
+			} else {
+				t.Errorf(""%#v: should not match %v."", v.matcher, request.Header)
+			}
+		}
+	}
+}
+
+func TestHostMatcher(t *testing.T) {
+	for _, v := range hostMatcherTests {
+		request, _ := http.NewRequest(""GET"", v.url, nil)
+		var routeMatch RouteMatch
+		result := v.matcher.Match(request, &routeMatch)
+		vars := routeMatch.Vars
+		if result != v.result {
+			if v.result {
+				t.Errorf(""%#v: should match %v."", v.matcher, v.url)
+			} else {
+				t.Errorf(""%#v: should not match %v."", v.matcher, v.url)
+			}
+		}
+		if result {
+			if len(vars) != len(v.vars) {
+				t.Errorf(""%#v: vars length should be %v, got %v."", v.matcher, len(v.vars), len(vars))
+			}
+			for name, value := range vars {
+				if v.vars[name] != value {
+					t.Errorf(""%#v: expected value %v for key %v, got %v."", v.matcher, v.vars[name], name, value)
+				}
+			}
+		} else {
+			if len(vars) != 0 {
+				t.Errorf(""%#v: vars length should be 0, got %v."", v.matcher, len(vars))
+			}
+		}
+	}
+}
+
+func TestMethodMatcher(t *testing.T) {
+	for _, v := range methodMatcherTests {
+		request, _ := http.NewRequest(v.method, ""http://localhost:8080/"", nil)
+		var routeMatch RouteMatch
+		result := v.matcher.Match(request, &routeMatch)
+		if result != v.result {
+			if v.result {
+				t.Errorf(""%#v: should match %v."", v.matcher, v.method)
+			} else {
+				t.Errorf(""%#v: should not match %v."", v.matcher, v.method)
+			}
+		}
+	}
+}
+
+func TestPathMatcher(t *testing.T) {
+	for _, v := range pathMatcherTests {
+		request, _ := http.NewRequest(""GET"", v.url, nil)
+		var routeMatch RouteMatch
+		result := v.matcher.Match(request, &routeMatch)
+		vars := routeMatch.Vars
+		if result != v.result {
+			if v.result {
+				t.Errorf(""%#v: should match %v."", v.matcher, v.url)
+			} else {
+				t.Errorf(""%#v: should not match %v."", v.matcher, v.url)
+			}
+		}
+		if result {
+			if len(vars) != len(v.vars) {
+				t.Errorf(""%#v: vars length should be %v, got %v."", v.matcher, len(v.vars), len(vars))
+			}
+			for name, value := range vars {
+				if v.vars[name] != value {
+					t.Errorf(""%#v: expected value %v for key %v, got %v."", v.matcher, v.vars[name], name, value)
+				}
+			}
+		} else {
+			if len(vars) != 0 {
+				t.Errorf(""%#v: vars length should be 0, got %v."", v.matcher, len(vars))
+			}
+		}
+	}
+}
+
+func TestQueryMatcher(t *testing.T) {
+	for _, v := range queryMatcherTests {
+		request, _ := http.NewRequest(""GET"", v.url, nil)
+		var routeMatch RouteMatch
+		result := v.matcher.Match(request, &routeMatch)
+		if result != v.result {
+			if v.result {
+				t.Errorf(""%#v: should match %v."", v.matcher, v.url)
+			} else {
+				t.Errorf(""%#v: should not match %v."", v.matcher, v.url)
+			}
+		}
+	}
+}
+
+func TestSchemeMatcher(t *testing.T) {
+	for _, v := range queryMatcherTests {
+		request, _ := http.NewRequest(""GET"", v.url, nil)
+		var routeMatch RouteMatch
+		result := v.matcher.Match(request, &routeMatch)
+		if result != v.result {
+			if v.result {
+				t.Errorf(""%#v: should match %v."", v.matcher, v.url)
+			} else {
+				t.Errorf(""%#v: should not match %v."", v.matcher, v.url)
+			}
+		}
+	}
+}
+
+func TestUrlBuilding(t *testing.T) {
+
+	for _, v := range urlBuildingTests {
+		u, _ := v.route.URL(v.vars...)
+		url := u.String()
+		if url != v.url {
+			t.Errorf(""expected %v, got %v"", v.url, url)
+			/*
+				reversePath := """"
+				reverseHost := """"
+				if v.route.pathTemplate != nil {
+						reversePath = v.route.pathTemplate.Reverse
+				}
+				if v.route.hostTemplate != nil {
+						reverseHost = v.route.hostTemplate.Reverse
+				}
+
+				t.Errorf(""%#v:\nexpected: %q\ngot: %q\nreverse path: %q\nreverse host: %q"", v.route, v.url, url, reversePath, reverseHost)
+			*/
+		}
+	}
+
+	ArticleHandler := func(w http.ResponseWriter, r *http.Request) {
+	}
+
+	router := NewRouter()
+	router.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).Name(""article"")
+
+	url, _ := router.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+	expected := ""/articles/technology/42""
+	if url.String() != expected {
+		t.Errorf(""Expected %v, got %v"", expected, url.String())
+	}
+}
+
+func TestMatchedRouteName(t *testing.T) {
+	routeName := ""stock""
+	router := NewRouter()
+	route := router.NewRoute().Path(""/products/"").Name(routeName)
+
+	url := ""http://www.domain.com/products/""
+	request, _ := http.NewRequest(""GET"", url, nil)
+	var rv RouteMatch
+	ok := router.Match(request, &rv)
+
+	if !ok || rv.Route != route {
+		t.Errorf(""Expected same route, got %+v."", rv.Route)
+	}
+
+	retName := rv.Route.GetName()
+	if retName != routeName {
+		t.Errorf(""Expected %q, got %q."", routeName, retName)
+	}
+}
+
+func TestSubRouting(t *testing.T) {
+	// Example from docs.
+	router := NewRouter()
+	subrouter := router.NewRoute().Host(""www.domain.com"").Subrouter()
+	route := subrouter.NewRoute().Path(""/products/"").Name(""products"")
+
+	url := ""http://www.domain.com/products/""
+	request, _ := http.NewRequest(""GET"", url, nil)
+	var rv RouteMatch
+	ok := router.Match(request, &rv)
+
+	if !ok || rv.Route != route {
+		t.Errorf(""Expected same route, got %+v."", rv.Route)
+	}
+
+	u, _ := router.Get(""products"").URL()
+	builtUrl := u.String()
+	// Yay, subroute aware of the domain when building!
+	if builtUrl != url {
+		t.Errorf(""Expected %q, got %q."", url, builtUrl)
+	}
+}
+
+func TestVariableNames(t *testing.T) {
+	route := new(Route).Host(""{arg1}.domain.com"").Path(""/{arg1}/{arg2:[0-9]+}"")
+	if route.err == nil {
+		t.Errorf(""Expected error for duplicated variable names"")
+	}
+}
+
+func TestRedirectSlash(t *testing.T) {
+	var route *Route
+	var routeMatch RouteMatch
+	r := NewRouter()
+
+	r.StrictSlash(false)
+	route = r.NewRoute()
+	if route.strictSlash != false {
+		t.Errorf(""Expected false redirectSlash."")
+	}
+
+	r.StrictSlash(true)
+	route = r.NewRoute()
+	if route.strictSlash != true {
+		t.Errorf(""Expected true redirectSlash."")
+	}
+
+	route = new(Route)
+	route.strictSlash = true
+	route.Path(""/{arg1}/{arg2:[0-9]+}/"")
+	request, _ := http.NewRequest(""GET"", ""http://localhost/foo/123"", nil)
+	routeMatch = RouteMatch{}
+	_ = route.Match(request, &routeMatch)
+	vars := routeMatch.Vars
+	if vars[""arg1""] != ""foo"" {
+		t.Errorf(""Expected foo."")
+	}
+	if vars[""arg2""] != ""123"" {
+		t.Errorf(""Expected 123."")
+	}
+	rsp := NewRecorder()
+	routeMatch.Handler.ServeHTTP(rsp, request)
+	if rsp.HeaderMap.Get(""Location"") != ""http://localhost/foo/123/"" {
+		t.Errorf(""Expected redirect header."")
+	}
+
+	route = new(Route)
+	route.strictSlash = true
+	route.Path(""/{arg1}/{arg2:[0-9]+}"")
+	request, _ = http.NewRequest(""GET"", ""http://localhost/foo/123/"", nil)
+	routeMatch = RouteMatch{}
+	_ = route.Match(request, &routeMatch)
+	vars = routeMatch.Vars
+	if vars[""arg1""] != ""foo"" {
+		t.Errorf(""Expected foo."")
+	}
+	if vars[""arg2""] != ""123"" {
+		t.Errorf(""Expected 123."")
+	}
+	rsp = NewRecorder()
+	routeMatch.Handler.ServeHTTP(rsp, request)
+	if rsp.HeaderMap.Get(""Location"") != ""http://localhost/foo/123"" {
+		t.Errorf(""Expected redirect header."")
+	}
+}
+
+// Test for the new regexp library, still not available in stable Go.
+func TestNewRegexp(t *testing.T) {
+	var p *routeRegexp
+	var matches []string
+
+	tests := map[string]map[string][]string{
+		""/{foo:a{2}}"": {
+			""/a"":    nil,
+			""/aa"":   {""aa""},
+			""/aaa"":  nil,
+			""/aaaa"": nil,
+		},
+		""/{foo:a{2,}}"": {
+			""/a"":    nil,
+			""/aa"":   {""aa""},
+			""/aaa"":  {""aaa""},
+			""/aaaa"": {""aaaa""},
+		},
+		""/{foo:a{2,3}}"": {
+			""/a"":    nil,
+			""/aa"":   {""aa""},
+			""/aaa"":  {""aaa""},
+			""/aaaa"": nil,
+		},
+		""/{foo:[a-z]{3}}/{bar:[a-z]{2}}"": {
+			""/a"":       nil,
+			""/ab"":      nil,
+			""/abc"":     nil,
+			""/abcd"":    nil,
+			""/abc/ab"":  {""abc"", ""ab""},
+			""/abc/abc"": nil,
+			""/abcd/ab"": nil,
+		},
+		`/{foo:\w{3,}}/{bar:\d{2,}}`: {
+			""/a"":        nil,
+			""/ab"":       nil,
+			""/abc"":      nil,
+			""/abc/1"":    nil,
+			""/abc/12"":   {""abc"", ""12""},
+			""/abcd/12"":  {""abcd"", ""12""},
+			""/abcd/123"": {""abcd"", ""123""},
+		},
+	}
+
+	for pattern, paths := range tests {
+		p, _ = newRouteRegexp(pattern, false, false, false)
+		for path, result := range paths {
+			matches = p.regexp.FindStringSubmatch(path)
+			if result == nil {
+				if matches != nil {
+					t.Errorf(""%v should not match %v."", pattern, path)
+				}
+			} else {
+				if len(matches) != len(result)+1 {
+					t.Errorf(""Expected %v matches, got %v."", len(result)+1, len(matches))
+				} else {
+					for k, v := range result {
+						if matches[k+1] != v {
+							t.Errorf(""Expected %v, got %v."", v, matches[k+1])
+						}
+					}
+				}
+			}
+		}
+	}
+}",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,https://github.com/gorilla/mux/blob/eac83ba2c004bb759a2875b1f1dbb032adf8bb4a/old_test.go
eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,4c3482bfbdd9701ae377aae1716c24ac1fd30b54,regexp.go,,"Wed, 03 Oct 2012 04:48:17 GMT",added,247,0,247,"@@ -0,0 +1,247 @@
+// Copyright 2012 The Gorilla Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mux
+
+import (
+	""bytes""
+	""fmt""
+	""net/http""
+	""net/url""
+	""regexp""
+	""strings""
+)
+
+// newRouteRegexp parses a route template and returns a routeRegexp,
+// used to match a host or path.
+//
+// It will extract named variables, assemble a regexp to be matched, create
+// a ""reverse"" template to build URLs and compile regexps to validate variable
+// values used in URL building.
+//
+// Previously we accepted only Python-like identifiers for variable
+// names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that
+// name and pattern can't be empty, and names can't contain a colon.
+func newRouteRegexp(tpl string, matchHost, matchPrefix, strictSlash bool) (*routeRegexp, error) {
+	// Check if it is well-formed.
+	idxs, errBraces := braceIndices(tpl)
+	if errBraces != nil {
+		return nil, errBraces
+	}
+	// Backup the original.
+	template := tpl
+	// Now let's parse it.
+	defaultPattern := ""[^/]+""
+	if matchHost {
+		defaultPattern = ""[^.]+""
+		matchPrefix, strictSlash = false, false
+	}
+	if matchPrefix {
+		strictSlash = false
+	}
+	// Set a flag for strictSlash.
+	endSlash := false
+	if strictSlash && strings.HasSuffix(tpl, ""/"") {
+		tpl = tpl[:len(tpl)-1]
+		endSlash = true
+	}
+	varsN := make([]string, len(idxs)/2)
+	varsR := make([]*regexp.Regexp, len(idxs)/2)
+	pattern := bytes.NewBufferString(""^"")
+	reverse := bytes.NewBufferString("""")
+	var end int
+	var err error
+	for i := 0; i < len(idxs); i += 2 {
+		// Set all values we are interested in.
+		raw := tpl[end:idxs[i]]
+		end = idxs[i+1]
+		parts := strings.SplitN(tpl[idxs[i]+1:end-1], "":"", 2)
+		name := parts[0]
+		patt := defaultPattern
+		if len(parts) == 2 {
+			patt = parts[1]
+		}
+		// Name or pattern can't be empty.
+		if name == """" || patt == """" {
+			return nil, fmt.Errorf(""mux: missing name or pattern in %q"",
+				tpl[idxs[i]:end])
+		}
+		// Build the regexp pattern.
+		fmt.Fprintf(pattern, ""%s(%s)"", regexp.QuoteMeta(raw), patt)
+		// Build the reverse template.
+		fmt.Fprintf(reverse, ""%s%%s"", raw)
+		// Append variable name and compiled pattern.
+		varsN[i/2] = name
+		varsR[i/2], err = regexp.Compile(fmt.Sprintf(""^%s$"", patt))
+		if err != nil {
+			return nil, err
+		}
+	}
+	// Add the remaining.
+	raw := tpl[end:]
+	pattern.WriteString(regexp.QuoteMeta(raw))
+	if strictSlash {
+		pattern.WriteString(""[/]?"")
+	}
+	if !matchPrefix {
+		pattern.WriteByte('$')
+	}
+	reverse.WriteString(raw)
+	if endSlash {
+		reverse.WriteByte('/')
+	}
+	// Compile full regexp.
+	reg, errCompile := regexp.Compile(pattern.String())
+	if errCompile != nil {
+		return nil, errCompile
+	}
+	// Done!
+	return &routeRegexp{
+		template:  template,
+		matchHost: matchHost,
+		regexp:    reg,
+		reverse:   reverse.String(),
+		varsN:     varsN,
+		varsR:     varsR,
+	}, nil
+}
+
+// routeRegexp stores a regexp to match a host or path and information to
+// collect and validate route variables.
+type routeRegexp struct {
+	// The unmodified template.
+	template string
+	// True for host match, false for path match.
+	matchHost bool
+	// Expanded regexp.
+	regexp *regexp.Regexp
+	// Reverse template.
+	reverse string
+	// Variable names.
+	varsN []string
+	// Variable regexps (validators).
+	varsR []*regexp.Regexp
+}
+
+// Match matches the regexp against the URL host or path.
+func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
+	if !r.matchHost {
+		return r.regexp.MatchString(req.URL.Path)
+	}
+	return r.regexp.MatchString(getHost(req))
+}
+
+// url builds a URL part using the given values.
+func (r *routeRegexp) url(pairs ...string) (string, error) {
+	values, err := mapFromPairs(pairs...)
+	if err != nil {
+		return """", err
+	}
+	urlValues := make([]interface{}, len(r.varsN))
+	for k, v := range r.varsN {
+		value, ok := values[v]
+		if !ok {
+			return """", fmt.Errorf(""mux: missing route variable %q"", v)
+		}
+		urlValues[k] = value
+	}
+	rv := fmt.Sprintf(r.reverse, urlValues...)
+	if !r.regexp.MatchString(rv) {
+		// The URL is checked against the full regexp, instead of checking
+		// individual variables. This is faster but to provide a good error
+		// message, we check individual regexps if the URL doesn't match.
+		for k, v := range r.varsN {
+			if !r.varsR[k].MatchString(values[v]) {
+				return """", fmt.Errorf(
+					""mux: variable %q doesn't match, expected %q"", values[v],
+					r.varsR[k].String())
+			}
+		}
+	}
+	return rv, nil
+}
+
+// braceIndices returns the first level curly brace indices from a string.
+// It returns an error in case of unbalanced braces.
+func braceIndices(s string) ([]int, error) {
+	var level, idx int
+	idxs := make([]int, 0)
+	for i := 0; i < len(s); i++ {
+		switch s[i] {
+		case '{':
+			if level++; level == 1 {
+				idx = i
+			}
+		case '}':
+			if level--; level == 0 {
+				idxs = append(idxs, idx, i+1)
+			} else if level < 0 {
+				return nil, fmt.Errorf(""mux: unbalanced braces in %q"", s)
+			}
+		}
+	}
+	if level != 0 {
+		return nil, fmt.Errorf(""mux: unbalanced braces in %q"", s)
+	}
+	return idxs, nil
+}
+
+// ----------------------------------------------------------------------------
+// routeRegexpGroup
+// ----------------------------------------------------------------------------
+
+// routeRegexpGroup groups the route matchers that carry variables.
+type routeRegexpGroup struct {
+	host *routeRegexp
+	path *routeRegexp
+}
+
+// setMatch extracts the variables from the URL once a route matches.
+func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
+	// Store host variables.
+	if v.host != nil {
+		hostVars := v.host.regexp.FindStringSubmatch(getHost(req))
+		if hostVars != nil {
+			for k, v := range v.host.varsN {
+				m.Vars[v] = hostVars[k+1]
+			}
+		}
+	}
+	// Store path variables.
+	if v.path != nil {
+		pathVars := v.path.regexp.FindStringSubmatch(req.URL.Path)
+		if pathVars != nil {
+			for k, v := range v.path.varsN {
+				m.Vars[v] = pathVars[k+1]
+			}
+			// Check if we should redirect.
+			if r.strictSlash {
+				p1 := strings.HasSuffix(req.URL.Path, ""/"")
+				p2 := strings.HasSuffix(v.path.template, ""/"")
+				if p1 != p2 {
+					u, _ := url.Parse(req.URL.String())
+					if p1 {
+						u.Path = u.Path[:len(u.Path)-1]
+					} else {
+						u.Path += ""/""
+					}
+					m.Handler = http.RedirectHandler(u.String(), 301)
+				}
+			}
+		}
+	}
+}
+
+// getHost tries its best to return the request host.
+func getHost(r *http.Request) string {
+	if !r.URL.IsAbs() {
+		host := r.Host
+		// Slice off any port information.
+		if i := strings.Index(host, "":""); i != -1 {
+			host = host[:i]
+		}
+		return host
+	}
+	return r.URL.Host
+}",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,https://github.com/gorilla/mux/blob/eac83ba2c004bb759a2875b1f1dbb032adf8bb4a/regexp.go
eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,cb538ea4ec2744b0b8efd75010d5a92dd40d1fea,route.go,,"Wed, 03 Oct 2012 04:48:17 GMT",added,499,0,499,"@@ -0,0 +1,499 @@
+// Copyright 2012 The Gorilla Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mux
+
+import (
+	""errors""
+	""fmt""
+	""net/http""
+	""net/url""
+	""strings""
+)
+
+// Route stores information to match a request and build URLs.
+type Route struct {
+	// Parent where the route was registered (a Router).
+	parent parentRoute
+	// Request handler for the route.
+	handler http.Handler
+	// List of matchers.
+	matchers []matcher
+	// Manager for the variables from host and path.
+	regexp *routeRegexpGroup
+	// If true, when the path pattern is ""/path/"", accessing ""/path"" will
+	// redirect to the former and vice versa.
+	strictSlash bool
+	// If true, this route never matches: it is only used to build URLs.
+	buildOnly bool
+	// The name used to build URLs.
+	name string
+	// Error resulted from building a route.
+	err error
+}
+
+// Match matches the route against the request.
+func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
+	if r.buildOnly || r.err != nil {
+		return false
+	}
+	// Match everything.
+	for _, m := range r.matchers {
+		if matched := m.Match(req, match); !matched {
+			return false
+		}
+	}
+	// Yay, we have a match. Let's collect some info about it.
+	if match.Route == nil {
+		match.Route = r
+	}
+	if match.Handler == nil {
+		match.Handler = r.handler
+	}
+	if match.Vars == nil {
+		match.Vars = make(map[string]string)
+	}
+	// Set variables.
+	if r.regexp != nil {
+		r.regexp.setMatch(req, match, r)
+	}
+	return true
+}
+
+// ----------------------------------------------------------------------------
+// Route attributes
+// ----------------------------------------------------------------------------
+
+// GetError returns an error resulted from building the route, if any.
+func (r *Route) GetError() error {
+	return r.err
+}
+
+// BuildOnly sets the route to never match: it is only used to build URLs.
+func (r *Route) BuildOnly() *Route {
+	r.buildOnly = true
+	return r
+}
+
+// Handler --------------------------------------------------------------------
+
+// Handler sets a handler for the route.
+func (r *Route) Handler(handler http.Handler) *Route {
+	if r.err == nil {
+		r.handler = handler
+	}
+	return r
+}
+
+// HandlerFunc sets a handler function for the route.
+func (r *Route) HandlerFunc(f func(http.ResponseWriter, *http.Request)) *Route {
+	return r.Handler(http.HandlerFunc(f))
+}
+
+// GetHandler returns the handler for the route, if any.
+func (r *Route) GetHandler() http.Handler {
+	return r.handler
+}
+
+// Name -----------------------------------------------------------------------
+
+// Name sets the name for the route, used to build URLs.
+// If the name was registered already it will be overwritten.
+func (r *Route) Name(name string) *Route {
+	if r.name != """" {
+		r.err = fmt.Errorf(""mux: route already has name %q, can't set %q"",
+			r.name, name)
+	}
+	if r.err == nil {
+		r.name = name
+		r.getNamedRoutes()[name] = r
+	}
+	return r
+}
+
+// GetName returns the name for the route, if any.
+func (r *Route) GetName() string {
+	return r.name
+}
+
+// ----------------------------------------------------------------------------
+// Matchers
+// ----------------------------------------------------------------------------
+
+// matcher types try to match a request.
+type matcher interface {
+	Match(*http.Request, *RouteMatch) bool
+}
+
+// addMatcher adds a matcher to the route.
+func (r *Route) addMatcher(m matcher) *Route {
+	if r.err == nil {
+		r.matchers = append(r.matchers, m)
+	}
+	return r
+}
+
+// addRegexpMatcher adds a host or path matcher and builder to a route.
+func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix bool) error {
+	if r.err != nil {
+		return r.err
+	}
+	r.regexp = r.getRegexpGroup()
+	if !matchHost {
+		if len(tpl) == 0 || tpl[0] != '/' {
+			return fmt.Errorf(""mux: path must start with a slash, got %q"", tpl)
+		}
+		if r.regexp.path != nil {
+			tpl = strings.TrimRight(r.regexp.path.template, ""/"") + tpl
+		}
+	}
+	rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, r.strictSlash)
+	if err != nil {
+		return err
+	}
+	if matchHost {
+		if r.regexp.path != nil {
+			if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
+				return err
+			}
+		}
+		r.regexp.host = rr
+	} else {
+		if r.regexp.host != nil {
+			if err = uniqueVars(rr.varsN, r.regexp.host.varsN); err != nil {
+				return err
+			}
+		}
+		r.regexp.path = rr
+	}
+	r.addMatcher(rr)
+	return nil
+}
+
+// Headers --------------------------------------------------------------------
+
+// headerMatcher matches the request against header values.
+type headerMatcher map[string]string
+
+func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
+	return matchMap(m, r.Header, true)
+}
+
+// Headers adds a matcher for request header values.
+// It accepts a sequence of key/value pairs to be matched. For example:
+//
+//     r := mux.NewRouter()
+//     r.Headers(""Content-Type"", ""application/json"",
+//               ""X-Requested-With"", ""XMLHttpRequest"")
+//
+// The above route will only match if both request header values match.
+//
+// It the value is an empty string, it will match any value if the key is set.
+func (r *Route) Headers(pairs ...string) *Route {
+	if r.err == nil {
+		var headers map[string]string
+		headers, r.err = mapFromPairs(pairs...)
+		return r.addMatcher(headerMatcher(headers))
+	}
+	return r
+}
+
+// Host -----------------------------------------------------------------------
+
+// Host adds a matcher for the URL host.
+// It accepts a template with zero or more URL variables enclosed by {}.
+// Variables can define an optional regexp pattern to me matched:
+//
+// - {name} matches anything until the next dot.
+//
+// - {name:pattern} matches the given regexp pattern.
+//
+// For example:
+//
+//     r := mux.NewRouter()
+//     r.Host(""www.domain.com"")
+//     r.Host(""{subdomain}.domain.com"")
+//     r.Host(""{subdomain:[a-z]+}.domain.com"")
+//
+// Variable names must be unique in a given route. They can be retrieved
+// calling mux.Vars(request).
+func (r *Route) Host(tpl string) *Route {
+	r.err = r.addRegexpMatcher(tpl, true, false)
+	return r
+}
+
+// MatcherFunc ----------------------------------------------------------------
+
+// MatcherFunc is the function signature used by custom matchers.
+type MatcherFunc func(*http.Request, *RouteMatch) bool
+
+func (m MatcherFunc) Match(r *http.Request, match *RouteMatch) bool {
+	return m(r, match)
+}
+
+// MatcherFunc adds a custom function to be used as request matcher.
+func (r *Route) MatcherFunc(f MatcherFunc) *Route {
+	return r.addMatcher(f)
+}
+
+// Methods --------------------------------------------------------------------
+
+// methodMatcher matches the request against HTTP methods.
+type methodMatcher []string
+
+func (m methodMatcher) Match(r *http.Request, match *RouteMatch) bool {
+	return matchInArray(m, r.Method)
+}
+
+// Methods adds a matcher for HTTP methods.
+// It accepts a sequence of one or more methods to be matched, e.g.:
+// ""GET"", ""POST"", ""PUT"".
+func (r *Route) Methods(methods ...string) *Route {
+	for k, v := range methods {
+		methods[k] = strings.ToUpper(v)
+	}
+	return r.addMatcher(methodMatcher(methods))
+}
+
+// Path -----------------------------------------------------------------------
+
+// Path adds a matcher for the URL path.
+// It accepts a template with zero or more URL variables enclosed by {}.
+// Variables can define an optional regexp pattern to me matched:
+//
+// - {name} matches anything until the next slash.
+//
+// - {name:pattern} matches the given regexp pattern.
+//
+// For example:
+//
+//     r := mux.NewRouter()
+//     r.Path(""/products/"").Handler(ProductsHandler)
+//     r.Path(""/products/{key}"").Handler(ProductsHandler)
+//     r.Path(""/articles/{category}/{id:[0-9]+}"").
+//       Handler(ArticleHandler)
+//
+// Variable names must be unique in a given route. They can be retrieved
+// calling mux.Vars(request).
+func (r *Route) Path(tpl string) *Route {
+	r.err = r.addRegexpMatcher(tpl, false, false)
+	return r
+}
+
+// PathPrefix -----------------------------------------------------------------
+
+// PathPrefix adds a matcher for the URL path prefix.
+func (r *Route) PathPrefix(tpl string) *Route {
+	r.strictSlash = false
+	r.err = r.addRegexpMatcher(tpl, false, true)
+	return r
+}
+
+// Query ----------------------------------------------------------------------
+
+// queryMatcher matches the request against URL queries.
+type queryMatcher map[string]string
+
+func (m queryMatcher) Match(r *http.Request, match *RouteMatch) bool {
+	return matchMap(m, r.URL.Query(), false)
+}
+
+// Queries adds a matcher for URL query values.
+// It accepts a sequence of key/value pairs. For example:
+//
+//     r := mux.NewRouter()
+//     r.Queries(""foo"", ""bar"", ""baz"", ""ding"")
+//
+// The above route will only match if the URL contains the defined queries
+// values, e.g.: ?foo=bar&baz=ding.
+//
+// It the value is an empty string, it will match any value if the key is set.
+func (r *Route) Queries(pairs ...string) *Route {
+	if r.err == nil {
+		var queries map[string]string
+		queries, r.err = mapFromPairs(pairs...)
+		return r.addMatcher(queryMatcher(queries))
+	}
+	return r
+}
+
+// Schemes --------------------------------------------------------------------
+
+// schemeMatcher matches the request against URL schemes.
+type schemeMatcher []string
+
+func (m schemeMatcher) Match(r *http.Request, match *RouteMatch) bool {
+	return matchInArray(m, r.URL.Scheme)
+}
+
+// Schemes adds a matcher for URL schemes.
+// It accepts a sequence schemes to be matched, e.g.: ""http"", ""https"".
+func (r *Route) Schemes(schemes ...string) *Route {
+	for k, v := range schemes {
+		schemes[k] = strings.ToLower(v)
+	}
+	return r.addMatcher(schemeMatcher(schemes))
+}
+
+// Subrouter ------------------------------------------------------------------
+
+// Subrouter creates a subrouter for the route.
+//
+// It will test the inner routes only if the parent route matched. For example:
+//
+//     r := mux.NewRouter()
+//     s := r.Host(""www.domain.com"").Subrouter()
+//     s.HandleFunc(""/products/"", ProductsHandler)
+//     s.HandleFunc(""/products/{key}"", ProductHandler)
+//     s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+//
+// Here, the routes registered in the subrouter won't be tested if the host
+// doesn't match.
+func (r *Route) Subrouter() *Router {
+	router := &Router{parent: r, strictSlash: r.strictSlash}
+	r.addMatcher(router)
+	return router
+}
+
+// ----------------------------------------------------------------------------
+// URL building
+// ----------------------------------------------------------------------------
+
+// URL builds a URL for the route.
+//
+// It accepts a sequence of key/value pairs for the route variables. For
+// example, given this route:
+//
+//     r := mux.NewRouter()
+//     r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+//       Name(""article"")
+//
+// ...a URL for it can be built using:
+//
+//     url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+//
+// ...which will return an url.URL with the following path:
+//
+//     ""/articles/technology/42""
+//
+// This also works for host variables:
+//
+//     r := mux.NewRouter()
+//     r.Host(""{subdomain}.domain.com"").
+//       HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+//       Name(""article"")
+//
+//     // url.String() will be ""http://news.domain.com/articles/technology/42""
+//     url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+//                                      ""category"", ""technology"",
+//                                      ""id"", ""42"")
+//
+// All variables defined in the route are required, and their values must
+// conform to the corresponding patterns.
+func (r *Route) URL(pairs ...string) (*url.URL, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	if r.regexp == nil {
+		return nil, errors.New(""mux: route doesn't have a host or path"")
+	}
+	var scheme, host, path string
+	var err error
+	if r.regexp.host != nil {
+		// Set a default scheme.
+		scheme = ""http""
+		if host, err = r.regexp.host.url(pairs...); err != nil {
+			return nil, err
+		}
+	}
+	if r.regexp.path != nil {
+		if path, err = r.regexp.path.url(pairs...); err != nil {
+			return nil, err
+		}
+	}
+	return &url.URL{
+		Scheme: scheme,
+		Host:   host,
+		Path:   path,
+	}, nil
+}
+
+// URLHost builds the host part of the URL for a route. See Route.URL().
+//
+// The route must have a host defined.
+func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	if r.regexp == nil || r.regexp.host == nil {
+		return nil, errors.New(""mux: route doesn't have a host"")
+	}
+	host, err := r.regexp.host.url(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	return &url.URL{
+		Scheme: ""http"",
+		Host:   host,
+	}, nil
+}
+
+// URLPath builds the path part of the URL for a route. See Route.URL().
+//
+// The route must have a path defined.
+func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	if r.regexp == nil || r.regexp.path == nil {
+		return nil, errors.New(""mux: route doesn't have a path"")
+	}
+	path, err := r.regexp.path.url(pairs...)
+	if err != nil {
+		return nil, err
+	}
+	return &url.URL{
+		Path: path,
+	}, nil
+}
+
+// ----------------------------------------------------------------------------
+// parentRoute
+// ----------------------------------------------------------------------------
+
+// parentRoute allows routes to know about parent host and path definitions.
+type parentRoute interface {
+	getNamedRoutes() map[string]*Route
+	getRegexpGroup() *routeRegexpGroup
+}
+
+// getNamedRoutes returns the map where named routes are registered.
+func (r *Route) getNamedRoutes() map[string]*Route {
+	if r.parent == nil {
+		// During tests router is not always set.
+		r.parent = NewRouter()
+	}
+	return r.parent.getNamedRoutes()
+}
+
+// getRegexpGroup returns regexp definitions from this route.
+func (r *Route) getRegexpGroup() *routeRegexpGroup {
+	if r.regexp == nil {
+		if r.parent == nil {
+			// During tests router is not always set.
+			r.parent = NewRouter()
+		}
+		regexp := r.parent.getRegexpGroup()
+		if regexp == nil {
+			r.regexp = new(routeRegexpGroup)
+		} else {
+			// Copy.
+			r.regexp = &routeRegexpGroup{
+				host: regexp.host,
+				path: regexp.path,
+			}
+		}
+	}
+	return r.regexp
+}",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=eac83ba2c004bb759a2875b1f1dbb032adf8bb4a,https://github.com/gorilla/mux/blob/eac83ba2c004bb759a2875b1f1dbb032adf8bb4a/route.go
4e8d10dc715feb79b43f1d607b45148537546a0a,ba77972572d284aaa0819bdc93eba0acbd8ded07,README.md,,"Tue, 02 Oct 2012 21:32:24 GMT",added,2,0,2,"@@ -0,0 +1,2 @@
+mux
+===
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=4e8d10dc715feb79b43f1d607b45148537546a0a,https://github.com/gorilla/mux/blob/4e8d10dc715feb79b43f1d607b45148537546a0a/README.md
ac856fa44dac3d5bdac2160d53f6bbec042fa3a3,52d2601a1e446fa1f375c47bb8013c70ee6c1781,LICENSE,,"Sun, 05 Nov 2023 21:57:10 GMT",modified,8,24,32,"@@ -1,27 +1,11 @@
-Copyright (c) 2023 The Gorilla Authors. All rights reserved.
+Copyright (c) 2023 Gorilla web toolkit Authors. All rights reserved.
 
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 
-	 * Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-	 * Redistributions in binary form must reproduce the above
-copyright notice, this list of conditions and the following disclaimer
-in the documentation and/or other materials provided with the
-distribution.
-	 * Neither the name of Google Inc. nor the names of its
-contributors may be used to endorse or promote products derived from
-this software without specific prior written permission.
+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",https://api.github.com/repos/gorilla/mux/contents/LICENSE?ref=ac856fa44dac3d5bdac2160d53f6bbec042fa3a3,https://github.com/gorilla/mux/blob/ac856fa44dac3d5bdac2160d53f6bbec042fa3a3/LICENSE
b4617d0b9670ad14039b2739167fd35a60f557c5,768b05b3f85986dd4377b89cb91e63af53bfc55a,.github/workflows/issues.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,1,1,2,"@@ -1,4 +1,4 @@
-# Add issues or pull-requests created to the project. 
+# Add all the issues created to the project.
 name: Add issue or pull request to Project
 
 on:",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fissues.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,ff4a613bbfbd483718ef56461b2e45af81efcae8,.github/workflows/security.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",added,37,0,37,"@@ -0,0 +1,37 @@
+name: Security
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+permissions:
+  contents: read
+jobs:
+  scan:
+    strategy:
+      matrix:
+        go: ['1.20','1.21']
+      fail-fast: true
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout Code
+        uses: actions/checkout@v3
+
+      - name: Setup Go ${{ matrix.go }}
+        uses: actions/setup-go@v4
+        with:
+          go-version: ${{ matrix.go }}
+          cache: false
+
+      - name: Run GoSec
+        uses: securego/gosec@master
+        with:
+          args: -exclude-dir examples ./...
+
+      - name: Run GoVulnCheck
+        uses: golang/govulncheck-action@v1
+        with:
+          go-version-input: ${{ matrix.go }}
+          go-package: ./...",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fsecurity.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fsecurity.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,50a3946abf6930ff1448aeedd932ca51e107e68b,.github/workflows/test.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,4,24,28,"@@ -1,20 +1,18 @@
-name: CI
+name: Test
 on:
   push:
     branches:
       - main
   pull_request:
     branches:
       - main
-
 permissions:
   contents: read
-
 jobs:
-  verify-and-test:
+  unit:
     strategy:
       matrix:
-        go: ['1.19','1.20']
+        go: ['1.20','1.21']
         os: [ubuntu-latest, macos-latest, windows-latest]
       fail-fast: true
     runs-on: ${{ matrix.os }}
@@ -28,28 +26,10 @@ jobs:
           go-version: ${{ matrix.go }}
           cache: false
 
-      - name: Run GolangCI-Lint
-        uses: golangci/golangci-lint-action@v3
-        with:
-          version: v1.53
-          args: --timeout=5m
-
-      - name: Run GoSec
-        if: matrix.os == 'ubuntu-latest'
-        uses: securego/gosec@master
-        with:
-          args: ./...
-
-      - name: Run GoVulnCheck
-        uses: golang/govulncheck-action@v1
-        with:
-          go-version-input: ${{ matrix.go }}
-          go-package: ./...
-
       - name: Run Tests
         run: go test -race -cover -coverprofile=coverage -covermode=atomic -v ./...
 
       - name: Upload coverage to Codecov
         uses: codecov/codecov-action@v3
         with:
-          files: ./coverage
\ No newline at end of file
+          files: ./coverage",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Ftest.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Ftest.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,a3eb74b3177fd240a907b1d79203576dca0dae24,.github/workflows/verify.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",added,32,0,32,"@@ -0,0 +1,32 @@
+name: Verify
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+permissions:
+  contents: read
+jobs:
+  lint:
+    strategy:
+      matrix:
+        go: ['1.20','1.21']
+      fail-fast: true
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout Code
+        uses: actions/checkout@v3
+
+      - name: Setup Go ${{ matrix.go }}
+        uses: actions/setup-go@v4
+        with:
+          go-version: ${{ matrix.go }}
+          cache: false
+
+      - name: Run GolangCI-Lint
+        uses: golangci/golangci-lint-action@v3
+        with:
+          version: v1.53
+          args: --timeout=5m",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fverify.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fverify.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,7c6f375b81e8342aa572dd49a404b925a0762a56,go.mod,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,1,1,2,"@@ -1,3 +1,3 @@
 module github.com/gorilla/mux
 
-go 1.19
+go 1.20",https://api.github.com/repos/gorilla/mux/contents/go.mod?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/go.mod
3401478badc7aa55470bc806ee8cd185a16f9298,382513d57c4c6ffd671b8a173beaef1f094e1ec2,README.md,,"Thu, 21 Sep 2023 03:06:08 GMT",modified,13,11,24,"@@ -247,23 +247,25 @@ type spaHandler struct {
 // file located at the index path on the SPA handler will be served. This
 // is suitable behavior for serving an SPA (single page application).
 func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-    // Join internally call path.Clean to prevent directory traversal
-    path := filepath.Join(h.staticPath, path)
+	// Join internally call path.Clean to prevent directory traversal
+	path := filepath.Join(h.staticPath, r.URL.Path)
 
-    // check whether a file exists at the given path
-	_, err := os.Stat(path)
-	if os.IsNotExist(err) {
-		// file does not exist, serve index.html
+	// check whether a file exists or is a directory at the given path
+	fi, err := os.Stat(path)
+	if os.IsNotExist(err) || fi.IsDir() {
+		// file does not exist or path is a directory, serve index.html
 		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))
 		return
-	} else if err != nil {
-        // if we got an error (that wasn't that the file doesn't exist) stating the
-        // file, return a 500 internal server error and stop
+	}
+
+	if err != nil {
+		// if we got an error (that wasn't that the file doesn't exist) stating the
+		// file, return a 500 internal server error and stop
 		http.Error(w, err.Error(), http.StatusInternalServerError)
-		return
+        return
 	}
 
-    // otherwise, use http.FileServer to serve the static dir
+	// otherwise, use http.FileServer to serve the static file
 	http.FileServer(http.Dir(h.staticPath)).ServeHTTP(w, r)
 }
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=3401478badc7aa55470bc806ee8cd185a16f9298,https://github.com/gorilla/mux/blob/3401478badc7aa55470bc806ee8cd185a16f9298/README.md
4a671cbc5162efa2ecb1b353e6a704a62737d66c,87ada8ec271e3381a2c589febf5529bbc2cdff77,README.md,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,13,0,13,"@@ -366,6 +366,19 @@ url, err := r.Get(""article"").URL(""subdomain"", ""news"",
                                  ""id"", ""42"")
 ```
 
+To find all the required variables for a given route when calling `URL()`, the method `GetVarNames()` is available:
+```go
+r := mux.NewRouter()
+r.Host(""{domain}"").
+    Path(""/{group}/{item_id}"").
+    Queries(""some_data1"", ""{some_data1}"").
+    Queries(""some_data2"", ""{some_data2}"").
+    Name(""article"")
+
+// Will print [domain group item_id some_data1 some_data2] <nil>
+fmt.Println(r.Get(""article"").GetVarNames())
+
+```
 ### Walking Routes
 
 The `Walk` function on `mux.Router` can be used to visit all of the routes that are registered on a router. For example,",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/README.md
4a671cbc5162efa2ecb1b353e6a704a62737d66c,428c3b6c2573a429841ad82a1724e3f9fc25bd41,example_route_vars_test.go,,"Thu, 24 Aug 2023 19:57:51 GMT",added,35,0,35,"@@ -0,0 +1,35 @@
+package mux_test
+
+import (
+	""fmt""
+	""github.com/gorilla/mux""
+)
+
+// This example demonstrates building a dynamic URL using
+// required vars and values retrieve from another source
+func ExampleRoute_GetVarNames() {
+	r := mux.NewRouter()
+
+	route := r.Host(""{domain}"").
+		Path(""/{group}/{item_id}"").
+		Queries(""some_data1"", ""{some_data1}"").
+		Queries(""some_data2_and_3"", ""{some_data2}.{some_data3}"")
+
+	dataSource := func(key string) string {
+		return ""my_value_for_"" + key
+	}
+
+	varNames, _ := route.GetVarNames()
+
+	pairs := make([]string, 0, len(varNames)*2)
+
+	for _, varName := range varNames {
+		pairs = append(pairs, varName, dataSource(varName))
+	}
+
+	url, err := route.URL(pairs...)
+	if err != nil {
+		panic(err)
+	}
+	fmt.Println(url.String())
+}",https://api.github.com/repos/gorilla/mux/contents/example_route_vars_test.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/example_route_vars_test.go
4a671cbc5162efa2ecb1b353e6a704a62737d66c,5898688be239818d2014b1ffb0769295adb4c54e,mux_test.go,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,34,0,34,"@@ -2879,6 +2879,40 @@ func TestContextMiddleware(t *testing.T) {
 	r.ServeHTTP(rec, req)
 }
 
+func TestGetVarNames(t *testing.T) {
+	r := NewRouter()
+
+	route := r.Host(""{domain}"").
+		Path(""/{group}/{item_id}"").
+		Queries(""some_data1"", ""{some_data1}"").
+		Queries(""some_data2_and_3"", ""{some_data2}.{some_data3}"")
+
+	// Order of vars in the slice is not guaranteed, so just check for existence
+	expected := map[string]bool{
+		""domain"":     true,
+		""group"":      true,
+		""item_id"":    true,
+		""some_data1"": true,
+		""some_data2"": true,
+		""some_data3"": true,
+	}
+
+	varNames, err := route.GetVarNames()
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	if len(varNames) != len(expected) {
+		t.Fatalf(""expected %d names, got %d"", len(expected), len(varNames))
+	}
+
+	for _, varName := range varNames {
+		if !expected[varName] {
+			t.Fatalf(""got unexpected %s"", varName)
+		}
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/mux_test.go
4a671cbc5162efa2ecb1b353e6a704a62737d66c,e8f11df221f089306926ac23775906a4a50cde62,route.go,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,19,0,19,"@@ -728,6 +728,25 @@ func (r *Route) GetHostTemplate() (string, error) {
 	return r.regexp.host.template, nil
 }
 
+// GetVarNames returns the names of all variables added by regexp matchers
+// These can be used to know which route variables should be passed into r.URL()
+func (r *Route) GetVarNames() ([]string, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	var varNames []string
+	if r.regexp.host != nil {
+		varNames = append(varNames, r.regexp.host.varsN...)
+	}
+	if r.regexp.path != nil {
+		varNames = append(varNames, r.regexp.path.varsN...)
+	}
+	for _, regx := range r.regexp.queries {
+		varNames = append(varNames, regx.varsN...)
+	}
+	return varNames, nil
+}
+
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/route.go
976b536446a77de8de2d5559c78f612970fb5e37,0845d7f7549034cb3c2964f4d454e50aa07c02d4,mux_test.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,18,0,18,"@@ -2116,6 +2116,24 @@ func TestMultipleDefinitionOfSamePathWithDifferentMethods(t *testing.T) {
 
 }
 
+func TestMultipleDefinitionOfSamePathWithDifferentQueries(t *testing.T) {
+	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/api"", emptyHandler).Queries(""foo"", ""{foo:[0-9]+}"").Methods(http.MethodGet)
+	r.HandleFunc(""/api"", emptyHandler).Queries(""bar"", ""{bar:[0-9]+}"").Methods(http.MethodGet)
+
+	req := newRequest(http.MethodGet, ""/api?bar=4"")
+	match := new(RouteMatch)
+	matched := r.Match(req, match)
+	if !matched {
+		t.Error(""Should have matched route for methods"")
+	}
+	if match.MatchErr != nil {
+		t.Error(""Should have no error. Found:"", match.MatchErr)
+	}
+}
+
 func TestErrMatchNotFound(t *testing.T) {
 	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=976b536446a77de8de2d5559c78f612970fb5e37,https://github.com/gorilla/mux/blob/976b536446a77de8de2d5559c78f612970fb5e37/mux_test.go
976b536446a77de8de2d5559c78f612970fb5e37,b6582dae2201d75e70fdf3bf8df6a6ba864c54a2,route.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,1,1,2,"@@ -87,7 +87,7 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 		return false
 	}
 
-	if match.MatchErr == ErrMethodMismatch && r.handler != nil {
+	if match.MatchErr != nil && r.handler != nil {
 		// We found a route which matches request method, clear MatchErr
 		match.MatchErr = nil
 		// Then override the mis-matched handler",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=976b536446a77de8de2d5559c78f612970fb5e37,https://github.com/gorilla/mux/blob/976b536446a77de8de2d5559c78f612970fb5e37/route.go
2b030fc311d07b8c5950807800b03b2d32a7142c,7f123f0246e7f0bfdcec6ee64f170b3aed5367b8,mux_test.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,17,0,17,"@@ -2784,6 +2784,23 @@ func TestMethodNotAllowed(t *testing.T) {
 	}
 }
 
+func TestMethodNotAllowedSubrouterWithSeveralRoutes(t *testing.T) {
+	handler := func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }
+
+	router := NewRouter()
+	subrouter := router.PathPrefix(""/v1"").Subrouter()
+	subrouter.HandleFunc(""/api"", handler).Methods(http.MethodGet)
+	subrouter.HandleFunc(""/api/{id}"", handler).Methods(http.MethodGet)
+
+	w := NewRecorder()
+	req := newRequest(http.MethodPut, ""/v1/api"")
+	router.ServeHTTP(w, req)
+
+	if w.Code != http.StatusMethodNotAllowed {
+		t.Errorf(""Expected status code 405 (got %d)"", w.Code)
+	}
+}
+
 type customMethodNotAllowedHandler struct {
 	msg string
 }",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=2b030fc311d07b8c5950807800b03b2d32a7142c,https://github.com/gorilla/mux/blob/2b030fc311d07b8c5950807800b03b2d32a7142c/mux_test.go
2b030fc311d07b8c5950807800b03b2d32a7142c,cb89ebb86548e12fb1e421ca908d05496d72353b,route.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,13,10,23,"@@ -53,6 +53,19 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 				continue
 			}
 
+			// Multiple routes may share the same path but use different HTTP methods. For instance:
+			// Route 1: POST ""/users/{id}"".
+			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
+			//
+			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
+			// The router should return a ""Not Found"" error as no route fully matches this request.
+			if rr, ok := m.(*routeRegexp); ok {
+				if rr.regexpType == regexpTypeQuery {
+					matchErr = ErrNotFound
+					break
+				}
+			}
+
 			// Ignore ErrNotFound errors. These errors arise from match call
 			// to Subrouters.
 			//
@@ -66,16 +79,6 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 
 			matchErr = nil // nolint:ineffassign
 			return false
-		} else {
-			// Multiple routes may share the same path but use different HTTP methods. For instance:
-			// Route 1: POST ""/users/{id}"".
-			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
-			//
-			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
-			// The router should return a ""Not Found"" error as no route fully matches this request.
-			if match.MatchErr == ErrMethodMismatch {
-				match.MatchErr = nil
-			}
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=2b030fc311d07b8c5950807800b03b2d32a7142c,https://github.com/gorilla/mux/blob/2b030fc311d07b8c5950807800b03b2d32a7142c/route.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,c1f86ca53e27dad12ea07c101799431393643fbf,bench_test.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,32,0,32,"@@ -21,6 +21,38 @@ func BenchmarkMux(b *testing.B) {
 	}
 }
 
+func BenchmarkMuxSimple(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/status"", handler)
+
+	testCases := []struct {
+		name                 string
+		omitRouteFromContext bool
+	}{
+		{
+			name:                 ""default"",
+			omitRouteFromContext: false,
+		},
+		{
+			name:                 ""omit route from ctx"",
+			omitRouteFromContext: true,
+		},
+	}
+	for _, tc := range testCases {
+		b.Run(tc.name, func(b *testing.B) {
+			router.OmitRouteFromContext(tc.omitRouteFromContext)
+
+			request, _ := http.NewRequest(""GET"", ""/status"", nil)
+			b.ReportAllocs()
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				router.ServeHTTP(nil, request)
+			}
+		})
+	}
+}
+
 func BenchmarkMuxAlternativeInRegexp(b *testing.B) {
 	router := new(Router)
 	handler := func(w http.ResponseWriter, r *http.Request) {}",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/bench_test.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,bcab454cf870433b1ba2c48f4e6952736dcca837,mux.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,45,12,57,"@@ -9,6 +9,7 @@ import (
 	""errors""
 	""fmt""
 	""net/http""
+	""net/url""
 	""path""
 	""regexp""
 )
@@ -84,6 +85,9 @@ type routeConf struct {
 	// will not redirect
 	skipClean bool
 
+	// If true, the http.Request context will not contain the Route.
+	omitRouteFromContext bool
+
 	// Manager for the variables from host and path.
 	regexp routeRegexpGroup
 
@@ -180,15 +184,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		}
 		// Clean path to canonical form and redirect.
 		if p := cleanPath(path); p != path {
-
-			// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
-			// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
-			// http://code.google.com/p/go/issues/detail?id=5252
-			url := *req.URL
-			url.Path = p
-			p = url.String()
-
-			w.Header().Set(""Location"", p)
+			w.Header().Set(""Location"", replaceURLPath(req.URL, p))
 			w.WriteHeader(http.StatusMovedPermanently)
 			return
 		}
@@ -197,8 +193,15 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	var handler http.Handler
 	if r.Match(req, &match) {
 		handler = match.Handler
-		req = requestWithVars(req, match.Vars)
-		req = requestWithRoute(req, match.Route)
+		if handler != nil {
+			// Populate context for custom handlers
+			if r.omitRouteFromContext {
+				// Only populate the match vars (if any) into the context.
+				req = requestWithVars(req, match.Vars)
+			} else {
+				req = requestWithRouteAndVars(req, match.Route, match.Vars)
+			}
+		}
 	}
 
 	if handler == nil && match.MatchErr == ErrMethodMismatch {
@@ -260,6 +263,16 @@ func (r *Router) SkipClean(value bool) *Router {
 	return r
 }
 
+// OmitRouteFromContext defines the behavior of omitting the Route from the
+//
+//	http.Request context.
+//
+// CurrentRoute will yield nil with this option.
+func (r *Router) OmitRouteFromContext(value bool) *Router {
+	r.omitRouteFromContext = value
+	return r
+}
+
 // UseEncodedPath tells the router to match the encoded original path
 // to the routes.
 // For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to"".
@@ -445,13 +458,25 @@ func CurrentRoute(r *http.Request) *Route {
 	return nil
 }
 
+// requestWithRouteAndVars adds the matched vars to the request ctx.
+// It shortcuts the operation when the vars are empty.
 func requestWithVars(r *http.Request, vars map[string]string) *http.Request {
+	if len(vars) == 0 {
+		return r
+	}
 	ctx := context.WithValue(r.Context(), varsKey, vars)
 	return r.WithContext(ctx)
 }
 
-func requestWithRoute(r *http.Request, route *Route) *http.Request {
+// requestWithRouteAndVars adds the matched route and vars to the request ctx.
+// It saves extra allocations in cloning the request once and skipping the
+//
+//	population of empty vars, which in turn mux.Vars can handle gracefully.
+func requestWithRouteAndVars(r *http.Request, route *Route, vars map[string]string) *http.Request {
 	ctx := context.WithValue(r.Context(), routeKey, route)
+	if len(vars) > 0 {
+		ctx = context.WithValue(ctx, varsKey, vars)
+	}
 	return r.WithContext(ctx)
 }
 
@@ -478,6 +503,14 @@ func cleanPath(p string) string {
 	return np
 }
 
+// replaceURLPath prints an url.URL with a different path.
+func replaceURLPath(u *url.URL, p string) string {
+	// Operate on a copy of the request url.
+	u2 := *u
+	u2.Path = p
+	return u2.String()
+}
+
 // uniqueVars returns an error if two slices contain duplicated strings.
 func uniqueVars(s1, s2 []string) error {
 	for _, v1 := range s1 {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/mux.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,cb3bbe0a5eaf58803a115316407871492dc0be86,mux_test.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,186,64,250,"@@ -59,7 +59,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route match"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: true,
@@ -68,7 +68,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, wrong host in request URL"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: false,
@@ -77,7 +77,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, match"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: true,
@@ -86,7 +86,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, wrong port in request URL"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: false,
@@ -95,7 +95,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, match with host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: true,
@@ -104,7 +104,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, wrong host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: false,
@@ -113,7 +113,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, match with request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: true,
@@ -122,7 +122,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, wrong host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: false,
@@ -232,7 +232,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, match"",
 			route:       new(Route).Path(""/111/222/333""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/222/333"",
 			shouldMatch: true,
@@ -241,7 +241,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, match with trailing slash in request and path"",
 			route:       new(Route).Path(""/111/""),
 			request:     newRequest(""GET"", ""http://localhost/111/""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/"",
 			shouldMatch: true,
@@ -250,7 +250,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, do not match with trailing slash in path"",
 			route:        new(Route).Path(""/111/""),
 			request:      newRequest(""GET"", ""http://localhost/111""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/111"",
 			pathTemplate: `/111/`,
@@ -261,7 +261,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, do not match with trailing slash in request"",
 			route:        new(Route).Path(""/111""),
 			request:      newRequest(""GET"", ""http://localhost/111/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/111/"",
 			pathTemplate: `/111`,
@@ -271,7 +271,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, match root with no host"",
 			route:        new(Route).Path(""/""),
 			request:      newRequest(""GET"", ""/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -286,7 +286,7 @@ func TestPath(t *testing.T) {
 				r.RequestURI = ""/""
 				return r
 			}(),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -296,7 +296,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, wrong path in request in request URL"",
 			route:       new(Route).Path(""/111/222/333""),
 			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/222/333"",
 			shouldMatch: false,
@@ -468,7 +468,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, match"",
 			route:       new(Route).PathPrefix(""/111""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111"",
 			shouldMatch: true,
@@ -477,7 +477,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, match substring"",
 			route:       new(Route).PathPrefix(""/1""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/1"",
 			shouldMatch: true,
@@ -486,7 +486,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, URL prefix in request does not match"",
 			route:       new(Route).PathPrefix(""/111""),
 			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111"",
 			shouldMatch: false,
@@ -548,7 +548,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Host and Path route, match"",
 			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -560,7 +560,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Scheme, Host, and Path route, match"",
 			route:        new(Route).Schemes(""https"").Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""https://aaa.bbb.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""https"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -572,7 +572,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Host and Path route, wrong host in request URL"",
 			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -669,7 +669,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, match"",
 			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -678,7 +678,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, bad header values"",
 			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -687,7 +687,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, regex header values to match"",
 			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baw""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -696,7 +696,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, regex header values to match"",
 			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baz""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -717,7 +717,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, match GET"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""GET"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -727,7 +727,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, match POST"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""POST"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -737,7 +737,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, bad method"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""PUT"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -747,7 +747,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Route without methods"",
 			route:       new(Route),
 			request:     newRequest(""PUT"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{},
@@ -770,7 +770,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -782,7 +782,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match with a query string"",
 			route:           new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -796,7 +796,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match with a query string out of order"",
 			route:           new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -810,7 +810,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, bad query"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar,baz=ding"",
@@ -857,7 +857,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=a""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]+}"",
@@ -892,7 +892,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern with quantifier, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=12""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]{1}}"",
@@ -915,7 +915,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=12""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]{1}}"",
@@ -974,7 +974,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value, should match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo="",
@@ -986,7 +986,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value and no parameter in request, should not match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo="",
@@ -997,7 +997,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value and empty parameter in request, should match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost?foo=""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo="",
@@ -1009,7 +1009,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with overlapping value, should not match"",
 			route:           new(Route).Queries(""foo"", ""bar""),
 			request:         newRequest(""GET"", ""http://localhost?foo=barfoo""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar"",
@@ -1020,7 +1020,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with no parameter in request, should not match"",
 			route:           new(Route).Queries(""foo"", ""{bar}""),
 			request:         newRequest(""GET"", ""http://localhost""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={bar}"",
@@ -1043,7 +1043,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, bad submatch"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?fffoo=bar&baz=dingggg""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar,baz=ding"",
@@ -1136,7 +1136,7 @@ func TestMatcherFunc(t *testing.T) {
 			title:       ""MatchFunc route, match"",
 			route:       new(Route).MatcherFunc(m),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -1145,7 +1145,7 @@ func TestMatcherFunc(t *testing.T) {
 			title:       ""MatchFunc route, non-match"",
 			route:       new(Route).MatcherFunc(m),
 			request:     newRequest(""GET"", ""http://aaa.222.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -1246,7 +1246,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter3.Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1255,7 +1255,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter3.Path(""""),
 			request:      newRequest(""GET"", ""http://localhost/foo""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo"",
 			pathTemplate: `/foo`,
@@ -1265,7 +1265,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter4.Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/bar/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/bar/"",
 			pathTemplate: `/foo/bar/`,
@@ -1274,7 +1274,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter4.Path(""""),
 			request:      newRequest(""GET"", ""http://localhost/foo/bar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/bar"",
 			pathTemplate: `/foo/bar`,
@@ -1302,7 +1302,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Mismatch method specified on parent route"",
 			route:        new(Route).Methods(""POST"").PathPrefix(""/foo"").Subrouter().Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1312,7 +1312,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Match method specified on parent route"",
 			route:        new(Route).Methods(""POST"").PathPrefix(""/foo"").Subrouter().Path(""/""),
 			request:      newRequest(""POST"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1322,7 +1322,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Mismatch scheme specified on parent route"",
 			route:        new(Route).Schemes(""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1332,7 +1332,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Match scheme specified on parent route"",
 			route:        new(Route).Schemes(""http"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1342,7 +1342,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""No match header specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1352,7 +1352,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Header mismatch value specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequestWithHeaders(""GET"", ""http://localhost/"", ""X-Forwarded-Proto"", ""http""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1362,7 +1362,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Header match value specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequestWithHeaders(""GET"", ""http://localhost/"", ""X-Forwarded-Proto"", ""https""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1372,7 +1372,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query specified on parent route not present"",
 			route:        new(Route).Headers(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1382,7 +1382,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query mismatch value specified on parent route"",
 			route:        new(Route).Queries(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/?key=notfoobar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1392,7 +1392,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query match value specified on subroute"",
 			route:        new(Route).Queries(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/?key=foobar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1473,7 +1473,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Redirect path without slash"",
 			route:          r.NewRoute().Path(""/111/""),
 			request:        newRequest(""GET"", ""http://localhost/111""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111/"",
 			shouldMatch:    true,
@@ -1483,7 +1483,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Do not redirect path with slash"",
 			route:          r.NewRoute().Path(""/111/""),
 			request:        newRequest(""GET"", ""http://localhost/111/""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111/"",
 			shouldMatch:    true,
@@ -1493,7 +1493,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Redirect path with slash"",
 			route:          r.NewRoute().Path(""/111""),
 			request:        newRequest(""GET"", ""http://localhost/111/""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111"",
 			shouldMatch:    true,
@@ -1503,7 +1503,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Do not redirect path without slash"",
 			route:          r.NewRoute().Path(""/111""),
 			request:        newRequest(""GET"", ""http://localhost/111""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111"",
 			shouldMatch:    true,
@@ -1513,7 +1513,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Propagate StrictSlash to subrouters"",
 			route:          r.NewRoute().PathPrefix(""/static/"").Subrouter().Path(""/images/""),
 			request:        newRequest(""GET"", ""http://localhost/static/images""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/static/images/"",
 			shouldMatch:    true,
@@ -1523,7 +1523,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Ignore StrictSlash for path prefix"",
 			route:          r.NewRoute().PathPrefix(""/static/""),
 			request:        newRequest(""GET"", ""http://localhost/static/logo.png""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/static/"",
 			shouldMatch:    true,
@@ -2913,6 +2913,128 @@ func TestGetVarNames(t *testing.T) {
 	}
 }
 
+func getPopulateContextTestCases() []struct {
+	name                 string
+	path                 string
+	omitRouteFromContext bool
+	wantVar              string
+	wantStaticRoute      bool
+	wantDynamicRoute     bool
+} {
+	return []struct {
+		name                 string
+		path                 string
+		omitRouteFromContext bool
+		wantVar              string
+		wantStaticRoute      bool
+		wantDynamicRoute     bool
+	}{
+		{
+			name:            ""no populated vars"",
+			path:            ""/static"",
+			wantVar:         """",
+			wantStaticRoute: true,
+		},
+		{
+			name:             ""empty var"",
+			path:             ""/dynamic/"",
+			wantVar:          """",
+			wantDynamicRoute: true,
+		},
+		{
+			name:             ""populated vars"",
+			path:             ""/dynamic/foo"",
+			wantVar:          ""foo"",
+			wantDynamicRoute: true,
+		},
+		{
+			name:                 ""omit route /static"",
+			path:                 ""/static"",
+			omitRouteFromContext: true,
+			wantVar:              """",
+			wantStaticRoute:      false,
+		},
+		{
+			name:                 ""omit route /dynamic"",
+			path:                 ""/dynamic/"",
+			omitRouteFromContext: true,
+			wantVar:              """",
+			wantDynamicRoute:     false,
+		},
+	}
+}
+
+func TestPopulateContext(t *testing.T) {
+	testCases := getPopulateContextTestCases()
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			matched := false
+			r := NewRouter()
+			r.OmitRouteFromContext(tc.omitRouteFromContext)
+			var static *Route
+			var dynamic *Route
+			fn := func(w http.ResponseWriter, r *http.Request) {
+				matched = true
+				if got := Vars(r)[""x""]; got != tc.wantVar {
+					t.Fatalf(""wantVar=%q, got=%q"", tc.wantVar, got)
+				}
+				switch {
+				case tc.wantDynamicRoute:
+					r2 := CurrentRoute(r)
+					if r2 != dynamic || r2.GetName() != ""dynamic"" {
+						t.Fatalf(""expected dynmic route in ctx, got %v"", r2)
+					}
+				case tc.wantStaticRoute:
+					r2 := CurrentRoute(r)
+					if r2 != static || r2.GetName() != ""static"" {
+						t.Fatalf(""expected static route in ctx, got %v"", r2)
+					}
+				default:
+					if r2 := CurrentRoute(r); r2 != nil {
+						t.Fatalf(""expected no route in ctx, got %v"", r2)
+					}
+				}
+				w.WriteHeader(http.StatusNoContent)
+			}
+			static = r.Name(""static"").Path(""/static"").HandlerFunc(fn)
+			dynamic = r.Name(""dynamic"").Path(""/dynamic/{x:.*}"").HandlerFunc(fn)
+			req := newRequest(http.MethodGet, ""http://localhost""+tc.path)
+			rec := NewRecorder()
+			r.ServeHTTP(rec, req)
+			if !matched {
+				t.Fatal(""Expected route to match"")
+			}
+		})
+	}
+}
+
+func BenchmarkPopulateContext(b *testing.B) {
+	testCases := getPopulateContextTestCases()
+	for _, tc := range testCases {
+		b.Run(tc.name, func(b *testing.B) {
+			matched := false
+			r := NewRouter()
+			r.OmitRouteFromContext(tc.omitRouteFromContext)
+			fn := func(w http.ResponseWriter, r *http.Request) {
+				matched = true
+				w.WriteHeader(http.StatusNoContent)
+			}
+			r.Name(""static"").Path(""/static"").HandlerFunc(fn)
+			r.Name(""dynamic"").Path(""/dynamic/{x:.*}"").HandlerFunc(fn)
+			req := newRequest(http.MethodGet, ""http://localhost""+tc.path)
+			rec := NewRecorder()
+			b.ReportAllocs()
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				r.ServeHTTP(rec, req)
+			}
+			if !matched {
+				b.Fatal(""Expected route to match"")
+			}
+		})
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/mux_test.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,b577073fa54db7a8d03cc94ff3643ab79b0b5059,regexp.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,40,29,69,"@@ -324,16 +324,18 @@ type routeRegexpGroup struct {
 func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
-		host := getHost(req)
-		if v.host.wildcardHostPort {
-			// Don't be strict on the port match
-			if i := strings.Index(host, "":""); i != -1 {
-				host = host[:i]
+		if len(v.host.varsN) > 0 {
+			host := getHost(req)
+			if v.host.wildcardHostPort {
+				// Don't be strict on the port match
+				if i := strings.Index(host, "":""); i != -1 {
+					host = host[:i]
+				}
+			}
+			matches := v.host.regexp.FindStringSubmatchIndex(host)
+			if len(matches) > 0 {
+				m.Vars = extractVars(host, matches, v.host.varsN, m.Vars)
 			}
-		}
-		matches := v.host.regexp.FindStringSubmatchIndex(host)
-		if len(matches) > 0 {
-			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
 	path := req.URL.Path
@@ -342,31 +344,36 @@ func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	}
 	// Store path variables.
 	if v.path != nil {
-		matches := v.path.regexp.FindStringSubmatchIndex(path)
-		if len(matches) > 0 {
-			extractVars(path, matches, v.path.varsN, m.Vars)
-			// Check if we should redirect.
-			if v.path.options.strictSlash {
-				p1 := strings.HasSuffix(path, ""/"")
-				p2 := strings.HasSuffix(v.path.template, ""/"")
-				if p1 != p2 {
-					u, _ := url.Parse(req.URL.String())
-					if p1 {
-						u.Path = u.Path[:len(u.Path)-1]
-					} else {
-						u.Path += ""/""
-					}
-					m.Handler = http.RedirectHandler(u.String(), http.StatusMovedPermanently)
+		if len(v.path.varsN) > 0 {
+			matches := v.path.regexp.FindStringSubmatchIndex(path)
+			if len(matches) > 0 {
+				m.Vars = extractVars(path, matches, v.path.varsN, m.Vars)
+			}
+		}
+		// Check if we should redirect.
+		if v.path.options.strictSlash {
+			p1 := strings.HasSuffix(path, ""/"")
+			p2 := strings.HasSuffix(v.path.template, ""/"")
+			if p1 != p2 {
+				p := req.URL.Path
+				if p1 {
+					p = p[:len(p)-1]
+				} else {
+					p += ""/""
 				}
+				u := replaceURLPath(req.URL, p)
+				m.Handler = http.RedirectHandler(u, http.StatusMovedPermanently)
 			}
 		}
 	}
 	// Store query string variables.
 	for _, q := range v.queries {
-		queryURL := q.getURLQuery(req)
-		matches := q.regexp.FindStringSubmatchIndex(queryURL)
-		if len(matches) > 0 {
-			extractVars(queryURL, matches, q.varsN, m.Vars)
+		if len(q.varsN) > 0 {
+			queryURL := q.getURLQuery(req)
+			matches := q.regexp.FindStringSubmatchIndex(queryURL)
+			if len(matches) > 0 {
+				m.Vars = extractVars(queryURL, matches, q.varsN, m.Vars)
+			}
 		}
 	}
 }
@@ -381,8 +388,12 @@ func getHost(r *http.Request) string {
 	return r.Host
 }
 
-func extractVars(input string, matches []int, names []string, output map[string]string) {
+func extractVars(input string, matches []int, names []string, output map[string]string) map[string]string {
 	for i, name := range names {
+		if output == nil {
+			output = make(map[string]string, len(names))
+		}
 		output[name] = input[matches[2*i+2]:matches[2*i+3]]
 	}
+	return output
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/regexp.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,8a9e754a38413bae8833cdf31595bf8f75991e83,route.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,0,3,3,"@@ -98,9 +98,6 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if match.Handler == nil {
 		match.Handler = r.handler
 	}
-	if match.Vars == nil {
-		match.Vars = make(map[string]string)
-	}
 
 	// Set variables.
 	r.regexp.setMatch(req, match, r)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/route.go
f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d,c0c37ecac430d3fb1615df736a81da7237f2ec85,mux.go,,"Mon, 13 Nov 2023 04:31:50 GMT",modified,2,2,4,"@@ -233,8 +233,8 @@ func (r *Router) GetRoute(name string) *Route {
 // When false, if the route path is ""/path"", accessing ""/path/"" will not match
 // this route and vice versa.
 //
-// The re-direct is a HTTP 301 (Moved Permanently). Note that when this is set for
-// routes with a non-idempotent method (e.g. POST, PUT), the subsequent re-directed
+// The redirect is a HTTP 301 (Moved Permanently). Note that when this is set for
+// routes with a non-idempotent method (e.g. POST, PUT), the subsequent redirected
 // request will be made as a GET by most clients. Use middleware or client settings
 // to modify this behaviour as needed.
 //",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d,https://github.com/gorilla/mux/blob/f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d/mux.go
