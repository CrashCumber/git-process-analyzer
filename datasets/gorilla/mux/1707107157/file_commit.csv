commit_sha,sha,filename,previous_filename,last_modified,status,additions,deletions,changes,patch,content_url,blob_url
976b536446a77de8de2d5559c78f612970fb5e37,0845d7f7549034cb3c2964f4d454e50aa07c02d4,mux_test.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,18,0,18,"@@ -2116,6 +2116,24 @@ func TestMultipleDefinitionOfSamePathWithDifferentMethods(t *testing.T) {
 
 }
 
+func TestMultipleDefinitionOfSamePathWithDifferentQueries(t *testing.T) {
+	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/api"", emptyHandler).Queries(""foo"", ""{foo:[0-9]+}"").Methods(http.MethodGet)
+	r.HandleFunc(""/api"", emptyHandler).Queries(""bar"", ""{bar:[0-9]+}"").Methods(http.MethodGet)
+
+	req := newRequest(http.MethodGet, ""/api?bar=4"")
+	match := new(RouteMatch)
+	matched := r.Match(req, match)
+	if !matched {
+		t.Error(""Should have matched route for methods"")
+	}
+	if match.MatchErr != nil {
+		t.Error(""Should have no error. Found:"", match.MatchErr)
+	}
+}
+
 func TestErrMatchNotFound(t *testing.T) {
 	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=976b536446a77de8de2d5559c78f612970fb5e37,https://github.com/gorilla/mux/blob/976b536446a77de8de2d5559c78f612970fb5e37/mux_test.go
976b536446a77de8de2d5559c78f612970fb5e37,b6582dae2201d75e70fdf3bf8df6a6ba864c54a2,route.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,1,1,2,"@@ -87,7 +87,7 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 		return false
 	}
 
-	if match.MatchErr == ErrMethodMismatch && r.handler != nil {
+	if match.MatchErr != nil && r.handler != nil {
 		// We found a route which matches request method, clear MatchErr
 		match.MatchErr = nil
 		// Then override the mis-matched handler",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=976b536446a77de8de2d5559c78f612970fb5e37,https://github.com/gorilla/mux/blob/976b536446a77de8de2d5559c78f612970fb5e37/route.go
2b030fc311d07b8c5950807800b03b2d32a7142c,7f123f0246e7f0bfdcec6ee64f170b3aed5367b8,mux_test.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,17,0,17,"@@ -2784,6 +2784,23 @@ func TestMethodNotAllowed(t *testing.T) {
 	}
 }
 
+func TestMethodNotAllowedSubrouterWithSeveralRoutes(t *testing.T) {
+	handler := func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }
+
+	router := NewRouter()
+	subrouter := router.PathPrefix(""/v1"").Subrouter()
+	subrouter.HandleFunc(""/api"", handler).Methods(http.MethodGet)
+	subrouter.HandleFunc(""/api/{id}"", handler).Methods(http.MethodGet)
+
+	w := NewRecorder()
+	req := newRequest(http.MethodPut, ""/v1/api"")
+	router.ServeHTTP(w, req)
+
+	if w.Code != http.StatusMethodNotAllowed {
+		t.Errorf(""Expected status code 405 (got %d)"", w.Code)
+	}
+}
+
 type customMethodNotAllowedHandler struct {
 	msg string
 }",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=2b030fc311d07b8c5950807800b03b2d32a7142c,https://github.com/gorilla/mux/blob/2b030fc311d07b8c5950807800b03b2d32a7142c/mux_test.go
2b030fc311d07b8c5950807800b03b2d32a7142c,cb89ebb86548e12fb1e421ca908d05496d72353b,route.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,13,10,23,"@@ -53,6 +53,19 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 				continue
 			}
 
+			// Multiple routes may share the same path but use different HTTP methods. For instance:
+			// Route 1: POST ""/users/{id}"".
+			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
+			//
+			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
+			// The router should return a ""Not Found"" error as no route fully matches this request.
+			if rr, ok := m.(*routeRegexp); ok {
+				if rr.regexpType == regexpTypeQuery {
+					matchErr = ErrNotFound
+					break
+				}
+			}
+
 			// Ignore ErrNotFound errors. These errors arise from match call
 			// to Subrouters.
 			//
@@ -66,16 +79,6 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 
 			matchErr = nil // nolint:ineffassign
 			return false
-		} else {
-			// Multiple routes may share the same path but use different HTTP methods. For instance:
-			// Route 1: POST ""/users/{id}"".
-			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
-			//
-			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
-			// The router should return a ""Not Found"" error as no route fully matches this request.
-			if match.MatchErr == ErrMethodMismatch {
-				match.MatchErr = nil
-			}
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=2b030fc311d07b8c5950807800b03b2d32a7142c,https://github.com/gorilla/mux/blob/2b030fc311d07b8c5950807800b03b2d32a7142c/route.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,c1f86ca53e27dad12ea07c101799431393643fbf,bench_test.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,32,0,32,"@@ -21,6 +21,38 @@ func BenchmarkMux(b *testing.B) {
 	}
 }
 
+func BenchmarkMuxSimple(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/status"", handler)
+
+	testCases := []struct {
+		name                 string
+		omitRouteFromContext bool
+	}{
+		{
+			name:                 ""default"",
+			omitRouteFromContext: false,
+		},
+		{
+			name:                 ""omit route from ctx"",
+			omitRouteFromContext: true,
+		},
+	}
+	for _, tc := range testCases {
+		b.Run(tc.name, func(b *testing.B) {
+			router.OmitRouteFromContext(tc.omitRouteFromContext)
+
+			request, _ := http.NewRequest(""GET"", ""/status"", nil)
+			b.ReportAllocs()
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				router.ServeHTTP(nil, request)
+			}
+		})
+	}
+}
+
 func BenchmarkMuxAlternativeInRegexp(b *testing.B) {
 	router := new(Router)
 	handler := func(w http.ResponseWriter, r *http.Request) {}",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/bench_test.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,bcab454cf870433b1ba2c48f4e6952736dcca837,mux.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,45,12,57,"@@ -9,6 +9,7 @@ import (
 	""errors""
 	""fmt""
 	""net/http""
+	""net/url""
 	""path""
 	""regexp""
 )
@@ -84,6 +85,9 @@ type routeConf struct {
 	// will not redirect
 	skipClean bool
 
+	// If true, the http.Request context will not contain the Route.
+	omitRouteFromContext bool
+
 	// Manager for the variables from host and path.
 	regexp routeRegexpGroup
 
@@ -180,15 +184,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		}
 		// Clean path to canonical form and redirect.
 		if p := cleanPath(path); p != path {
-
-			// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
-			// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
-			// http://code.google.com/p/go/issues/detail?id=5252
-			url := *req.URL
-			url.Path = p
-			p = url.String()
-
-			w.Header().Set(""Location"", p)
+			w.Header().Set(""Location"", replaceURLPath(req.URL, p))
 			w.WriteHeader(http.StatusMovedPermanently)
 			return
 		}
@@ -197,8 +193,15 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	var handler http.Handler
 	if r.Match(req, &match) {
 		handler = match.Handler
-		req = requestWithVars(req, match.Vars)
-		req = requestWithRoute(req, match.Route)
+		if handler != nil {
+			// Populate context for custom handlers
+			if r.omitRouteFromContext {
+				// Only populate the match vars (if any) into the context.
+				req = requestWithVars(req, match.Vars)
+			} else {
+				req = requestWithRouteAndVars(req, match.Route, match.Vars)
+			}
+		}
 	}
 
 	if handler == nil && match.MatchErr == ErrMethodMismatch {
@@ -260,6 +263,16 @@ func (r *Router) SkipClean(value bool) *Router {
 	return r
 }
 
+// OmitRouteFromContext defines the behavior of omitting the Route from the
+//
+//	http.Request context.
+//
+// CurrentRoute will yield nil with this option.
+func (r *Router) OmitRouteFromContext(value bool) *Router {
+	r.omitRouteFromContext = value
+	return r
+}
+
 // UseEncodedPath tells the router to match the encoded original path
 // to the routes.
 // For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to"".
@@ -445,13 +458,25 @@ func CurrentRoute(r *http.Request) *Route {
 	return nil
 }
 
+// requestWithRouteAndVars adds the matched vars to the request ctx.
+// It shortcuts the operation when the vars are empty.
 func requestWithVars(r *http.Request, vars map[string]string) *http.Request {
+	if len(vars) == 0 {
+		return r
+	}
 	ctx := context.WithValue(r.Context(), varsKey, vars)
 	return r.WithContext(ctx)
 }
 
-func requestWithRoute(r *http.Request, route *Route) *http.Request {
+// requestWithRouteAndVars adds the matched route and vars to the request ctx.
+// It saves extra allocations in cloning the request once and skipping the
+//
+//	population of empty vars, which in turn mux.Vars can handle gracefully.
+func requestWithRouteAndVars(r *http.Request, route *Route, vars map[string]string) *http.Request {
 	ctx := context.WithValue(r.Context(), routeKey, route)
+	if len(vars) > 0 {
+		ctx = context.WithValue(ctx, varsKey, vars)
+	}
 	return r.WithContext(ctx)
 }
 
@@ -478,6 +503,14 @@ func cleanPath(p string) string {
 	return np
 }
 
+// replaceURLPath prints an url.URL with a different path.
+func replaceURLPath(u *url.URL, p string) string {
+	// Operate on a copy of the request url.
+	u2 := *u
+	u2.Path = p
+	return u2.String()
+}
+
 // uniqueVars returns an error if two slices contain duplicated strings.
 func uniqueVars(s1, s2 []string) error {
 	for _, v1 := range s1 {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/mux.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,cb3bbe0a5eaf58803a115316407871492dc0be86,mux_test.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,186,64,250,"@@ -59,7 +59,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route match"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: true,
@@ -68,7 +68,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, wrong host in request URL"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: false,
@@ -77,7 +77,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, match"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: true,
@@ -86,7 +86,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, wrong port in request URL"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: false,
@@ -95,7 +95,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, match with host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: true,
@@ -104,7 +104,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, wrong host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: false,
@@ -113,7 +113,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, match with request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: true,
@@ -122,7 +122,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, wrong host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: false,
@@ -232,7 +232,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, match"",
 			route:       new(Route).Path(""/111/222/333""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/222/333"",
 			shouldMatch: true,
@@ -241,7 +241,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, match with trailing slash in request and path"",
 			route:       new(Route).Path(""/111/""),
 			request:     newRequest(""GET"", ""http://localhost/111/""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/"",
 			shouldMatch: true,
@@ -250,7 +250,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, do not match with trailing slash in path"",
 			route:        new(Route).Path(""/111/""),
 			request:      newRequest(""GET"", ""http://localhost/111""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/111"",
 			pathTemplate: `/111/`,
@@ -261,7 +261,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, do not match with trailing slash in request"",
 			route:        new(Route).Path(""/111""),
 			request:      newRequest(""GET"", ""http://localhost/111/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/111/"",
 			pathTemplate: `/111`,
@@ -271,7 +271,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, match root with no host"",
 			route:        new(Route).Path(""/""),
 			request:      newRequest(""GET"", ""/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -286,7 +286,7 @@ func TestPath(t *testing.T) {
 				r.RequestURI = ""/""
 				return r
 			}(),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -296,7 +296,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, wrong path in request in request URL"",
 			route:       new(Route).Path(""/111/222/333""),
 			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/222/333"",
 			shouldMatch: false,
@@ -468,7 +468,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, match"",
 			route:       new(Route).PathPrefix(""/111""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111"",
 			shouldMatch: true,
@@ -477,7 +477,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, match substring"",
 			route:       new(Route).PathPrefix(""/1""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/1"",
 			shouldMatch: true,
@@ -486,7 +486,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, URL prefix in request does not match"",
 			route:       new(Route).PathPrefix(""/111""),
 			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111"",
 			shouldMatch: false,
@@ -548,7 +548,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Host and Path route, match"",
 			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -560,7 +560,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Scheme, Host, and Path route, match"",
 			route:        new(Route).Schemes(""https"").Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""https://aaa.bbb.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""https"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -572,7 +572,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Host and Path route, wrong host in request URL"",
 			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -669,7 +669,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, match"",
 			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -678,7 +678,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, bad header values"",
 			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -687,7 +687,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, regex header values to match"",
 			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baw""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -696,7 +696,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, regex header values to match"",
 			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baz""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -717,7 +717,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, match GET"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""GET"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -727,7 +727,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, match POST"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""POST"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -737,7 +737,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, bad method"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""PUT"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -747,7 +747,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Route without methods"",
 			route:       new(Route),
 			request:     newRequest(""PUT"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{},
@@ -770,7 +770,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -782,7 +782,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match with a query string"",
 			route:           new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -796,7 +796,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match with a query string out of order"",
 			route:           new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -810,7 +810,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, bad query"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar,baz=ding"",
@@ -857,7 +857,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=a""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]+}"",
@@ -892,7 +892,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern with quantifier, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=12""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]{1}}"",
@@ -915,7 +915,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=12""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]{1}}"",
@@ -974,7 +974,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value, should match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo="",
@@ -986,7 +986,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value and no parameter in request, should not match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo="",
@@ -997,7 +997,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value and empty parameter in request, should match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost?foo=""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo="",
@@ -1009,7 +1009,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with overlapping value, should not match"",
 			route:           new(Route).Queries(""foo"", ""bar""),
 			request:         newRequest(""GET"", ""http://localhost?foo=barfoo""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar"",
@@ -1020,7 +1020,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with no parameter in request, should not match"",
 			route:           new(Route).Queries(""foo"", ""{bar}""),
 			request:         newRequest(""GET"", ""http://localhost""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={bar}"",
@@ -1043,7 +1043,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, bad submatch"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?fffoo=bar&baz=dingggg""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar,baz=ding"",
@@ -1136,7 +1136,7 @@ func TestMatcherFunc(t *testing.T) {
 			title:       ""MatchFunc route, match"",
 			route:       new(Route).MatcherFunc(m),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -1145,7 +1145,7 @@ func TestMatcherFunc(t *testing.T) {
 			title:       ""MatchFunc route, non-match"",
 			route:       new(Route).MatcherFunc(m),
 			request:     newRequest(""GET"", ""http://aaa.222.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -1246,7 +1246,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter3.Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1255,7 +1255,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter3.Path(""""),
 			request:      newRequest(""GET"", ""http://localhost/foo""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo"",
 			pathTemplate: `/foo`,
@@ -1265,7 +1265,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter4.Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/bar/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/bar/"",
 			pathTemplate: `/foo/bar/`,
@@ -1274,7 +1274,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter4.Path(""""),
 			request:      newRequest(""GET"", ""http://localhost/foo/bar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/bar"",
 			pathTemplate: `/foo/bar`,
@@ -1302,7 +1302,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Mismatch method specified on parent route"",
 			route:        new(Route).Methods(""POST"").PathPrefix(""/foo"").Subrouter().Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1312,7 +1312,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Match method specified on parent route"",
 			route:        new(Route).Methods(""POST"").PathPrefix(""/foo"").Subrouter().Path(""/""),
 			request:      newRequest(""POST"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1322,7 +1322,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Mismatch scheme specified on parent route"",
 			route:        new(Route).Schemes(""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1332,7 +1332,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Match scheme specified on parent route"",
 			route:        new(Route).Schemes(""http"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1342,7 +1342,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""No match header specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1352,7 +1352,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Header mismatch value specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequestWithHeaders(""GET"", ""http://localhost/"", ""X-Forwarded-Proto"", ""http""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1362,7 +1362,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Header match value specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequestWithHeaders(""GET"", ""http://localhost/"", ""X-Forwarded-Proto"", ""https""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1372,7 +1372,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query specified on parent route not present"",
 			route:        new(Route).Headers(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1382,7 +1382,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query mismatch value specified on parent route"",
 			route:        new(Route).Queries(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/?key=notfoobar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1392,7 +1392,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query match value specified on subroute"",
 			route:        new(Route).Queries(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/?key=foobar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1473,7 +1473,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Redirect path without slash"",
 			route:          r.NewRoute().Path(""/111/""),
 			request:        newRequest(""GET"", ""http://localhost/111""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111/"",
 			shouldMatch:    true,
@@ -1483,7 +1483,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Do not redirect path with slash"",
 			route:          r.NewRoute().Path(""/111/""),
 			request:        newRequest(""GET"", ""http://localhost/111/""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111/"",
 			shouldMatch:    true,
@@ -1493,7 +1493,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Redirect path with slash"",
 			route:          r.NewRoute().Path(""/111""),
 			request:        newRequest(""GET"", ""http://localhost/111/""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111"",
 			shouldMatch:    true,
@@ -1503,7 +1503,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Do not redirect path without slash"",
 			route:          r.NewRoute().Path(""/111""),
 			request:        newRequest(""GET"", ""http://localhost/111""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111"",
 			shouldMatch:    true,
@@ -1513,7 +1513,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Propagate StrictSlash to subrouters"",
 			route:          r.NewRoute().PathPrefix(""/static/"").Subrouter().Path(""/images/""),
 			request:        newRequest(""GET"", ""http://localhost/static/images""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/static/images/"",
 			shouldMatch:    true,
@@ -1523,7 +1523,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Ignore StrictSlash for path prefix"",
 			route:          r.NewRoute().PathPrefix(""/static/""),
 			request:        newRequest(""GET"", ""http://localhost/static/logo.png""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/static/"",
 			shouldMatch:    true,
@@ -2913,6 +2913,128 @@ func TestGetVarNames(t *testing.T) {
 	}
 }
 
+func getPopulateContextTestCases() []struct {
+	name                 string
+	path                 string
+	omitRouteFromContext bool
+	wantVar              string
+	wantStaticRoute      bool
+	wantDynamicRoute     bool
+} {
+	return []struct {
+		name                 string
+		path                 string
+		omitRouteFromContext bool
+		wantVar              string
+		wantStaticRoute      bool
+		wantDynamicRoute     bool
+	}{
+		{
+			name:            ""no populated vars"",
+			path:            ""/static"",
+			wantVar:         """",
+			wantStaticRoute: true,
+		},
+		{
+			name:             ""empty var"",
+			path:             ""/dynamic/"",
+			wantVar:          """",
+			wantDynamicRoute: true,
+		},
+		{
+			name:             ""populated vars"",
+			path:             ""/dynamic/foo"",
+			wantVar:          ""foo"",
+			wantDynamicRoute: true,
+		},
+		{
+			name:                 ""omit route /static"",
+			path:                 ""/static"",
+			omitRouteFromContext: true,
+			wantVar:              """",
+			wantStaticRoute:      false,
+		},
+		{
+			name:                 ""omit route /dynamic"",
+			path:                 ""/dynamic/"",
+			omitRouteFromContext: true,
+			wantVar:              """",
+			wantDynamicRoute:     false,
+		},
+	}
+}
+
+func TestPopulateContext(t *testing.T) {
+	testCases := getPopulateContextTestCases()
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			matched := false
+			r := NewRouter()
+			r.OmitRouteFromContext(tc.omitRouteFromContext)
+			var static *Route
+			var dynamic *Route
+			fn := func(w http.ResponseWriter, r *http.Request) {
+				matched = true
+				if got := Vars(r)[""x""]; got != tc.wantVar {
+					t.Fatalf(""wantVar=%q, got=%q"", tc.wantVar, got)
+				}
+				switch {
+				case tc.wantDynamicRoute:
+					r2 := CurrentRoute(r)
+					if r2 != dynamic || r2.GetName() != ""dynamic"" {
+						t.Fatalf(""expected dynmic route in ctx, got %v"", r2)
+					}
+				case tc.wantStaticRoute:
+					r2 := CurrentRoute(r)
+					if r2 != static || r2.GetName() != ""static"" {
+						t.Fatalf(""expected static route in ctx, got %v"", r2)
+					}
+				default:
+					if r2 := CurrentRoute(r); r2 != nil {
+						t.Fatalf(""expected no route in ctx, got %v"", r2)
+					}
+				}
+				w.WriteHeader(http.StatusNoContent)
+			}
+			static = r.Name(""static"").Path(""/static"").HandlerFunc(fn)
+			dynamic = r.Name(""dynamic"").Path(""/dynamic/{x:.*}"").HandlerFunc(fn)
+			req := newRequest(http.MethodGet, ""http://localhost""+tc.path)
+			rec := NewRecorder()
+			r.ServeHTTP(rec, req)
+			if !matched {
+				t.Fatal(""Expected route to match"")
+			}
+		})
+	}
+}
+
+func BenchmarkPopulateContext(b *testing.B) {
+	testCases := getPopulateContextTestCases()
+	for _, tc := range testCases {
+		b.Run(tc.name, func(b *testing.B) {
+			matched := false
+			r := NewRouter()
+			r.OmitRouteFromContext(tc.omitRouteFromContext)
+			fn := func(w http.ResponseWriter, r *http.Request) {
+				matched = true
+				w.WriteHeader(http.StatusNoContent)
+			}
+			r.Name(""static"").Path(""/static"").HandlerFunc(fn)
+			r.Name(""dynamic"").Path(""/dynamic/{x:.*}"").HandlerFunc(fn)
+			req := newRequest(http.MethodGet, ""http://localhost""+tc.path)
+			rec := NewRecorder()
+			b.ReportAllocs()
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				r.ServeHTTP(rec, req)
+			}
+			if !matched {
+				b.Fatal(""Expected route to match"")
+			}
+		})
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/mux_test.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,b577073fa54db7a8d03cc94ff3643ab79b0b5059,regexp.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,40,29,69,"@@ -324,16 +324,18 @@ type routeRegexpGroup struct {
 func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
-		host := getHost(req)
-		if v.host.wildcardHostPort {
-			// Don't be strict on the port match
-			if i := strings.Index(host, "":""); i != -1 {
-				host = host[:i]
+		if len(v.host.varsN) > 0 {
+			host := getHost(req)
+			if v.host.wildcardHostPort {
+				// Don't be strict on the port match
+				if i := strings.Index(host, "":""); i != -1 {
+					host = host[:i]
+				}
+			}
+			matches := v.host.regexp.FindStringSubmatchIndex(host)
+			if len(matches) > 0 {
+				m.Vars = extractVars(host, matches, v.host.varsN, m.Vars)
 			}
-		}
-		matches := v.host.regexp.FindStringSubmatchIndex(host)
-		if len(matches) > 0 {
-			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
 	path := req.URL.Path
@@ -342,31 +344,36 @@ func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	}
 	// Store path variables.
 	if v.path != nil {
-		matches := v.path.regexp.FindStringSubmatchIndex(path)
-		if len(matches) > 0 {
-			extractVars(path, matches, v.path.varsN, m.Vars)
-			// Check if we should redirect.
-			if v.path.options.strictSlash {
-				p1 := strings.HasSuffix(path, ""/"")
-				p2 := strings.HasSuffix(v.path.template, ""/"")
-				if p1 != p2 {
-					u, _ := url.Parse(req.URL.String())
-					if p1 {
-						u.Path = u.Path[:len(u.Path)-1]
-					} else {
-						u.Path += ""/""
-					}
-					m.Handler = http.RedirectHandler(u.String(), http.StatusMovedPermanently)
+		if len(v.path.varsN) > 0 {
+			matches := v.path.regexp.FindStringSubmatchIndex(path)
+			if len(matches) > 0 {
+				m.Vars = extractVars(path, matches, v.path.varsN, m.Vars)
+			}
+		}
+		// Check if we should redirect.
+		if v.path.options.strictSlash {
+			p1 := strings.HasSuffix(path, ""/"")
+			p2 := strings.HasSuffix(v.path.template, ""/"")
+			if p1 != p2 {
+				p := req.URL.Path
+				if p1 {
+					p = p[:len(p)-1]
+				} else {
+					p += ""/""
 				}
+				u := replaceURLPath(req.URL, p)
+				m.Handler = http.RedirectHandler(u, http.StatusMovedPermanently)
 			}
 		}
 	}
 	// Store query string variables.
 	for _, q := range v.queries {
-		queryURL := q.getURLQuery(req)
-		matches := q.regexp.FindStringSubmatchIndex(queryURL)
-		if len(matches) > 0 {
-			extractVars(queryURL, matches, q.varsN, m.Vars)
+		if len(q.varsN) > 0 {
+			queryURL := q.getURLQuery(req)
+			matches := q.regexp.FindStringSubmatchIndex(queryURL)
+			if len(matches) > 0 {
+				m.Vars = extractVars(queryURL, matches, q.varsN, m.Vars)
+			}
 		}
 	}
 }
@@ -381,8 +388,12 @@ func getHost(r *http.Request) string {
 	return r.Host
 }
 
-func extractVars(input string, matches []int, names []string, output map[string]string) {
+func extractVars(input string, matches []int, names []string, output map[string]string) map[string]string {
 	for i, name := range names {
+		if output == nil {
+			output = make(map[string]string, len(names))
+		}
 		output[name] = input[matches[2*i+2]:matches[2*i+3]]
 	}
+	return output
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/regexp.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,8a9e754a38413bae8833cdf31595bf8f75991e83,route.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,0,3,3,"@@ -98,9 +98,6 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if match.Handler == nil {
 		match.Handler = r.handler
 	}
-	if match.Vars == nil {
-		match.Vars = make(map[string]string)
-	}
 
 	// Set variables.
 	r.regexp.setMatch(req, match, r)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/route.go
f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d,c0c37ecac430d3fb1615df736a81da7237f2ec85,mux.go,,"Mon, 13 Nov 2023 04:31:50 GMT",modified,2,2,4,"@@ -233,8 +233,8 @@ func (r *Router) GetRoute(name string) *Route {
 // When false, if the route path is ""/path"", accessing ""/path/"" will not match
 // this route and vice versa.
 //
-// The re-direct is a HTTP 301 (Moved Permanently). Note that when this is set for
-// routes with a non-idempotent method (e.g. POST, PUT), the subsequent re-directed
+// The redirect is a HTTP 301 (Moved Permanently). Note that when this is set for
+// routes with a non-idempotent method (e.g. POST, PUT), the subsequent redirected
 // request will be made as a GET by most clients. Use middleware or client settings
 // to modify this behaviour as needed.
 //",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d,https://github.com/gorilla/mux/blob/f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d/mux.go
b4617d0b9670ad14039b2739167fd35a60f557c5,768b05b3f85986dd4377b89cb91e63af53bfc55a,.github/workflows/issues.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,1,1,2,"@@ -1,4 +1,4 @@
-# Add issues or pull-requests created to the project. 
+# Add all the issues created to the project.
 name: Add issue or pull request to Project
 
 on:",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fissues.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,ff4a613bbfbd483718ef56461b2e45af81efcae8,.github/workflows/security.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",added,37,0,37,"@@ -0,0 +1,37 @@
+name: Security
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+permissions:
+  contents: read
+jobs:
+  scan:
+    strategy:
+      matrix:
+        go: ['1.20','1.21']
+      fail-fast: true
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout Code
+        uses: actions/checkout@v3
+
+      - name: Setup Go ${{ matrix.go }}
+        uses: actions/setup-go@v4
+        with:
+          go-version: ${{ matrix.go }}
+          cache: false
+
+      - name: Run GoSec
+        uses: securego/gosec@master
+        with:
+          args: -exclude-dir examples ./...
+
+      - name: Run GoVulnCheck
+        uses: golang/govulncheck-action@v1
+        with:
+          go-version-input: ${{ matrix.go }}
+          go-package: ./...",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fsecurity.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fsecurity.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,50a3946abf6930ff1448aeedd932ca51e107e68b,.github/workflows/test.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,4,24,28,"@@ -1,20 +1,18 @@
-name: CI
+name: Test
 on:
   push:
     branches:
       - main
   pull_request:
     branches:
       - main
-
 permissions:
   contents: read
-
 jobs:
-  verify-and-test:
+  unit:
     strategy:
       matrix:
-        go: ['1.19','1.20']
+        go: ['1.20','1.21']
         os: [ubuntu-latest, macos-latest, windows-latest]
       fail-fast: true
     runs-on: ${{ matrix.os }}
@@ -28,28 +26,10 @@ jobs:
           go-version: ${{ matrix.go }}
           cache: false
 
-      - name: Run GolangCI-Lint
-        uses: golangci/golangci-lint-action@v3
-        with:
-          version: v1.53
-          args: --timeout=5m
-
-      - name: Run GoSec
-        if: matrix.os == 'ubuntu-latest'
-        uses: securego/gosec@master
-        with:
-          args: ./...
-
-      - name: Run GoVulnCheck
-        uses: golang/govulncheck-action@v1
-        with:
-          go-version-input: ${{ matrix.go }}
-          go-package: ./...
-
       - name: Run Tests
         run: go test -race -cover -coverprofile=coverage -covermode=atomic -v ./...
 
       - name: Upload coverage to Codecov
         uses: codecov/codecov-action@v3
         with:
-          files: ./coverage
\ No newline at end of file
+          files: ./coverage",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Ftest.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Ftest.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,a3eb74b3177fd240a907b1d79203576dca0dae24,.github/workflows/verify.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",added,32,0,32,"@@ -0,0 +1,32 @@
+name: Verify
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+permissions:
+  contents: read
+jobs:
+  lint:
+    strategy:
+      matrix:
+        go: ['1.20','1.21']
+      fail-fast: true
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout Code
+        uses: actions/checkout@v3
+
+      - name: Setup Go ${{ matrix.go }}
+        uses: actions/setup-go@v4
+        with:
+          go-version: ${{ matrix.go }}
+          cache: false
+
+      - name: Run GolangCI-Lint
+        uses: golangci/golangci-lint-action@v3
+        with:
+          version: v1.53
+          args: --timeout=5m",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fverify.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fverify.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,7c6f375b81e8342aa572dd49a404b925a0762a56,go.mod,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,1,1,2,"@@ -1,3 +1,3 @@
 module github.com/gorilla/mux
 
-go 1.19
+go 1.20",https://api.github.com/repos/gorilla/mux/contents/go.mod?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/go.mod
3401478badc7aa55470bc806ee8cd185a16f9298,382513d57c4c6ffd671b8a173beaef1f094e1ec2,README.md,,"Thu, 21 Sep 2023 03:06:08 GMT",modified,13,11,24,"@@ -247,23 +247,25 @@ type spaHandler struct {
 // file located at the index path on the SPA handler will be served. This
 // is suitable behavior for serving an SPA (single page application).
 func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-    // Join internally call path.Clean to prevent directory traversal
-    path := filepath.Join(h.staticPath, path)
+	// Join internally call path.Clean to prevent directory traversal
+	path := filepath.Join(h.staticPath, r.URL.Path)
 
-    // check whether a file exists at the given path
-	_, err := os.Stat(path)
-	if os.IsNotExist(err) {
-		// file does not exist, serve index.html
+	// check whether a file exists or is a directory at the given path
+	fi, err := os.Stat(path)
+	if os.IsNotExist(err) || fi.IsDir() {
+		// file does not exist or path is a directory, serve index.html
 		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))
 		return
-	} else if err != nil {
-        // if we got an error (that wasn't that the file doesn't exist) stating the
-        // file, return a 500 internal server error and stop
+	}
+
+	if err != nil {
+		// if we got an error (that wasn't that the file doesn't exist) stating the
+		// file, return a 500 internal server error and stop
 		http.Error(w, err.Error(), http.StatusInternalServerError)
-		return
+        return
 	}
 
-    // otherwise, use http.FileServer to serve the static dir
+	// otherwise, use http.FileServer to serve the static file
 	http.FileServer(http.Dir(h.staticPath)).ServeHTTP(w, r)
 }
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=3401478badc7aa55470bc806ee8cd185a16f9298,https://github.com/gorilla/mux/blob/3401478badc7aa55470bc806ee8cd185a16f9298/README.md
4a671cbc5162efa2ecb1b353e6a704a62737d66c,87ada8ec271e3381a2c589febf5529bbc2cdff77,README.md,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,13,0,13,"@@ -366,6 +366,19 @@ url, err := r.Get(""article"").URL(""subdomain"", ""news"",
                                  ""id"", ""42"")
 ```
 
+To find all the required variables for a given route when calling `URL()`, the method `GetVarNames()` is available:
+```go
+r := mux.NewRouter()
+r.Host(""{domain}"").
+    Path(""/{group}/{item_id}"").
+    Queries(""some_data1"", ""{some_data1}"").
+    Queries(""some_data2"", ""{some_data2}"").
+    Name(""article"")
+
+// Will print [domain group item_id some_data1 some_data2] <nil>
+fmt.Println(r.Get(""article"").GetVarNames())
+
+```
 ### Walking Routes
 
 The `Walk` function on `mux.Router` can be used to visit all of the routes that are registered on a router. For example,",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/README.md
4a671cbc5162efa2ecb1b353e6a704a62737d66c,428c3b6c2573a429841ad82a1724e3f9fc25bd41,example_route_vars_test.go,,"Thu, 24 Aug 2023 19:57:51 GMT",added,35,0,35,"@@ -0,0 +1,35 @@
+package mux_test
+
+import (
+	""fmt""
+	""github.com/gorilla/mux""
+)
+
+// This example demonstrates building a dynamic URL using
+// required vars and values retrieve from another source
+func ExampleRoute_GetVarNames() {
+	r := mux.NewRouter()
+
+	route := r.Host(""{domain}"").
+		Path(""/{group}/{item_id}"").
+		Queries(""some_data1"", ""{some_data1}"").
+		Queries(""some_data2_and_3"", ""{some_data2}.{some_data3}"")
+
+	dataSource := func(key string) string {
+		return ""my_value_for_"" + key
+	}
+
+	varNames, _ := route.GetVarNames()
+
+	pairs := make([]string, 0, len(varNames)*2)
+
+	for _, varName := range varNames {
+		pairs = append(pairs, varName, dataSource(varName))
+	}
+
+	url, err := route.URL(pairs...)
+	if err != nil {
+		panic(err)
+	}
+	fmt.Println(url.String())
+}",https://api.github.com/repos/gorilla/mux/contents/example_route_vars_test.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/example_route_vars_test.go
4a671cbc5162efa2ecb1b353e6a704a62737d66c,5898688be239818d2014b1ffb0769295adb4c54e,mux_test.go,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,34,0,34,"@@ -2879,6 +2879,40 @@ func TestContextMiddleware(t *testing.T) {
 	r.ServeHTTP(rec, req)
 }
 
+func TestGetVarNames(t *testing.T) {
+	r := NewRouter()
+
+	route := r.Host(""{domain}"").
+		Path(""/{group}/{item_id}"").
+		Queries(""some_data1"", ""{some_data1}"").
+		Queries(""some_data2_and_3"", ""{some_data2}.{some_data3}"")
+
+	// Order of vars in the slice is not guaranteed, so just check for existence
+	expected := map[string]bool{
+		""domain"":     true,
+		""group"":      true,
+		""item_id"":    true,
+		""some_data1"": true,
+		""some_data2"": true,
+		""some_data3"": true,
+	}
+
+	varNames, err := route.GetVarNames()
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	if len(varNames) != len(expected) {
+		t.Fatalf(""expected %d names, got %d"", len(expected), len(varNames))
+	}
+
+	for _, varName := range varNames {
+		if !expected[varName] {
+			t.Fatalf(""got unexpected %s"", varName)
+		}
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/mux_test.go
4a671cbc5162efa2ecb1b353e6a704a62737d66c,e8f11df221f089306926ac23775906a4a50cde62,route.go,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,19,0,19,"@@ -728,6 +728,25 @@ func (r *Route) GetHostTemplate() (string, error) {
 	return r.regexp.host.template, nil
 }
 
+// GetVarNames returns the names of all variables added by regexp matchers
+// These can be used to know which route variables should be passed into r.URL()
+func (r *Route) GetVarNames() ([]string, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	var varNames []string
+	if r.regexp.host != nil {
+		varNames = append(varNames, r.regexp.host.varsN...)
+	}
+	if r.regexp.path != nil {
+		varNames = append(varNames, r.regexp.path.varsN...)
+	}
+	for _, regx := range r.regexp.queries {
+		varNames = append(varNames, regx.varsN...)
+	}
+	return varNames, nil
+}
+
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/route.go
85123bf20e069b156415b871dea10517f6a8938a,9e49b24b880bb11775ecb3f9d881758c736e2b63,README.md,,"Thu, 17 Aug 2023 15:29:52 GMT",modified,2,1,3,"@@ -749,7 +749,8 @@ func TestMetricsHandler(t *testing.T) {
 
         rr := httptest.NewRecorder()
 	
-	// Need to create a router that we can pass the request through so that the vars will be added to the context
+	// To add the vars to the context, 
+	// we need to create a router through which we can pass the request.
 	router := mux.NewRouter()
         router.HandleFunc(""/metrics/{type}"", MetricsHandler)
         router.ServeHTTP(rr, req)",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=85123bf20e069b156415b871dea10517f6a8938a,https://github.com/gorilla/mux/blob/85123bf20e069b156415b871dea10517f6a8938a/README.md
79f2f457ca5017e08de9f86ada03939a82dbf714,cd85f4b382471e5c9c1c7ad707d8856da16beb05,route.go,,"Thu, 17 Aug 2023 04:48:59 GMT",modified,7,7,14,"@@ -240,7 +240,7 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // Headers adds a matcher for request header values.
 // It accepts a sequence of key/value pairs to be matched. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Headers(""Content-Type"", ""application/json"",
 //	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
@@ -265,7 +265,7 @@ func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // HeadersRegexp accepts a sequence of key/value pairs, where the value has regex
 // support. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
 //	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
@@ -293,7 +293,7 @@ func (r *Route) HeadersRegexp(pairs ...string) *Route {
 //
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Host(""www.example.com"")
 //	r.Host(""{subdomain}.domain.com"")
 //	r.Host(""{subdomain:[a-z]+}.domain.com"")
@@ -352,7 +352,7 @@ func (r *Route) Methods(methods ...string) *Route {
 //
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Path(""/products/"").Handler(ProductsHandler)
 //	r.Path(""/products/{key}"").Handler(ProductsHandler)
 //	r.Path(""/articles/{category}/{id:[0-9]+}"").
@@ -387,7 +387,7 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // It accepts a sequence of key/value pairs. Values may define variables.
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
 //
 // The above route will only match if the URL contains the defined queries
@@ -483,7 +483,7 @@ func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
 //
 // It will test the inner routes only if the parent route matched. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	s := r.Host(""www.example.com"").Subrouter()
 //	s.HandleFunc(""/products/"", ProductsHandler)
 //	s.HandleFunc(""/products/{key}"", ProductHandler)
@@ -534,7 +534,7 @@ func (r *Route) Subrouter() *Router {
 // The scheme of the resulting url will be the first argument that was passed to Schemes:
 //
 //	// url.String() will be ""https://example.com""
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	url, err := r.Host(""example.com"")
 //	             .Schemes(""https"", ""http"").URL()
 //",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=79f2f457ca5017e08de9f86ada03939a82dbf714,https://github.com/gorilla/mux/blob/79f2f457ca5017e08de9f86ada03939a82dbf714/route.go
395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,bd97d33b30c71dc1aa65d860319fa1a5c73d0af1,mux_test.go,,"Thu, 17 Aug 2023 01:34:43 GMT",modified,47,0,47,"@@ -2069,6 +2069,53 @@ func TestNoMatchMethodErrorHandler(t *testing.T) {
 	}
 }
 
+func TestMultipleDefinitionOfSamePathWithDifferentMethods(t *testing.T) {
+	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/api"", emptyHandler).Methods(""POST"")
+	r.HandleFunc(""/api"", emptyHandler).Queries(""time"", ""{time:[0-9]+}"").Methods(""GET"")
+
+	t.Run(""Post Method should be matched properly"", func(t *testing.T) {
+		req, _ := http.NewRequest(""POST"", ""http://localhost/api"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if !matched {
+			t.Error(""Should have matched route for methods"")
+		}
+		if match.MatchErr != nil {
+			t.Error(""Should not have any matching error. Found:"", match.MatchErr)
+		}
+	})
+
+	t.Run(""Get Method with invalid query value should not match"", func(t *testing.T) {
+		req, _ := http.NewRequest(""GET"", ""http://localhost/api?time=-4"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if matched {
+			t.Error(""Should not have matched route for methods"")
+		}
+		if match.MatchErr != ErrNotFound {
+			t.Error(""Should have ErrNotFound error. Found:"", match.MatchErr)
+		}
+	})
+
+	t.Run(""A mismach method of a valid path should return ErrMethodMismatch"", func(t *testing.T) {
+		r := NewRouter()
+		r.HandleFunc(""/api2"", emptyHandler).Methods(""POST"")
+		req, _ := http.NewRequest(""GET"", ""http://localhost/api2"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if matched {
+			t.Error(""Should not have matched route for methods"")
+		}
+		if match.MatchErr != ErrMethodMismatch {
+			t.Error(""Should have ErrMethodMismatch error. Found:"", match.MatchErr)
+		}
+	})
+
+}
+
 func TestErrMatchNotFound(t *testing.T) {
 	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,https://github.com/gorilla/mux/blob/395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92/mux_test.go
395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,abea99be68da2256691cf2226150f33c66b280f1,route.go,,"Thu, 17 Aug 2023 01:34:43 GMT",modified,10,0,10,"@@ -66,6 +66,16 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 
 			matchErr = nil // nolint:ineffassign
 			return false
+		} else {
+			// Multiple routes may share the same path but use different HTTP methods. For instance:
+			// Route 1: POST ""/users/{id}"".
+			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
+			//
+			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
+			// The router should return a ""Not Found"" error as no route fully matches this request.
+			if match.MatchErr == ErrMethodMismatch {
+				match.MatchErr = nil
+			}
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,https://github.com/gorilla/mux/blob/395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92/route.go
24c3e7f499efd8b1429cfe789c7e6a3631357045,f3cdc9c48a3f9c2b46eecf58801a35b2b834ac2c,README.md,,"Wed, 16 Aug 2023 02:08:21 GMT",modified,3,12,15,"@@ -247,20 +247,11 @@ type spaHandler struct {
 // file located at the index path on the SPA handler will be served. This
 // is suitable behavior for serving an SPA (single page application).
 func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-    // get the absolute path to prevent directory traversal
-	path, err := filepath.Abs(r.URL.Path)
-	if err != nil {
-        // if we failed to get the absolute path respond with a 400 bad request
-        // and stop
-		http.Error(w, err.Error(), http.StatusBadRequest)
-		return
-	}
-
-    // prepend the path with the path to the static directory
-	path = filepath.Join(h.staticPath, path)
+    // Join internally call path.Clean to prevent directory traversal
+    path := filepath.Join(h.staticPath, path)
 
     // check whether a file exists at the given path
-	_, err = os.Stat(path)
+	_, err := os.Stat(path)
 	if os.IsNotExist(err) {
 		// file does not exist, serve index.html
 		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=24c3e7f499efd8b1429cfe789c7e6a3631357045,https://github.com/gorilla/mux/blob/24c3e7f499efd8b1429cfe789c7e6a3631357045/README.md
