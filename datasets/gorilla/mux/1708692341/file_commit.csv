commit_sha,sha,filename,previous_filename,last_modified,status,additions,deletions,changes,patch,content_url,blob_url
976b536446a77de8de2d5559c78f612970fb5e37,0845d7f7549034cb3c2964f4d454e50aa07c02d4,mux_test.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,18,0,18,"@@ -2116,6 +2116,24 @@ func TestMultipleDefinitionOfSamePathWithDifferentMethods(t *testing.T) {
 
 }
 
+func TestMultipleDefinitionOfSamePathWithDifferentQueries(t *testing.T) {
+	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/api"", emptyHandler).Queries(""foo"", ""{foo:[0-9]+}"").Methods(http.MethodGet)
+	r.HandleFunc(""/api"", emptyHandler).Queries(""bar"", ""{bar:[0-9]+}"").Methods(http.MethodGet)
+
+	req := newRequest(http.MethodGet, ""/api?bar=4"")
+	match := new(RouteMatch)
+	matched := r.Match(req, match)
+	if !matched {
+		t.Error(""Should have matched route for methods"")
+	}
+	if match.MatchErr != nil {
+		t.Error(""Should have no error. Found:"", match.MatchErr)
+	}
+}
+
 func TestErrMatchNotFound(t *testing.T) {
 	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=976b536446a77de8de2d5559c78f612970fb5e37,https://github.com/gorilla/mux/blob/976b536446a77de8de2d5559c78f612970fb5e37/mux_test.go
976b536446a77de8de2d5559c78f612970fb5e37,b6582dae2201d75e70fdf3bf8df6a6ba864c54a2,route.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,1,1,2,"@@ -87,7 +87,7 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 		return false
 	}
 
-	if match.MatchErr == ErrMethodMismatch && r.handler != nil {
+	if match.MatchErr != nil && r.handler != nil {
 		// We found a route which matches request method, clear MatchErr
 		match.MatchErr = nil
 		// Then override the mis-matched handler",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=976b536446a77de8de2d5559c78f612970fb5e37,https://github.com/gorilla/mux/blob/976b536446a77de8de2d5559c78f612970fb5e37/route.go
2b030fc311d07b8c5950807800b03b2d32a7142c,7f123f0246e7f0bfdcec6ee64f170b3aed5367b8,mux_test.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,17,0,17,"@@ -2784,6 +2784,23 @@ func TestMethodNotAllowed(t *testing.T) {
 	}
 }
 
+func TestMethodNotAllowedSubrouterWithSeveralRoutes(t *testing.T) {
+	handler := func(w http.ResponseWriter, r *http.Request) { w.WriteHeader(http.StatusOK) }
+
+	router := NewRouter()
+	subrouter := router.PathPrefix(""/v1"").Subrouter()
+	subrouter.HandleFunc(""/api"", handler).Methods(http.MethodGet)
+	subrouter.HandleFunc(""/api/{id}"", handler).Methods(http.MethodGet)
+
+	w := NewRecorder()
+	req := newRequest(http.MethodPut, ""/v1/api"")
+	router.ServeHTTP(w, req)
+
+	if w.Code != http.StatusMethodNotAllowed {
+		t.Errorf(""Expected status code 405 (got %d)"", w.Code)
+	}
+}
+
 type customMethodNotAllowedHandler struct {
 	msg string
 }",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=2b030fc311d07b8c5950807800b03b2d32a7142c,https://github.com/gorilla/mux/blob/2b030fc311d07b8c5950807800b03b2d32a7142c/mux_test.go
2b030fc311d07b8c5950807800b03b2d32a7142c,cb89ebb86548e12fb1e421ca908d05496d72353b,route.go,,"Mon, 22 Jan 2024 04:09:26 GMT",modified,13,10,23,"@@ -53,6 +53,19 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 				continue
 			}
 
+			// Multiple routes may share the same path but use different HTTP methods. For instance:
+			// Route 1: POST ""/users/{id}"".
+			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
+			//
+			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
+			// The router should return a ""Not Found"" error as no route fully matches this request.
+			if rr, ok := m.(*routeRegexp); ok {
+				if rr.regexpType == regexpTypeQuery {
+					matchErr = ErrNotFound
+					break
+				}
+			}
+
 			// Ignore ErrNotFound errors. These errors arise from match call
 			// to Subrouters.
 			//
@@ -66,16 +79,6 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 
 			matchErr = nil // nolint:ineffassign
 			return false
-		} else {
-			// Multiple routes may share the same path but use different HTTP methods. For instance:
-			// Route 1: POST ""/users/{id}"".
-			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
-			//
-			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
-			// The router should return a ""Not Found"" error as no route fully matches this request.
-			if match.MatchErr == ErrMethodMismatch {
-				match.MatchErr = nil
-			}
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=2b030fc311d07b8c5950807800b03b2d32a7142c,https://github.com/gorilla/mux/blob/2b030fc311d07b8c5950807800b03b2d32a7142c/route.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,c1f86ca53e27dad12ea07c101799431393643fbf,bench_test.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,32,0,32,"@@ -21,6 +21,38 @@ func BenchmarkMux(b *testing.B) {
 	}
 }
 
+func BenchmarkMuxSimple(b *testing.B) {
+	router := new(Router)
+	handler := func(w http.ResponseWriter, r *http.Request) {}
+	router.HandleFunc(""/status"", handler)
+
+	testCases := []struct {
+		name                 string
+		omitRouteFromContext bool
+	}{
+		{
+			name:                 ""default"",
+			omitRouteFromContext: false,
+		},
+		{
+			name:                 ""omit route from ctx"",
+			omitRouteFromContext: true,
+		},
+	}
+	for _, tc := range testCases {
+		b.Run(tc.name, func(b *testing.B) {
+			router.OmitRouteFromContext(tc.omitRouteFromContext)
+
+			request, _ := http.NewRequest(""GET"", ""/status"", nil)
+			b.ReportAllocs()
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				router.ServeHTTP(nil, request)
+			}
+		})
+	}
+}
+
 func BenchmarkMuxAlternativeInRegexp(b *testing.B) {
 	router := new(Router)
 	handler := func(w http.ResponseWriter, r *http.Request) {}",https://api.github.com/repos/gorilla/mux/contents/bench_test.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/bench_test.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,bcab454cf870433b1ba2c48f4e6952736dcca837,mux.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,45,12,57,"@@ -9,6 +9,7 @@ import (
 	""errors""
 	""fmt""
 	""net/http""
+	""net/url""
 	""path""
 	""regexp""
 )
@@ -84,6 +85,9 @@ type routeConf struct {
 	// will not redirect
 	skipClean bool
 
+	// If true, the http.Request context will not contain the Route.
+	omitRouteFromContext bool
+
 	// Manager for the variables from host and path.
 	regexp routeRegexpGroup
 
@@ -180,15 +184,7 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 		}
 		// Clean path to canonical form and redirect.
 		if p := cleanPath(path); p != path {
-
-			// Added 3 lines (Philip Schlump) - It was dropping the query string and #whatever from query.
-			// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
-			// http://code.google.com/p/go/issues/detail?id=5252
-			url := *req.URL
-			url.Path = p
-			p = url.String()
-
-			w.Header().Set(""Location"", p)
+			w.Header().Set(""Location"", replaceURLPath(req.URL, p))
 			w.WriteHeader(http.StatusMovedPermanently)
 			return
 		}
@@ -197,8 +193,15 @@ func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
 	var handler http.Handler
 	if r.Match(req, &match) {
 		handler = match.Handler
-		req = requestWithVars(req, match.Vars)
-		req = requestWithRoute(req, match.Route)
+		if handler != nil {
+			// Populate context for custom handlers
+			if r.omitRouteFromContext {
+				// Only populate the match vars (if any) into the context.
+				req = requestWithVars(req, match.Vars)
+			} else {
+				req = requestWithRouteAndVars(req, match.Route, match.Vars)
+			}
+		}
 	}
 
 	if handler == nil && match.MatchErr == ErrMethodMismatch {
@@ -260,6 +263,16 @@ func (r *Router) SkipClean(value bool) *Router {
 	return r
 }
 
+// OmitRouteFromContext defines the behavior of omitting the Route from the
+//
+//	http.Request context.
+//
+// CurrentRoute will yield nil with this option.
+func (r *Router) OmitRouteFromContext(value bool) *Router {
+	r.omitRouteFromContext = value
+	return r
+}
+
 // UseEncodedPath tells the router to match the encoded original path
 // to the routes.
 // For eg. ""/path/foo%2Fbar/to"" will match the path ""/path/{var}/to"".
@@ -445,13 +458,25 @@ func CurrentRoute(r *http.Request) *Route {
 	return nil
 }
 
+// requestWithRouteAndVars adds the matched vars to the request ctx.
+// It shortcuts the operation when the vars are empty.
 func requestWithVars(r *http.Request, vars map[string]string) *http.Request {
+	if len(vars) == 0 {
+		return r
+	}
 	ctx := context.WithValue(r.Context(), varsKey, vars)
 	return r.WithContext(ctx)
 }
 
-func requestWithRoute(r *http.Request, route *Route) *http.Request {
+// requestWithRouteAndVars adds the matched route and vars to the request ctx.
+// It saves extra allocations in cloning the request once and skipping the
+//
+//	population of empty vars, which in turn mux.Vars can handle gracefully.
+func requestWithRouteAndVars(r *http.Request, route *Route, vars map[string]string) *http.Request {
 	ctx := context.WithValue(r.Context(), routeKey, route)
+	if len(vars) > 0 {
+		ctx = context.WithValue(ctx, varsKey, vars)
+	}
 	return r.WithContext(ctx)
 }
 
@@ -478,6 +503,14 @@ func cleanPath(p string) string {
 	return np
 }
 
+// replaceURLPath prints an url.URL with a different path.
+func replaceURLPath(u *url.URL, p string) string {
+	// Operate on a copy of the request url.
+	u2 := *u
+	u2.Path = p
+	return u2.String()
+}
+
 // uniqueVars returns an error if two slices contain duplicated strings.
 func uniqueVars(s1, s2 []string) error {
 	for _, v1 := range s1 {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/mux.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,cb3bbe0a5eaf58803a115316407871492dc0be86,mux_test.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,186,64,250,"@@ -59,7 +59,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route match"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: true,
@@ -68,7 +68,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, wrong host in request URL"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: false,
@@ -77,7 +77,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, match"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:1234/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: true,
@@ -86,7 +86,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, wrong port in request URL"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc:9999/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: false,
@@ -95,7 +95,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, match with host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: true,
@@ -104,7 +104,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route, wrong host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.222.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc"",
 			path:        """",
 			shouldMatch: false,
@@ -113,7 +113,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, match with request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:1234""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: true,
@@ -122,7 +122,7 @@ func TestHost(t *testing.T) {
 			title:       ""Host route with port, wrong host in request header"",
 			route:       new(Route).Host(""aaa.bbb.ccc:1234""),
 			request:     newRequestHost(""GET"", ""/111/222/333"", ""aaa.bbb.ccc:9999""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        ""aaa.bbb.ccc:1234"",
 			path:        """",
 			shouldMatch: false,
@@ -232,7 +232,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, match"",
 			route:       new(Route).Path(""/111/222/333""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/222/333"",
 			shouldMatch: true,
@@ -241,7 +241,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, match with trailing slash in request and path"",
 			route:       new(Route).Path(""/111/""),
 			request:     newRequest(""GET"", ""http://localhost/111/""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/"",
 			shouldMatch: true,
@@ -250,7 +250,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, do not match with trailing slash in path"",
 			route:        new(Route).Path(""/111/""),
 			request:      newRequest(""GET"", ""http://localhost/111""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/111"",
 			pathTemplate: `/111/`,
@@ -261,7 +261,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, do not match with trailing slash in request"",
 			route:        new(Route).Path(""/111""),
 			request:      newRequest(""GET"", ""http://localhost/111/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/111/"",
 			pathTemplate: `/111`,
@@ -271,7 +271,7 @@ func TestPath(t *testing.T) {
 			title:        ""Path route, match root with no host"",
 			route:        new(Route).Path(""/""),
 			request:      newRequest(""GET"", ""/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -286,7 +286,7 @@ func TestPath(t *testing.T) {
 				r.RequestURI = ""/""
 				return r
 			}(),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -296,7 +296,7 @@ func TestPath(t *testing.T) {
 			title:       ""Path route, wrong path in request in request URL"",
 			route:       new(Route).Path(""/111/222/333""),
 			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111/222/333"",
 			shouldMatch: false,
@@ -468,7 +468,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, match"",
 			route:       new(Route).PathPrefix(""/111""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111"",
 			shouldMatch: true,
@@ -477,7 +477,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, match substring"",
 			route:       new(Route).PathPrefix(""/1""),
 			request:     newRequest(""GET"", ""http://localhost/111/222/333""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/1"",
 			shouldMatch: true,
@@ -486,7 +486,7 @@ func TestPathPrefix(t *testing.T) {
 			title:       ""PathPrefix route, URL prefix in request does not match"",
 			route:       new(Route).PathPrefix(""/111""),
 			request:     newRequest(""GET"", ""http://localhost/1/2/3""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        ""/111"",
 			shouldMatch: false,
@@ -548,7 +548,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Host and Path route, match"",
 			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""http://aaa.bbb.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -560,7 +560,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Scheme, Host, and Path route, match"",
 			route:        new(Route).Schemes(""https"").Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""https://aaa.bbb.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""https"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -572,7 +572,7 @@ func TestSchemeHostPath(t *testing.T) {
 			title:        ""Host and Path route, wrong host in request URL"",
 			route:        new(Route).Host(""aaa.bbb.ccc"").Path(""/111/222/333""),
 			request:      newRequest(""GET"", ""http://aaa.222.ccc/111/222/333""),
-			vars:         map[string]string{},
+			vars:         nil,
 			scheme:       ""http"",
 			host:         ""aaa.bbb.ccc"",
 			path:         ""/111/222/333"",
@@ -669,7 +669,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, match"",
 			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""ding""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -678,7 +678,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, bad header values"",
 			route:       new(Route).Headers(""foo"", ""bar"", ""baz"", ""ding""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""bar"", ""baz"": ""dong""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -687,7 +687,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, regex header values to match"",
 			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baw""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -696,7 +696,7 @@ func TestHeaders(t *testing.T) {
 			title:       ""Headers route, regex header values to match"",
 			route:       new(Route).HeadersRegexp(""foo"", ""ba[zr]""),
 			request:     newRequestHeaders(""GET"", ""http://localhost"", map[string]string{""foo"": ""baz""}),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -717,7 +717,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, match GET"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""GET"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -727,7 +727,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, match POST"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""POST"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -737,7 +737,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Methods route, bad method"",
 			route:       new(Route).Methods(""GET"", ""POST""),
 			request:     newRequest(""PUT"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{""GET"", ""POST""},
@@ -747,7 +747,7 @@ func TestMethods(t *testing.T) {
 			title:       ""Route without methods"",
 			route:       new(Route),
 			request:     newRequest(""PUT"", ""http://localhost""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			methods:     []string{},
@@ -770,7 +770,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=ding""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -782,7 +782,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match with a query string"",
 			route:           new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://www.example.com/api?foo=bar&baz=ding""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -796,7 +796,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, match with a query string out of order"",
 			route:           new(Route).Host(""www.example.com"").Path(""/api"").Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://www.example.com/api?baz=ding&foo=bar""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo=bar&baz=ding"",
@@ -810,7 +810,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, bad query"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar&baz=dong""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar,baz=ding"",
@@ -857,7 +857,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]+}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=a""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]+}"",
@@ -892,7 +892,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern with quantifier, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=12""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]{1}}"",
@@ -915,7 +915,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with regexp pattern with quantifier, additional variable in query string, regexp does not match"",
 			route:           new(Route).Queries(""foo"", ""{v1:[0-9]{1}}""),
 			request:         newRequest(""GET"", ""http://localhost?foo=12""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={v1:[0-9]{1}}"",
@@ -974,7 +974,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value, should match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost?foo=bar""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo="",
@@ -986,7 +986,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value and no parameter in request, should not match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo="",
@@ -997,7 +997,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with empty value and empty parameter in request, should match"",
 			route:           new(Route).Queries(""foo"", """"),
 			request:         newRequest(""GET"", ""http://localhost?foo=""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			query:           ""foo="",
@@ -1009,7 +1009,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with overlapping value, should not match"",
 			route:           new(Route).Queries(""foo"", ""bar""),
 			request:         newRequest(""GET"", ""http://localhost?foo=barfoo""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar"",
@@ -1020,7 +1020,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route with no parameter in request, should not match"",
 			route:           new(Route).Queries(""foo"", ""{bar}""),
 			request:         newRequest(""GET"", ""http://localhost""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo={bar}"",
@@ -1043,7 +1043,7 @@ func TestQueries(t *testing.T) {
 			title:           ""Queries route, bad submatch"",
 			route:           new(Route).Queries(""foo"", ""bar"", ""baz"", ""ding""),
 			request:         newRequest(""GET"", ""http://localhost?fffoo=bar&baz=dingggg""),
-			vars:            map[string]string{},
+			vars:            nil,
 			host:            """",
 			path:            """",
 			queriesTemplate: ""foo=bar,baz=ding"",
@@ -1136,7 +1136,7 @@ func TestMatcherFunc(t *testing.T) {
 			title:       ""MatchFunc route, match"",
 			route:       new(Route).MatcherFunc(m),
 			request:     newRequest(""GET"", ""http://aaa.bbb.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: true,
@@ -1145,7 +1145,7 @@ func TestMatcherFunc(t *testing.T) {
 			title:       ""MatchFunc route, non-match"",
 			route:       new(Route).MatcherFunc(m),
 			request:     newRequest(""GET"", ""http://aaa.222.ccc""),
-			vars:        map[string]string{},
+			vars:        nil,
 			host:        """",
 			path:        """",
 			shouldMatch: false,
@@ -1246,7 +1246,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter3.Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1255,7 +1255,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter3.Path(""""),
 			request:      newRequest(""GET"", ""http://localhost/foo""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo"",
 			pathTemplate: `/foo`,
@@ -1265,7 +1265,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter4.Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/bar/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/bar/"",
 			pathTemplate: `/foo/bar/`,
@@ -1274,7 +1274,7 @@ func TestSubRouter(t *testing.T) {
 		{
 			route:        subrouter4.Path(""""),
 			request:      newRequest(""GET"", ""http://localhost/foo/bar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/bar"",
 			pathTemplate: `/foo/bar`,
@@ -1302,7 +1302,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Mismatch method specified on parent route"",
 			route:        new(Route).Methods(""POST"").PathPrefix(""/foo"").Subrouter().Path(""/""),
 			request:      newRequest(""GET"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1312,7 +1312,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Match method specified on parent route"",
 			route:        new(Route).Methods(""POST"").PathPrefix(""/foo"").Subrouter().Path(""/""),
 			request:      newRequest(""POST"", ""http://localhost/foo/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/foo/"",
 			pathTemplate: `/foo/`,
@@ -1322,7 +1322,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Mismatch scheme specified on parent route"",
 			route:        new(Route).Schemes(""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1332,7 +1332,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Match scheme specified on parent route"",
 			route:        new(Route).Schemes(""http"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1342,7 +1342,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""No match header specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1352,7 +1352,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Header mismatch value specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequestWithHeaders(""GET"", ""http://localhost/"", ""X-Forwarded-Proto"", ""http""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1362,7 +1362,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Header match value specified on parent route"",
 			route:        new(Route).Headers(""X-Forwarded-Proto"", ""https"").Subrouter().PathPrefix(""/""),
 			request:      newRequestWithHeaders(""GET"", ""http://localhost/"", ""X-Forwarded-Proto"", ""https""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1372,7 +1372,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query specified on parent route not present"",
 			route:        new(Route).Headers(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1382,7 +1382,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query mismatch value specified on parent route"",
 			route:        new(Route).Queries(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/?key=notfoobar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1392,7 +1392,7 @@ func TestSubRouter(t *testing.T) {
 			title:        ""Query match value specified on subroute"",
 			route:        new(Route).Queries(""key"", ""foobar"").Subrouter().PathPrefix(""/""),
 			request:      newRequest(""GET"", ""http://localhost/?key=foobar""),
-			vars:         map[string]string{},
+			vars:         nil,
 			host:         """",
 			path:         ""/"",
 			pathTemplate: `/`,
@@ -1473,7 +1473,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Redirect path without slash"",
 			route:          r.NewRoute().Path(""/111/""),
 			request:        newRequest(""GET"", ""http://localhost/111""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111/"",
 			shouldMatch:    true,
@@ -1483,7 +1483,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Do not redirect path with slash"",
 			route:          r.NewRoute().Path(""/111/""),
 			request:        newRequest(""GET"", ""http://localhost/111/""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111/"",
 			shouldMatch:    true,
@@ -1493,7 +1493,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Redirect path with slash"",
 			route:          r.NewRoute().Path(""/111""),
 			request:        newRequest(""GET"", ""http://localhost/111/""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111"",
 			shouldMatch:    true,
@@ -1503,7 +1503,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Do not redirect path without slash"",
 			route:          r.NewRoute().Path(""/111""),
 			request:        newRequest(""GET"", ""http://localhost/111""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/111"",
 			shouldMatch:    true,
@@ -1513,7 +1513,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Propagate StrictSlash to subrouters"",
 			route:          r.NewRoute().PathPrefix(""/static/"").Subrouter().Path(""/images/""),
 			request:        newRequest(""GET"", ""http://localhost/static/images""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/static/images/"",
 			shouldMatch:    true,
@@ -1523,7 +1523,7 @@ func TestStrictSlash(t *testing.T) {
 			title:          ""Ignore StrictSlash for path prefix"",
 			route:          r.NewRoute().PathPrefix(""/static/""),
 			request:        newRequest(""GET"", ""http://localhost/static/logo.png""),
-			vars:           map[string]string{},
+			vars:           nil,
 			host:           """",
 			path:           ""/static/"",
 			shouldMatch:    true,
@@ -2913,6 +2913,128 @@ func TestGetVarNames(t *testing.T) {
 	}
 }
 
+func getPopulateContextTestCases() []struct {
+	name                 string
+	path                 string
+	omitRouteFromContext bool
+	wantVar              string
+	wantStaticRoute      bool
+	wantDynamicRoute     bool
+} {
+	return []struct {
+		name                 string
+		path                 string
+		omitRouteFromContext bool
+		wantVar              string
+		wantStaticRoute      bool
+		wantDynamicRoute     bool
+	}{
+		{
+			name:            ""no populated vars"",
+			path:            ""/static"",
+			wantVar:         """",
+			wantStaticRoute: true,
+		},
+		{
+			name:             ""empty var"",
+			path:             ""/dynamic/"",
+			wantVar:          """",
+			wantDynamicRoute: true,
+		},
+		{
+			name:             ""populated vars"",
+			path:             ""/dynamic/foo"",
+			wantVar:          ""foo"",
+			wantDynamicRoute: true,
+		},
+		{
+			name:                 ""omit route /static"",
+			path:                 ""/static"",
+			omitRouteFromContext: true,
+			wantVar:              """",
+			wantStaticRoute:      false,
+		},
+		{
+			name:                 ""omit route /dynamic"",
+			path:                 ""/dynamic/"",
+			omitRouteFromContext: true,
+			wantVar:              """",
+			wantDynamicRoute:     false,
+		},
+	}
+}
+
+func TestPopulateContext(t *testing.T) {
+	testCases := getPopulateContextTestCases()
+	for _, tc := range testCases {
+		t.Run(tc.name, func(t *testing.T) {
+			matched := false
+			r := NewRouter()
+			r.OmitRouteFromContext(tc.omitRouteFromContext)
+			var static *Route
+			var dynamic *Route
+			fn := func(w http.ResponseWriter, r *http.Request) {
+				matched = true
+				if got := Vars(r)[""x""]; got != tc.wantVar {
+					t.Fatalf(""wantVar=%q, got=%q"", tc.wantVar, got)
+				}
+				switch {
+				case tc.wantDynamicRoute:
+					r2 := CurrentRoute(r)
+					if r2 != dynamic || r2.GetName() != ""dynamic"" {
+						t.Fatalf(""expected dynmic route in ctx, got %v"", r2)
+					}
+				case tc.wantStaticRoute:
+					r2 := CurrentRoute(r)
+					if r2 != static || r2.GetName() != ""static"" {
+						t.Fatalf(""expected static route in ctx, got %v"", r2)
+					}
+				default:
+					if r2 := CurrentRoute(r); r2 != nil {
+						t.Fatalf(""expected no route in ctx, got %v"", r2)
+					}
+				}
+				w.WriteHeader(http.StatusNoContent)
+			}
+			static = r.Name(""static"").Path(""/static"").HandlerFunc(fn)
+			dynamic = r.Name(""dynamic"").Path(""/dynamic/{x:.*}"").HandlerFunc(fn)
+			req := newRequest(http.MethodGet, ""http://localhost""+tc.path)
+			rec := NewRecorder()
+			r.ServeHTTP(rec, req)
+			if !matched {
+				t.Fatal(""Expected route to match"")
+			}
+		})
+	}
+}
+
+func BenchmarkPopulateContext(b *testing.B) {
+	testCases := getPopulateContextTestCases()
+	for _, tc := range testCases {
+		b.Run(tc.name, func(b *testing.B) {
+			matched := false
+			r := NewRouter()
+			r.OmitRouteFromContext(tc.omitRouteFromContext)
+			fn := func(w http.ResponseWriter, r *http.Request) {
+				matched = true
+				w.WriteHeader(http.StatusNoContent)
+			}
+			r.Name(""static"").Path(""/static"").HandlerFunc(fn)
+			r.Name(""dynamic"").Path(""/dynamic/{x:.*}"").HandlerFunc(fn)
+			req := newRequest(http.MethodGet, ""http://localhost""+tc.path)
+			rec := NewRecorder()
+			b.ReportAllocs()
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				r.ServeHTTP(rec, req)
+			}
+			if !matched {
+				b.Fatal(""Expected route to match"")
+			}
+		})
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/mux_test.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,b577073fa54db7a8d03cc94ff3643ab79b0b5059,regexp.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,40,29,69,"@@ -324,16 +324,18 @@ type routeRegexpGroup struct {
 func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
-		host := getHost(req)
-		if v.host.wildcardHostPort {
-			// Don't be strict on the port match
-			if i := strings.Index(host, "":""); i != -1 {
-				host = host[:i]
+		if len(v.host.varsN) > 0 {
+			host := getHost(req)
+			if v.host.wildcardHostPort {
+				// Don't be strict on the port match
+				if i := strings.Index(host, "":""); i != -1 {
+					host = host[:i]
+				}
+			}
+			matches := v.host.regexp.FindStringSubmatchIndex(host)
+			if len(matches) > 0 {
+				m.Vars = extractVars(host, matches, v.host.varsN, m.Vars)
 			}
-		}
-		matches := v.host.regexp.FindStringSubmatchIndex(host)
-		if len(matches) > 0 {
-			extractVars(host, matches, v.host.varsN, m.Vars)
 		}
 	}
 	path := req.URL.Path
@@ -342,31 +344,36 @@ func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	}
 	// Store path variables.
 	if v.path != nil {
-		matches := v.path.regexp.FindStringSubmatchIndex(path)
-		if len(matches) > 0 {
-			extractVars(path, matches, v.path.varsN, m.Vars)
-			// Check if we should redirect.
-			if v.path.options.strictSlash {
-				p1 := strings.HasSuffix(path, ""/"")
-				p2 := strings.HasSuffix(v.path.template, ""/"")
-				if p1 != p2 {
-					u, _ := url.Parse(req.URL.String())
-					if p1 {
-						u.Path = u.Path[:len(u.Path)-1]
-					} else {
-						u.Path += ""/""
-					}
-					m.Handler = http.RedirectHandler(u.String(), http.StatusMovedPermanently)
+		if len(v.path.varsN) > 0 {
+			matches := v.path.regexp.FindStringSubmatchIndex(path)
+			if len(matches) > 0 {
+				m.Vars = extractVars(path, matches, v.path.varsN, m.Vars)
+			}
+		}
+		// Check if we should redirect.
+		if v.path.options.strictSlash {
+			p1 := strings.HasSuffix(path, ""/"")
+			p2 := strings.HasSuffix(v.path.template, ""/"")
+			if p1 != p2 {
+				p := req.URL.Path
+				if p1 {
+					p = p[:len(p)-1]
+				} else {
+					p += ""/""
 				}
+				u := replaceURLPath(req.URL, p)
+				m.Handler = http.RedirectHandler(u, http.StatusMovedPermanently)
 			}
 		}
 	}
 	// Store query string variables.
 	for _, q := range v.queries {
-		queryURL := q.getURLQuery(req)
-		matches := q.regexp.FindStringSubmatchIndex(queryURL)
-		if len(matches) > 0 {
-			extractVars(queryURL, matches, q.varsN, m.Vars)
+		if len(q.varsN) > 0 {
+			queryURL := q.getURLQuery(req)
+			matches := q.regexp.FindStringSubmatchIndex(queryURL)
+			if len(matches) > 0 {
+				m.Vars = extractVars(queryURL, matches, q.varsN, m.Vars)
+			}
 		}
 	}
 }
@@ -381,8 +388,12 @@ func getHost(r *http.Request) string {
 	return r.Host
 }
 
-func extractVars(input string, matches []int, names []string, output map[string]string) {
+func extractVars(input string, matches []int, names []string, output map[string]string) map[string]string {
 	for i, name := range names {
+		if output == nil {
+			output = make(map[string]string, len(names))
+		}
 		output[name] = input[matches[2*i+2]:matches[2*i+3]]
 	}
+	return output
 }",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/regexp.go
e44017df2b8798f6bfff81fff1c0b319c1a54496,8a9e754a38413bae8833cdf31595bf8f75991e83,route.go,,"Thu, 07 Dec 2023 04:58:53 GMT",modified,0,3,3,"@@ -98,9 +98,6 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 	if match.Handler == nil {
 		match.Handler = r.handler
 	}
-	if match.Vars == nil {
-		match.Vars = make(map[string]string)
-	}
 
 	// Set variables.
 	r.regexp.setMatch(req, match, r)",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=e44017df2b8798f6bfff81fff1c0b319c1a54496,https://github.com/gorilla/mux/blob/e44017df2b8798f6bfff81fff1c0b319c1a54496/route.go
f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d,c0c37ecac430d3fb1615df736a81da7237f2ec85,mux.go,,"Mon, 13 Nov 2023 04:31:50 GMT",modified,2,2,4,"@@ -233,8 +233,8 @@ func (r *Router) GetRoute(name string) *Route {
 // When false, if the route path is ""/path"", accessing ""/path/"" will not match
 // this route and vice versa.
 //
-// The re-direct is a HTTP 301 (Moved Permanently). Note that when this is set for
-// routes with a non-idempotent method (e.g. POST, PUT), the subsequent re-directed
+// The redirect is a HTTP 301 (Moved Permanently). Note that when this is set for
+// routes with a non-idempotent method (e.g. POST, PUT), the subsequent redirected
 // request will be made as a GET by most clients. Use middleware or client settings
 // to modify this behaviour as needed.
 //",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d,https://github.com/gorilla/mux/blob/f79c3af9b03521687ad5be6a9d0cf7e9b8207d7d/mux.go
b4617d0b9670ad14039b2739167fd35a60f557c5,768b05b3f85986dd4377b89cb91e63af53bfc55a,.github/workflows/issues.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,1,1,2,"@@ -1,4 +1,4 @@
-# Add issues or pull-requests created to the project. 
+# Add all the issues created to the project.
 name: Add issue or pull request to Project
 
 on:",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fissues.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,ff4a613bbfbd483718ef56461b2e45af81efcae8,.github/workflows/security.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",added,37,0,37,"@@ -0,0 +1,37 @@
+name: Security
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+permissions:
+  contents: read
+jobs:
+  scan:
+    strategy:
+      matrix:
+        go: ['1.20','1.21']
+      fail-fast: true
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout Code
+        uses: actions/checkout@v3
+
+      - name: Setup Go ${{ matrix.go }}
+        uses: actions/setup-go@v4
+        with:
+          go-version: ${{ matrix.go }}
+          cache: false
+
+      - name: Run GoSec
+        uses: securego/gosec@master
+        with:
+          args: -exclude-dir examples ./...
+
+      - name: Run GoVulnCheck
+        uses: golang/govulncheck-action@v1
+        with:
+          go-version-input: ${{ matrix.go }}
+          go-package: ./...",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fsecurity.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fsecurity.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,50a3946abf6930ff1448aeedd932ca51e107e68b,.github/workflows/test.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,4,24,28,"@@ -1,20 +1,18 @@
-name: CI
+name: Test
 on:
   push:
     branches:
       - main
   pull_request:
     branches:
       - main
-
 permissions:
   contents: read
-
 jobs:
-  verify-and-test:
+  unit:
     strategy:
       matrix:
-        go: ['1.19','1.20']
+        go: ['1.20','1.21']
         os: [ubuntu-latest, macos-latest, windows-latest]
       fail-fast: true
     runs-on: ${{ matrix.os }}
@@ -28,28 +26,10 @@ jobs:
           go-version: ${{ matrix.go }}
           cache: false
 
-      - name: Run GolangCI-Lint
-        uses: golangci/golangci-lint-action@v3
-        with:
-          version: v1.53
-          args: --timeout=5m
-
-      - name: Run GoSec
-        if: matrix.os == 'ubuntu-latest'
-        uses: securego/gosec@master
-        with:
-          args: ./...
-
-      - name: Run GoVulnCheck
-        uses: golang/govulncheck-action@v1
-        with:
-          go-version-input: ${{ matrix.go }}
-          go-package: ./...
-
       - name: Run Tests
         run: go test -race -cover -coverprofile=coverage -covermode=atomic -v ./...
 
       - name: Upload coverage to Codecov
         uses: codecov/codecov-action@v3
         with:
-          files: ./coverage
\ No newline at end of file
+          files: ./coverage",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Ftest.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Ftest.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,a3eb74b3177fd240a907b1d79203576dca0dae24,.github/workflows/verify.yml,,"Wed, 18 Oct 2023 11:23:00 GMT",added,32,0,32,"@@ -0,0 +1,32 @@
+name: Verify
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+permissions:
+  contents: read
+jobs:
+  lint:
+    strategy:
+      matrix:
+        go: ['1.20','1.21']
+      fail-fast: true
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout Code
+        uses: actions/checkout@v3
+
+      - name: Setup Go ${{ matrix.go }}
+        uses: actions/setup-go@v4
+        with:
+          go-version: ${{ matrix.go }}
+          cache: false
+
+      - name: Run GolangCI-Lint
+        uses: golangci/golangci-lint-action@v3
+        with:
+          version: v1.53
+          args: --timeout=5m",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fverify.yml?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/.github%2Fworkflows%2Fverify.yml
b4617d0b9670ad14039b2739167fd35a60f557c5,7c6f375b81e8342aa572dd49a404b925a0762a56,go.mod,,"Wed, 18 Oct 2023 11:23:00 GMT",modified,1,1,2,"@@ -1,3 +1,3 @@
 module github.com/gorilla/mux
 
-go 1.19
+go 1.20",https://api.github.com/repos/gorilla/mux/contents/go.mod?ref=b4617d0b9670ad14039b2739167fd35a60f557c5,https://github.com/gorilla/mux/blob/b4617d0b9670ad14039b2739167fd35a60f557c5/go.mod
3401478badc7aa55470bc806ee8cd185a16f9298,382513d57c4c6ffd671b8a173beaef1f094e1ec2,README.md,,"Thu, 21 Sep 2023 03:06:08 GMT",modified,13,11,24,"@@ -247,23 +247,25 @@ type spaHandler struct {
 // file located at the index path on the SPA handler will be served. This
 // is suitable behavior for serving an SPA (single page application).
 func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-    // Join internally call path.Clean to prevent directory traversal
-    path := filepath.Join(h.staticPath, path)
+	// Join internally call path.Clean to prevent directory traversal
+	path := filepath.Join(h.staticPath, r.URL.Path)
 
-    // check whether a file exists at the given path
-	_, err := os.Stat(path)
-	if os.IsNotExist(err) {
-		// file does not exist, serve index.html
+	// check whether a file exists or is a directory at the given path
+	fi, err := os.Stat(path)
+	if os.IsNotExist(err) || fi.IsDir() {
+		// file does not exist or path is a directory, serve index.html
 		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))
 		return
-	} else if err != nil {
-        // if we got an error (that wasn't that the file doesn't exist) stating the
-        // file, return a 500 internal server error and stop
+	}
+
+	if err != nil {
+		// if we got an error (that wasn't that the file doesn't exist) stating the
+		// file, return a 500 internal server error and stop
 		http.Error(w, err.Error(), http.StatusInternalServerError)
-		return
+        return
 	}
 
-    // otherwise, use http.FileServer to serve the static dir
+	// otherwise, use http.FileServer to serve the static file
 	http.FileServer(http.Dir(h.staticPath)).ServeHTTP(w, r)
 }
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=3401478badc7aa55470bc806ee8cd185a16f9298,https://github.com/gorilla/mux/blob/3401478badc7aa55470bc806ee8cd185a16f9298/README.md
4a671cbc5162efa2ecb1b353e6a704a62737d66c,87ada8ec271e3381a2c589febf5529bbc2cdff77,README.md,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,13,0,13,"@@ -366,6 +366,19 @@ url, err := r.Get(""article"").URL(""subdomain"", ""news"",
                                  ""id"", ""42"")
 ```
 
+To find all the required variables for a given route when calling `URL()`, the method `GetVarNames()` is available:
+```go
+r := mux.NewRouter()
+r.Host(""{domain}"").
+    Path(""/{group}/{item_id}"").
+    Queries(""some_data1"", ""{some_data1}"").
+    Queries(""some_data2"", ""{some_data2}"").
+    Name(""article"")
+
+// Will print [domain group item_id some_data1 some_data2] <nil>
+fmt.Println(r.Get(""article"").GetVarNames())
+
+```
 ### Walking Routes
 
 The `Walk` function on `mux.Router` can be used to visit all of the routes that are registered on a router. For example,",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/README.md
4a671cbc5162efa2ecb1b353e6a704a62737d66c,428c3b6c2573a429841ad82a1724e3f9fc25bd41,example_route_vars_test.go,,"Thu, 24 Aug 2023 19:57:51 GMT",added,35,0,35,"@@ -0,0 +1,35 @@
+package mux_test
+
+import (
+	""fmt""
+	""github.com/gorilla/mux""
+)
+
+// This example demonstrates building a dynamic URL using
+// required vars and values retrieve from another source
+func ExampleRoute_GetVarNames() {
+	r := mux.NewRouter()
+
+	route := r.Host(""{domain}"").
+		Path(""/{group}/{item_id}"").
+		Queries(""some_data1"", ""{some_data1}"").
+		Queries(""some_data2_and_3"", ""{some_data2}.{some_data3}"")
+
+	dataSource := func(key string) string {
+		return ""my_value_for_"" + key
+	}
+
+	varNames, _ := route.GetVarNames()
+
+	pairs := make([]string, 0, len(varNames)*2)
+
+	for _, varName := range varNames {
+		pairs = append(pairs, varName, dataSource(varName))
+	}
+
+	url, err := route.URL(pairs...)
+	if err != nil {
+		panic(err)
+	}
+	fmt.Println(url.String())
+}",https://api.github.com/repos/gorilla/mux/contents/example_route_vars_test.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/example_route_vars_test.go
4a671cbc5162efa2ecb1b353e6a704a62737d66c,5898688be239818d2014b1ffb0769295adb4c54e,mux_test.go,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,34,0,34,"@@ -2879,6 +2879,40 @@ func TestContextMiddleware(t *testing.T) {
 	r.ServeHTTP(rec, req)
 }
 
+func TestGetVarNames(t *testing.T) {
+	r := NewRouter()
+
+	route := r.Host(""{domain}"").
+		Path(""/{group}/{item_id}"").
+		Queries(""some_data1"", ""{some_data1}"").
+		Queries(""some_data2_and_3"", ""{some_data2}.{some_data3}"")
+
+	// Order of vars in the slice is not guaranteed, so just check for existence
+	expected := map[string]bool{
+		""domain"":     true,
+		""group"":      true,
+		""item_id"":    true,
+		""some_data1"": true,
+		""some_data2"": true,
+		""some_data3"": true,
+	}
+
+	varNames, err := route.GetVarNames()
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	if len(varNames) != len(expected) {
+		t.Fatalf(""expected %d names, got %d"", len(expected), len(varNames))
+	}
+
+	for _, varName := range varNames {
+		if !expected[varName] {
+			t.Fatalf(""got unexpected %s"", varName)
+		}
+	}
+}
+
 // mapToPairs converts a string map to a slice of string pairs
 func mapToPairs(m map[string]string) []string {
 	var i int",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/mux_test.go
4a671cbc5162efa2ecb1b353e6a704a62737d66c,e8f11df221f089306926ac23775906a4a50cde62,route.go,,"Thu, 24 Aug 2023 19:57:51 GMT",modified,19,0,19,"@@ -728,6 +728,25 @@ func (r *Route) GetHostTemplate() (string, error) {
 	return r.regexp.host.template, nil
 }
 
+// GetVarNames returns the names of all variables added by regexp matchers
+// These can be used to know which route variables should be passed into r.URL()
+func (r *Route) GetVarNames() ([]string, error) {
+	if r.err != nil {
+		return nil, r.err
+	}
+	var varNames []string
+	if r.regexp.host != nil {
+		varNames = append(varNames, r.regexp.host.varsN...)
+	}
+	if r.regexp.path != nil {
+		varNames = append(varNames, r.regexp.path.varsN...)
+	}
+	for _, regx := range r.regexp.queries {
+		varNames = append(varNames, regx.varsN...)
+	}
+	return varNames, nil
+}
+
 // prepareVars converts the route variable pairs into a map. If the route has a
 // BuildVarsFunc, it is invoked.
 func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=4a671cbc5162efa2ecb1b353e6a704a62737d66c,https://github.com/gorilla/mux/blob/4a671cbc5162efa2ecb1b353e6a704a62737d66c/route.go
85123bf20e069b156415b871dea10517f6a8938a,9e49b24b880bb11775ecb3f9d881758c736e2b63,README.md,,"Thu, 17 Aug 2023 15:29:52 GMT",modified,2,1,3,"@@ -749,7 +749,8 @@ func TestMetricsHandler(t *testing.T) {
 
         rr := httptest.NewRecorder()
 	
-	// Need to create a router that we can pass the request through so that the vars will be added to the context
+	// To add the vars to the context, 
+	// we need to create a router through which we can pass the request.
 	router := mux.NewRouter()
         router.HandleFunc(""/metrics/{type}"", MetricsHandler)
         router.ServeHTTP(rr, req)",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=85123bf20e069b156415b871dea10517f6a8938a,https://github.com/gorilla/mux/blob/85123bf20e069b156415b871dea10517f6a8938a/README.md
79f2f457ca5017e08de9f86ada03939a82dbf714,cd85f4b382471e5c9c1c7ad707d8856da16beb05,route.go,,"Thu, 17 Aug 2023 04:48:59 GMT",modified,7,7,14,"@@ -240,7 +240,7 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // Headers adds a matcher for request header values.
 // It accepts a sequence of key/value pairs to be matched. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Headers(""Content-Type"", ""application/json"",
 //	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
@@ -265,7 +265,7 @@ func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // HeadersRegexp accepts a sequence of key/value pairs, where the value has regex
 // support. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
 //	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
@@ -293,7 +293,7 @@ func (r *Route) HeadersRegexp(pairs ...string) *Route {
 //
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Host(""www.example.com"")
 //	r.Host(""{subdomain}.domain.com"")
 //	r.Host(""{subdomain:[a-z]+}.domain.com"")
@@ -352,7 +352,7 @@ func (r *Route) Methods(methods ...string) *Route {
 //
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Path(""/products/"").Handler(ProductsHandler)
 //	r.Path(""/products/{key}"").Handler(ProductsHandler)
 //	r.Path(""/articles/{category}/{id:[0-9]+}"").
@@ -387,7 +387,7 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // It accepts a sequence of key/value pairs. Values may define variables.
 // For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
 //
 // The above route will only match if the URL contains the defined queries
@@ -483,7 +483,7 @@ func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
 //
 // It will test the inner routes only if the parent route matched. For example:
 //
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	s := r.Host(""www.example.com"").Subrouter()
 //	s.HandleFunc(""/products/"", ProductsHandler)
 //	s.HandleFunc(""/products/{key}"", ProductHandler)
@@ -534,7 +534,7 @@ func (r *Route) Subrouter() *Router {
 // The scheme of the resulting url will be the first argument that was passed to Schemes:
 //
 //	// url.String() will be ""https://example.com""
-//	r := mux.NewRouter()
+//	r := mux.NewRouter().NewRoute()
 //	url, err := r.Host(""example.com"")
 //	             .Schemes(""https"", ""http"").URL()
 //",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=79f2f457ca5017e08de9f86ada03939a82dbf714,https://github.com/gorilla/mux/blob/79f2f457ca5017e08de9f86ada03939a82dbf714/route.go
395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,bd97d33b30c71dc1aa65d860319fa1a5c73d0af1,mux_test.go,,"Thu, 17 Aug 2023 01:34:43 GMT",modified,47,0,47,"@@ -2069,6 +2069,53 @@ func TestNoMatchMethodErrorHandler(t *testing.T) {
 	}
 }
 
+func TestMultipleDefinitionOfSamePathWithDifferentMethods(t *testing.T) {
+	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
+
+	r := NewRouter()
+	r.HandleFunc(""/api"", emptyHandler).Methods(""POST"")
+	r.HandleFunc(""/api"", emptyHandler).Queries(""time"", ""{time:[0-9]+}"").Methods(""GET"")
+
+	t.Run(""Post Method should be matched properly"", func(t *testing.T) {
+		req, _ := http.NewRequest(""POST"", ""http://localhost/api"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if !matched {
+			t.Error(""Should have matched route for methods"")
+		}
+		if match.MatchErr != nil {
+			t.Error(""Should not have any matching error. Found:"", match.MatchErr)
+		}
+	})
+
+	t.Run(""Get Method with invalid query value should not match"", func(t *testing.T) {
+		req, _ := http.NewRequest(""GET"", ""http://localhost/api?time=-4"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if matched {
+			t.Error(""Should not have matched route for methods"")
+		}
+		if match.MatchErr != ErrNotFound {
+			t.Error(""Should have ErrNotFound error. Found:"", match.MatchErr)
+		}
+	})
+
+	t.Run(""A mismach method of a valid path should return ErrMethodMismatch"", func(t *testing.T) {
+		r := NewRouter()
+		r.HandleFunc(""/api2"", emptyHandler).Methods(""POST"")
+		req, _ := http.NewRequest(""GET"", ""http://localhost/api2"", nil)
+		match := new(RouteMatch)
+		matched := r.Match(req, match)
+		if matched {
+			t.Error(""Should not have matched route for methods"")
+		}
+		if match.MatchErr != ErrMethodMismatch {
+			t.Error(""Should have ErrMethodMismatch error. Found:"", match.MatchErr)
+		}
+	})
+
+}
+
 func TestErrMatchNotFound(t *testing.T) {
 	emptyHandler := func(w http.ResponseWriter, r *http.Request) {}
 ",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,https://github.com/gorilla/mux/blob/395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92/mux_test.go
395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,abea99be68da2256691cf2226150f33c66b280f1,route.go,,"Thu, 17 Aug 2023 01:34:43 GMT",modified,10,0,10,"@@ -66,6 +66,16 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 
 			matchErr = nil // nolint:ineffassign
 			return false
+		} else {
+			// Multiple routes may share the same path but use different HTTP methods. For instance:
+			// Route 1: POST ""/users/{id}"".
+			// Route 2: GET ""/users/{id}"", parameters: ""id"": ""[0-9]+"".
+			//
+			// The router must handle these cases correctly. For a GET request to ""/users/abc"" with ""id"" as ""-2"",
+			// The router should return a ""Not Found"" error as no route fully matches this request.
+			if match.MatchErr == ErrMethodMismatch {
+				match.MatchErr = nil
+			}
 		}
 	}
 ",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92,https://github.com/gorilla/mux/blob/395ad81d0ebffa0c5a36f3e5a2e720a7d5870d92/route.go
24c3e7f499efd8b1429cfe789c7e6a3631357045,f3cdc9c48a3f9c2b46eecf58801a35b2b834ac2c,README.md,,"Wed, 16 Aug 2023 02:08:21 GMT",modified,3,12,15,"@@ -247,20 +247,11 @@ type spaHandler struct {
 // file located at the index path on the SPA handler will be served. This
 // is suitable behavior for serving an SPA (single page application).
 func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
-    // get the absolute path to prevent directory traversal
-	path, err := filepath.Abs(r.URL.Path)
-	if err != nil {
-        // if we failed to get the absolute path respond with a 400 bad request
-        // and stop
-		http.Error(w, err.Error(), http.StatusBadRequest)
-		return
-	}
-
-    // prepend the path with the path to the static directory
-	path = filepath.Join(h.staticPath, path)
+    // Join internally call path.Clean to prevent directory traversal
+    path := filepath.Join(h.staticPath, path)
 
     // check whether a file exists at the given path
-	_, err = os.Stat(path)
+	_, err := os.Stat(path)
 	if os.IsNotExist(err) {
 		// file does not exist, serve index.html
 		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=24c3e7f499efd8b1429cfe789c7e6a3631357045,https://github.com/gorilla/mux/blob/24c3e7f499efd8b1429cfe789c7e6a3631357045/README.md
546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4,80601351fd071c44b7c0a740e7d3a55520adcfc8,doc.go,,"Mon, 31 Jul 2023 01:44:28 GMT",modified,12,13,25,"@@ -10,18 +10,18 @@ http.ServeMux, mux.Router matches incoming requests against a list of
 registered routes and calls a handler for the route that matches the URL
 or other conditions. The main features are:
 
-	* Requests can be matched based on URL host, path, path prefix, schemes,
-	  header and query values, HTTP methods or using custom matchers.
-	* URL hosts, paths and query values can have variables with an optional
-	  regular expression.
-	* Registered URLs can be built, or ""reversed"", which helps maintaining
-	  references to resources.
-	* Routes can be used as subrouters: nested routes are only tested if the
-	  parent route matches. This is useful to define groups of routes that
-	  share common conditions like a host, a path prefix or other repeated
-	  attributes. As a bonus, this optimizes request matching.
-	* It implements the http.Handler interface so it is compatible with the
-	  standard http.ServeMux.
+  - Requests can be matched based on URL host, path, path prefix, schemes,
+    header and query values, HTTP methods or using custom matchers.
+  - URL hosts, paths and query values can have variables with an optional
+    regular expression.
+  - Registered URLs can be built, or ""reversed"", which helps maintaining
+    references to resources.
+  - Routes can be used as subrouters: nested routes are only tested if the
+    parent route matches. This is useful to define groups of routes that
+    share common conditions like a host, a path prefix or other repeated
+    attributes. As a bonus, this optimizes request matching.
+  - It implements the http.Handler interface so it is compatible with the
+    standard http.ServeMux.
 
 Let's start registering a couple of URL paths and handlers:
 
@@ -301,6 +301,5 @@ A more complex authentication middleware, which maps session token to users, cou
 	r.Use(amw.Middleware)
 
 Note: The handler chain will be stopped if your middleware doesn't call `next.ServeHTTP()` with the corresponding parameters. This can be used to abort a request if the middleware writer wants to.
-
 */
 package mux",https://api.github.com/repos/gorilla/mux/contents/doc.go?ref=546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4,https://github.com/gorilla/mux/blob/546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4/doc.go
546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4,1e089906fad5715477ba0c785562a43f0d987a8a,mux.go,,"Mon, 31 Jul 2023 01:44:28 GMT",modified,7,7,14,"@@ -31,17 +31,17 @@ func NewRouter() *Router {
 // It implements the http.Handler interface, so it can be registered to serve
 // requests:
 //
-//     var router = mux.NewRouter()
+//	var router = mux.NewRouter()
 //
-//     func main() {
-//         http.Handle(""/"", router)
-//     }
+//	func main() {
+//	    http.Handle(""/"", router)
+//	}
 //
 // Or, for Google App Engine, register it in a init() function:
 //
-//     func init() {
-//         http.Handle(""/"", router)
-//     }
+//	func init() {
+//	    http.Handle(""/"", router)
+//	}
 //
 // This will send all incoming requests to the router.
 type Router struct {",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4,https://github.com/gorilla/mux/blob/546dd0cc9f3ecdef8b065ac6336b4c6ed99887d4/mux.go
651928c42f7b60c7942e46d5f651dd1ece444246,8be6cedb260adf9827964b68e26e33eca59268a8,.github/workflows/issues.yml,,"Sun, 30 Jul 2023 16:37:42 GMT",modified,1,0,1,"@@ -8,6 +8,7 @@ on:
   pull_request_target:
     types:
       - opened
+      - reopened
 
 jobs:
   add-to-project:",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=651928c42f7b60c7942e46d5f651dd1ece444246,https://github.com/gorilla/mux/blob/651928c42f7b60c7942e46d5f651dd1ece444246/.github%2Fworkflows%2Fissues.yml
cfc696d6d239ff68ceb71ee35c9a4e4ef3f30ed9,ff9e3183e38af95a22603f0e6f1167c8a28836db,.github/workflows/issues.yml,,"Sun, 30 Jul 2023 16:23:57 GMT",modified,2,2,4,"@@ -5,7 +5,7 @@ on:
   issues:
     types:
       - opened
-  pull_request:
+  pull_request_target:
     types:
       - opened
 
@@ -17,4 +17,4 @@ jobs:
         uses: actions/add-to-project@v0.5.0
         with:
           project-url: https://github.com/orgs/gorilla/projects/4
-          github-token: ${{ secrets.ADD_TO_PROJECT_TOKEN }}
\ No newline at end of file
+          github-token: ${{ secrets.ADD_TO_PROJECT_TOKEN }}",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=cfc696d6d239ff68ceb71ee35c9a4e4ef3f30ed9,https://github.com/gorilla/mux/blob/cfc696d6d239ff68ceb71ee35c9a4e4ef3f30ed9/.github%2Fworkflows%2Fissues.yml
809d12850fc170caa4229eb2da58a4701c9837b8,bb9d80bc9b6bc381c1e0edc7b76683cc621b3183,LICENSE,,"Tue, 25 Jul 2023 17:19:44 GMT",modified,24,10,34,"@@ -1,13 +1,27 @@
-BSD 3-Clause License
+Copyright (c) 2023 The Gorilla Authors. All rights reserved.
 
-Copyright 2023 Gorilla web toolkit contributors
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
 
-Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+	 * Redistributions of source code must retain the above copyright
+notice, this list of conditions and the following disclaimer.
+	 * Redistributions in binary form must reproduce the above
+copyright notice, this list of conditions and the following disclaimer
+in the documentation and/or other materials provided with the
+distribution.
+	 * Neither the name of Google Inc. nor the names of its
+contributors may be used to endorse or promote products derived from
+this software without specific prior written permission.
 
-1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
-
-3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",https://api.github.com/repos/gorilla/mux/contents/LICENSE?ref=809d12850fc170caa4229eb2da58a4701c9837b8,https://github.com/gorilla/mux/blob/809d12850fc170caa4229eb2da58a4701c9837b8/LICENSE
753457f3059d3db9a96f9f4c67d7f3724e97478d,4553c1fe6be67345ce17e2d9392e6f7a30d43016,README.md,,"Tue, 25 Jul 2023 16:35:16 GMT",modified,1,1,2,"@@ -6,7 +6,7 @@
 [![sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
 
 
-![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
+![Gorilla Logo](https://github.com/gorilla/.github/assets/53367916/d92caabf-98e0-473e-bfbf-ab554ba435e5)
 
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=753457f3059d3db9a96f9f4c67d7f3724e97478d,https://github.com/gorilla/mux/blob/753457f3059d3db9a96f9f4c67d7f3724e97478d/README.md
ff63d0e2fd6b3634b25a63c85c27a3dc80a3b8c8,1cedc459d8fe35ca3059883a8240f81bf6f87cd7,LICENSE,,"Sun, 23 Jul 2023 20:32:33 GMT",modified,10,24,34,"@@ -1,27 +1,13 @@
-Copyright (c) 2012-2018 The Gorilla Authors. All rights reserved.
+BSD 3-Clause License
 
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
+Copyright 2023 Gorilla web toolkit contributors
 
-	 * Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-	 * Redistributions in binary form must reproduce the above
-copyright notice, this list of conditions and the following disclaimer
-in the documentation and/or other materials provided with the
-distribution.
-	 * Neither the name of Google Inc. nor the names of its
-contributors may be used to endorse or promote products derived from
-this software without specific prior written permission.
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",https://api.github.com/repos/gorilla/mux/contents/LICENSE?ref=ff63d0e2fd6b3634b25a63c85c27a3dc80a3b8c8,https://github.com/gorilla/mux/blob/ff63d0e2fd6b3634b25a63c85c27a3dc80a3b8c8/LICENSE
2392d7d19e8c3b02af216a404709415813467766,b722392ee59266773c107a8e871d6b2a3085cb7c,AUTHORS,,"Sun, 23 Jul 2023 20:29:12 GMT",removed,0,8,8,"@@ -1,8 +0,0 @@
-# This is the official list of gorilla/mux authors for copyright purposes.
-#
-# Please keep the list sorted.
-
-Google LLC (https://opensource.google.com/)
-Kamil Kisielk <kamil@kamilkisiel.net>
-Matt Silverlock <matt@eatsleeprepeat.net>
-Rodrigo Moraes (https://github.com/moraes)",https://api.github.com/repos/gorilla/mux/contents/AUTHORS?ref=81b48a39f012296f51d582d3cefaaba1c2f5a01f,https://github.com/gorilla/mux/blob/81b48a39f012296f51d582d3cefaaba1c2f5a01f/AUTHORS
81b48a39f012296f51d582d3cefaaba1c2f5a01f,f4b12d30baf37382ec63e7a309bcab4d48c7ec41,.github/stale.yml,,"Sun, 23 Jul 2023 20:28:38 GMT",removed,0,12,12,"@@ -1,12 +0,0 @@
-daysUntilStale: 75
-daysUntilClose: 14
-# Issues with these labels will never be considered stale
-exemptLabels:
-  - proposal
-  - needs review
-  - build system
-staleLabel: stale
-markComment: >
-  This issue has been automatically marked as stale because it hasn't seen
-  a recent update. It'll be automatically closed in a few days.
-closeComment: false",https://api.github.com/repos/gorilla/mux/contents/.github%2Fstale.yml?ref=96847b8b06f990d7b53c8a5c647ee73d3e70582a,https://github.com/gorilla/mux/blob/96847b8b06f990d7b53c8a5c647ee73d3e70582a/.github%2Fstale.yml
96847b8b06f990d7b53c8a5c647ee73d3e70582a,2db2e1397ec7b63ebe94d7536548cba72f20e7bd,.github/release-drafter.yml,,"Sun, 23 Jul 2023 20:27:23 GMT",removed,0,8,8,"@@ -1,8 +0,0 @@
-# Config for https://github.com/apps/release-drafter
-template: |
-  
-  <summary of changes here>
-  
-  ## CHANGELOG
-
-  $CHANGES",https://api.github.com/repos/gorilla/mux/contents/.github%2Frelease-drafter.yml?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.github%2Frelease-drafter.yml
1fa2ee87bf61940bfac616e98513448af97a1813,ead3e1d49f7f1ee53f8f75746355afef2498d643,.circleci/config.yml,,"Sun, 23 Jul 2023 20:15:04 GMT",removed,0,70,70,"@@ -1,70 +0,0 @@
-version: 2.1
-
-jobs:
-  ""test"":
-    parameters:
-      version:
-        type: string
-        default: ""latest""
-      golint:
-        type: boolean
-        default: true
-      modules:
-        type: boolean
-        default: true
-      goproxy:
-        type: string
-        default: """"
-    docker:
-      - image: ""circleci/golang:<< parameters.version >>""
-    working_directory: /go/src/github.com/gorilla/mux
-    environment:
-      GO111MODULE: ""on""
-      GOPROXY: ""<< parameters.goproxy >>""
-    steps:
-      - checkout
-      - run:
-          name: ""Print the Go version""
-          command: >
-            go version
-      - run:
-          name: ""Fetch dependencies""
-          command: >
-            if [[ << parameters.modules >> = true ]]; then
-              go mod download
-              export GO111MODULE=on
-            else
-              go get -v ./...
-            fi
-      # Only run gofmt, vet & lint against the latest Go version
-      - run:
-          name: ""Run golint""
-          command: >
-            if [ << parameters.version >> = ""latest"" ] && [ << parameters.golint >> = true ]; then
-              go get -u golang.org/x/lint/golint
-              golint ./...
-            fi
-      - run:
-          name: ""Run gofmt""
-          command: >
-            if [[ << parameters.version >> = ""latest"" ]]; then
-              diff -u <(echo -n) <(gofmt -d -e .)
-            fi
-      - run:
-          name: ""Run go vet""
-          command: >
-            if [[ << parameters.version >> = ""latest"" ]]; then
-              go vet -v ./...
-            fi
-      - run:
-          name: ""Run go test (+ race detector)""
-          command: >
-            go test -v -race ./...
-
-workflows:
-  tests:
-    jobs:
-      - test:
-          matrix:
-            parameters:
-              version: [""latest"", ""1.15"", ""1.14"", ""1.13"", ""1.12"", ""1.11""]",https://api.github.com/repos/gorilla/mux/contents/.circleci%2Fconfig.yml?ref=abccd7e4d7c117370b7908f51e48decb38b6835b,https://github.com/gorilla/mux/blob/abccd7e4d7c117370b7908f51e48decb38b6835b/.circleci%2Fconfig.yml
1fa2ee87bf61940bfac616e98513448af97a1813,c6b74c3e0d0c70aa3e311cba355eab11fd7adf8d,.editorconfig,,"Sun, 23 Jul 2023 20:15:04 GMT",added,20,0,20,"@@ -0,0 +1,20 @@
+; https://editorconfig.org/
+
+root = true
+
+[*]
+insert_final_newline = true
+charset = utf-8
+trim_trailing_whitespace = true
+indent_style = space
+indent_size = 2
+
+[{Makefile,go.mod,go.sum,*.go,.gitmodules}]
+indent_style = tab
+indent_size = 4
+
+[*.md]
+indent_size = 4
+trim_trailing_whitespace = false
+
+eclint_indent_style = unset
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/.editorconfig?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.editorconfig
1fa2ee87bf61940bfac616e98513448af97a1813,055ca8222eab29c771cda4f97c671a0ab1876066,.github/workflows/issues.yml,,"Sun, 23 Jul 2023 20:15:04 GMT",added,20,0,20,"@@ -0,0 +1,20 @@
+# Add issues or pull-requests created to the project. 
+name: Add issue or pull request to Project
+
+on:
+  issues:
+    types:
+      - opened
+  pull_request:
+    types:
+      - opened
+
+jobs:
+  add-to-project:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Add issue to project
+        uses: actions/add-to-project@v0.5.0
+        with:
+          project-url: https://github.com/orgs/gorilla/projects/4
+          github-token: ${{ secrets.ADD_TO_PROJECT_TOKEN }}
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Fissues.yml?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.github%2Fworkflows%2Fissues.yml
1fa2ee87bf61940bfac616e98513448af97a1813,af48d2289fd47fce511a9698f236c78164223cbc,.github/workflows/test.yml,,"Sun, 23 Jul 2023 20:15:04 GMT",added,55,0,55,"@@ -0,0 +1,55 @@
+name: CI
+on:
+  push:
+    branches:
+      - main
+  pull_request:
+    branches:
+      - main
+
+permissions:
+  contents: read
+
+jobs:
+  verify-and-test:
+    strategy:
+      matrix:
+        go: ['1.19','1.20']
+        os: [ubuntu-latest, macos-latest, windows-latest]
+      fail-fast: true
+    runs-on: ${{ matrix.os }}
+    steps:
+      - name: Checkout Code
+        uses: actions/checkout@v3
+
+      - name: Setup Go ${{ matrix.go }}
+        uses: actions/setup-go@v4
+        with:
+          go-version: ${{ matrix.go }}
+          cache: false
+
+      - name: Run GolangCI-Lint
+        uses: golangci/golangci-lint-action@v3
+        with:
+          version: v1.53
+          args: --timeout=5m
+
+      - name: Run GoSec
+        if: matrix.os == 'ubuntu-latest'
+        uses: securego/gosec@master
+        with:
+          args: ./...
+
+      - name: Run GoVulnCheck
+        uses: golang/govulncheck-action@v1
+        with:
+          go-version-input: ${{ matrix.go }}
+          go-package: ./...
+
+      - name: Run Tests
+        run: go test -race -cover -coverprofile=coverage -covermode=atomic -v ./...
+
+      - name: Upload coverage to Codecov
+        uses: codecov/codecov-action@v3
+        with:
+          files: ./coverage
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/.github%2Fworkflows%2Ftest.yml?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.github%2Fworkflows%2Ftest.yml
1fa2ee87bf61940bfac616e98513448af97a1813,84039fec68771bc54be8f70617692068532536d2,.gitignore,,"Sun, 23 Jul 2023 20:15:04 GMT",added,1,0,1,"@@ -0,0 +1 @@
+coverage.coverprofile",https://api.github.com/repos/gorilla/mux/contents/.gitignore?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/.gitignore
1fa2ee87bf61940bfac616e98513448af97a1813,98f5ab75f9d7ccbf249cd7271c44303ed719ebd3,Makefile,,"Sun, 23 Jul 2023 20:15:04 GMT",added,34,0,34,"@@ -0,0 +1,34 @@
+GO_LINT=$(shell which golangci-lint 2> /dev/null || echo '')
+GO_LINT_URI=github.com/golangci/golangci-lint/cmd/golangci-lint@latest
+
+GO_SEC=$(shell which gosec 2> /dev/null || echo '')
+GO_SEC_URI=github.com/securego/gosec/v2/cmd/gosec@latest
+
+GO_VULNCHECK=$(shell which govulncheck 2> /dev/null || echo '')
+GO_VULNCHECK_URI=golang.org/x/vuln/cmd/govulncheck@latest
+
+.PHONY: golangci-lint
+golangci-lint:
+	$(if $(GO_LINT), ,go install $(GO_LINT_URI))
+	@echo ""##### Running golangci-lint""
+	golangci-lint run -v
+	
+.PHONY: gosec
+gosec:
+	$(if $(GO_SEC), ,go install $(GO_SEC_URI))
+	@echo ""##### Running gosec""
+	gosec ./...
+
+.PHONY: govulncheck
+govulncheck:
+	$(if $(GO_VULNCHECK), ,go install $(GO_VULNCHECK_URI))
+	@echo ""##### Running govulncheck""
+	govulncheck ./...
+
+.PHONY: verify
+verify: golangci-lint gosec govulncheck
+
+.PHONY: test
+test:
+	@echo ""##### Running tests""
+	go test -race -cover -coverprofile=coverage.coverprofile -covermode=atomic -v ./...
\ No newline at end of file",https://api.github.com/repos/gorilla/mux/contents/Makefile?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/Makefile
1fa2ee87bf61940bfac616e98513448af97a1813,551f3c67478bb396842db0ef2287ba27b14ffbf6,README.md,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,5,3,8,"@@ -1,8 +1,10 @@
 # gorilla/mux
 
-[![GoDoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
-[![CircleCI](https://circleci.com/gh/gorilla/mux.svg?style=svg)](https://circleci.com/gh/gorilla/mux)
-[![Sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
+![testing](https://github.com/gorilla/mux/actions/workflows/test.yml/badge.svg)
+[![codecov](https://codecov.io/github/gorilla/mux/branch/main/graph/badge.svg)](https://codecov.io/github/gorilla/mux)
+[![godoc](https://godoc.org/github.com/gorilla/mux?status.svg)](https://godoc.org/github.com/gorilla/mux)
+[![sourcegraph](https://sourcegraph.com/github.com/gorilla/mux/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/mux?badge)
+
 
 ![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/README.md
1fa2ee87bf61940bfac616e98513448af97a1813,7bcfa026847c645eb0e30e874095007366725c64,go.mod,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,1,1,2,"@@ -1,3 +1,3 @@
 module github.com/gorilla/mux
 
-go 1.12
+go 1.19",https://api.github.com/repos/gorilla/mux/contents/go.mod?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/go.mod
1fa2ee87bf61940bfac616e98513448af97a1813,4963b66fc955214e5b1099078afcd21f244a191a,middleware_test.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,76,19,95,"@@ -158,7 +158,10 @@ func TestMiddlewareExecution(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	t.Run(""responds normally without middleware"", func(t *testing.T) {
@@ -178,7 +181,10 @@ func TestMiddlewareExecution(t *testing.T) {
 
 		router.Use(func(h http.Handler) http.Handler {
 			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-				w.Write(mwStr)
+				_, err := w.Write(mwStr)
+				if err != nil {
+					t.Fatalf(""Failed writing HTTP response: %v"", err)
+				}
 				h.ServeHTTP(w, r)
 			})
 		})
@@ -196,11 +202,17 @@ func TestMiddlewareNotFound(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 	router.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
+			_, err := w.Write(mwStr)
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
@@ -221,7 +233,10 @@ func TestMiddlewareNotFound(t *testing.T) {
 		req := newRequest(""GET"", ""/notfound"")
 
 		router.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-			rw.Write([]byte(""Custom 404 handler""))
+			_, err := rw.Write([]byte(""Custom 404 handler""))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 		})
 		router.ServeHTTP(rw, req)
 
@@ -237,12 +252,18 @@ func TestMiddlewareMethodMismatch(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	}).Methods(""GET"")
 
 	router.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
+			_, err := w.Write(mwStr)
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
@@ -262,7 +283,10 @@ func TestMiddlewareMethodMismatch(t *testing.T) {
 		req := newRequest(""POST"", ""/"")
 
 		router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-			rw.Write([]byte(""Method not allowed""))
+			_, err := rw.Write([]byte(""Method not allowed""))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 		})
 		router.ServeHTTP(rw, req)
 
@@ -278,17 +302,26 @@ func TestMiddlewareNotFoundSubrouter(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	subrouter := router.PathPrefix(""/sub/"").Subrouter()
 	subrouter.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	router.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
+			_, err := w.Write(mwStr)
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
@@ -308,7 +341,10 @@ func TestMiddlewareNotFoundSubrouter(t *testing.T) {
 		req := newRequest(""GET"", ""/sub/notfound"")
 
 		subrouter.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-			rw.Write([]byte(""Custom 404 handler""))
+			_, err := rw.Write([]byte(""Custom 404 handler""))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 		})
 		router.ServeHTTP(rw, req)
 
@@ -324,17 +360,26 @@ func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
 
 	router := NewRouter()
 	router.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	subrouter := router.PathPrefix(""/sub/"").Subrouter()
 	subrouter.HandleFunc(""/"", func(w http.ResponseWriter, e *http.Request) {
-		w.Write(handlerStr)
+		_, err := w.Write(handlerStr)
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	}).Methods(""GET"")
 
 	router.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write(mwStr)
+			_, err := w.Write(mwStr)
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
@@ -354,7 +399,10 @@ func TestMiddlewareMethodMismatchSubrouter(t *testing.T) {
 		req := newRequest(""POST"", ""/sub/"")
 
 		router.MethodNotAllowedHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-			rw.Write([]byte(""Method not allowed""))
+			_, err := rw.Write([]byte(""Method not allowed""))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 		})
 		router.ServeHTTP(rw, req)
 
@@ -508,7 +556,10 @@ func TestMiddlewareOnMultiSubrouter(t *testing.T) {
 	secondSubRouter := router.PathPrefix(""/"").Subrouter()
 
 	router.NotFoundHandler = http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(notFound))
+		_, err := rw.Write([]byte(notFound))
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	})
 
 	firstSubRouter.HandleFunc(""/first"", func(w http.ResponseWriter, r *http.Request) {
@@ -521,14 +572,20 @@ func TestMiddlewareOnMultiSubrouter(t *testing.T) {
 
 	firstSubRouter.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write([]byte(first))
+			_, err := w.Write([]byte(first))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})
 
 	secondSubRouter.Use(func(h http.Handler) http.Handler {
 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
-			w.Write([]byte(second))
+			_, err := w.Write([]byte(second))
+			if err != nil {
+				t.Fatalf(""Failed writing HTTP response: %v"", err)
+			}
 			h.ServeHTTP(w, r)
 		})
 	})",https://api.github.com/repos/gorilla/mux/contents/middleware_test.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/middleware_test.go
1fa2ee87bf61940bfac616e98513448af97a1813,f55a2de3136a57721bf6726c06e3a830941958e5,mux_httpserver_test.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,10,4,14,"@@ -5,7 +5,7 @@ package mux
 
 import (
 	""bytes""
-	""io/ioutil""
+	""io""
 	""net/http""
 	""net/http/httptest""
 	""testing""
@@ -14,10 +14,16 @@ import (
 func TestSchemeMatchers(t *testing.T) {
 	router := NewRouter()
 	router.HandleFunc(""/"", func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(""hello http world""))
+		_, err := rw.Write([]byte(""hello http world""))
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	}).Schemes(""http"")
 	router.HandleFunc(""/"", func(rw http.ResponseWriter, r *http.Request) {
-		rw.Write([]byte(""hello https world""))
+		_, err := rw.Write([]byte(""hello https world""))
+		if err != nil {
+			t.Fatalf(""Failed writing HTTP response: %v"", err)
+		}
 	}).Schemes(""https"")
 
 	assertResponseBody := func(t *testing.T, s *httptest.Server, expectedBody string) {
@@ -28,7 +34,7 @@ func TestSchemeMatchers(t *testing.T) {
 		if resp.StatusCode != 200 {
 			t.Fatalf(""expected a status code of 200, got %v"", resp.StatusCode)
 		}
-		body, err := ioutil.ReadAll(resp.Body)
+		body, err := io.ReadAll(resp.Body)
 		if err != nil {
 			t.Fatalf(""unexpected error reading body: %v"", err)
 		}",https://api.github.com/repos/gorilla/mux/contents/mux_httpserver_test.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/mux_httpserver_test.go
1fa2ee87bf61940bfac616e98513448af97a1813,4345254bc38739e31f9e71c43796588a363db134,mux_test.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,15,5,20,"@@ -10,7 +10,8 @@ import (
 	""context""
 	""errors""
 	""fmt""
-	""io/ioutil""
+	""io""
+	""log""
 	""net/http""
 	""net/http/httptest""
 	""net/url""
@@ -2136,7 +2137,10 @@ type methodsSubrouterTest struct {
 // methodHandler writes the method string in response.
 func methodHandler(method string) http.HandlerFunc {
 	return func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(method))
+		_, err := w.Write([]byte(method))
+		if err != nil {
+			log.Printf(""Failed writing HTTP response: %v"", err)
+		}
 	}
 }
 
@@ -2778,7 +2782,7 @@ func TestSubrouterCustomMethodNotAllowed(t *testing.T) {
 				tt.Errorf(""Expected status code 405 (got %d)"", w.Code)
 			}
 
-			b, err := ioutil.ReadAll(w.Body)
+			b, err := io.ReadAll(w.Body)
 			if err != nil {
 				tt.Errorf(""failed to read body: %v"", err)
 			}
@@ -2859,7 +2863,10 @@ func stringMapEqual(m1, m2 map[string]string) bool {
 // http.ResponseWriter.
 func stringHandler(s string) http.HandlerFunc {
 	return func(w http.ResponseWriter, r *http.Request) {
-		w.Write([]byte(s))
+		_, err := w.Write([]byte(s))
+		if err != nil {
+			log.Printf(""Failed writing HTTP response: %v"", err)
+		}
 	}
 }
 
@@ -2892,7 +2899,10 @@ func newRequest(method, url string) *http.Request {
 
 	// Simulate writing to wire
 	var buff bytes.Buffer
-	req.Write(&buff)
+	err = req.Write(&buff)
+	if err != nil {
+		log.Printf(""Failed writing HTTP request: %v"", err)
+	}
 	ioreader := bufio.NewReader(&buff)
 
 	// Parse request off of 'wire'",https://api.github.com/repos/gorilla/mux/contents/mux_test.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/mux_test.go
1fa2ee87bf61940bfac616e98513448af97a1813,5d05cfa0e9ea01a497425a0c41a721c430c80099,regexp.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,1,1,2,"@@ -195,7 +195,7 @@ func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
 
 // url builds a URL part using the given values.
 func (r *routeRegexp) url(values map[string]string) (string, error) {
-	urlValues := make([]interface{}, len(r.varsN), len(r.varsN))
+	urlValues := make([]interface{}, len(r.varsN))
 	for k, v := range r.varsN {
 		value, ok := values[v]
 		if !ok {",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/regexp.go
1fa2ee87bf61940bfac616e98513448af97a1813,d7518f3e06b56f2623a2e0849cde2c89a0667c85,regexp_test.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,2,2,4,"@@ -54,7 +54,7 @@ func Benchmark_findQueryKey(b *testing.B) {
 			b.ReportAllocs()
 			b.ResetTimer()
 			for i := 0; i < b.N; i++ {
-				for key, _ := range all {
+				for key := range all {
 					_, _ = findFirstQueryKey(query, key)
 				}
 			}
@@ -79,7 +79,7 @@ func Benchmark_findQueryKeyGoLib(b *testing.B) {
 			b.ReportAllocs()
 			b.ResetTimer()
 			for i := 0; i < b.N; i++ {
-				for key, _ := range all {
+				for key := range all {
 					v := u.Query()[key]
 					if len(v) > 0 {
 						_ = v[0]",https://api.github.com/repos/gorilla/mux/contents/regexp_test.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/regexp_test.go
1fa2ee87bf61940bfac616e98513448af97a1813,ce1c9bfe1e94b8297f73bad8ea5d2fefe3bb0a1e,route.go,,"Sun, 23 Jul 2023 20:15:04 GMT",modified,40,40,80,"@@ -64,7 +64,7 @@ func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
 				match.MatchErr = nil
 			}
 
-			matchErr = nil
+			matchErr = nil // nolint:ineffassign
 			return false
 		}
 	}
@@ -230,9 +230,9 @@ func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // Headers adds a matcher for request header values.
 // It accepts a sequence of key/value pairs to be matched. For example:
 //
-//     r := mux.NewRouter()
-//     r.Headers(""Content-Type"", ""application/json"",
-//               ""X-Requested-With"", ""XMLHttpRequest"")
+//	r := mux.NewRouter()
+//	r.Headers(""Content-Type"", ""application/json"",
+//	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both request header values match.
 // If the value is an empty string, it will match any value if the key is set.
@@ -255,9 +255,9 @@ func (m headerRegexMatcher) Match(r *http.Request, match *RouteMatch) bool {
 // HeadersRegexp accepts a sequence of key/value pairs, where the value has regex
 // support. For example:
 //
-//     r := mux.NewRouter()
-//     r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
-//               ""X-Requested-With"", ""XMLHttpRequest"")
+//	r := mux.NewRouter()
+//	r.HeadersRegexp(""Content-Type"", ""application/(text|json)"",
+//	          ""X-Requested-With"", ""XMLHttpRequest"")
 //
 // The above route will only match if both the request header matches both regular expressions.
 // If the value is an empty string, it will match any value if the key is set.
@@ -283,10 +283,10 @@ func (r *Route) HeadersRegexp(pairs ...string) *Route {
 //
 // For example:
 //
-//     r := mux.NewRouter()
-//     r.Host(""www.example.com"")
-//     r.Host(""{subdomain}.domain.com"")
-//     r.Host(""{subdomain:[a-z]+}.domain.com"")
+//	r := mux.NewRouter()
+//	r.Host(""www.example.com"")
+//	r.Host(""{subdomain}.domain.com"")
+//	r.Host(""{subdomain:[a-z]+}.domain.com"")
 //
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
@@ -342,11 +342,11 @@ func (r *Route) Methods(methods ...string) *Route {
 //
 // For example:
 //
-//     r := mux.NewRouter()
-//     r.Path(""/products/"").Handler(ProductsHandler)
-//     r.Path(""/products/{key}"").Handler(ProductsHandler)
-//     r.Path(""/articles/{category}/{id:[0-9]+}"").
-//       Handler(ArticleHandler)
+//	r := mux.NewRouter()
+//	r.Path(""/products/"").Handler(ProductsHandler)
+//	r.Path(""/products/{key}"").Handler(ProductsHandler)
+//	r.Path(""/articles/{category}/{id:[0-9]+}"").
+//	  Handler(ArticleHandler)
 //
 // Variable names must be unique in a given route. They can be retrieved
 // calling mux.Vars(request).
@@ -377,8 +377,8 @@ func (r *Route) PathPrefix(tpl string) *Route {
 // It accepts a sequence of key/value pairs. Values may define variables.
 // For example:
 //
-//     r := mux.NewRouter()
-//     r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
+//	r := mux.NewRouter()
+//	r.Queries(""foo"", ""bar"", ""id"", ""{id:[0-9]+}"")
 //
 // The above route will only match if the URL contains the defined queries
 // values, e.g.: ?foo=bar&id=42.
@@ -473,11 +473,11 @@ func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
 //
 // It will test the inner routes only if the parent route matched. For example:
 //
-//     r := mux.NewRouter()
-//     s := r.Host(""www.example.com"").Subrouter()
-//     s.HandleFunc(""/products/"", ProductsHandler)
-//     s.HandleFunc(""/products/{key}"", ProductHandler)
-//     s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
+//	r := mux.NewRouter()
+//	s := r.Host(""www.example.com"").Subrouter()
+//	s.HandleFunc(""/products/"", ProductsHandler)
+//	s.HandleFunc(""/products/{key}"", ProductHandler)
+//	s.HandleFunc(""/articles/{category}/{id:[0-9]+}""), ArticleHandler)
 //
 // Here, the routes registered in the subrouter won't be tested if the host
 // doesn't match.
@@ -497,36 +497,36 @@ func (r *Route) Subrouter() *Router {
 // It accepts a sequence of key/value pairs for the route variables. For
 // example, given this route:
 //
-//     r := mux.NewRouter()
-//     r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
-//       Name(""article"")
+//	r := mux.NewRouter()
+//	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+//	  Name(""article"")
 //
 // ...a URL for it can be built using:
 //
-//     url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
+//	url, err := r.Get(""article"").URL(""category"", ""technology"", ""id"", ""42"")
 //
 // ...which will return an url.URL with the following path:
 //
-//     ""/articles/technology/42""
+//	""/articles/technology/42""
 //
 // This also works for host variables:
 //
-//     r := mux.NewRouter()
-//     r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
-//       Host(""{subdomain}.domain.com"").
-//       Name(""article"")
+//	r := mux.NewRouter()
+//	r.HandleFunc(""/articles/{category}/{id:[0-9]+}"", ArticleHandler).
+//	  Host(""{subdomain}.domain.com"").
+//	  Name(""article"")
 //
-//     // url.String() will be ""http://news.domain.com/articles/technology/42""
-//     url, err := r.Get(""article"").URL(""subdomain"", ""news"",
-//                                      ""category"", ""technology"",
-//                                      ""id"", ""42"")
+//	// url.String() will be ""http://news.domain.com/articles/technology/42""
+//	url, err := r.Get(""article"").URL(""subdomain"", ""news"",
+//	                                 ""category"", ""technology"",
+//	                                 ""id"", ""42"")
 //
 // The scheme of the resulting url will be the first argument that was passed to Schemes:
 //
-//     // url.String() will be ""https://example.com""
-//     r := mux.NewRouter()
-//     url, err := r.Host(""example.com"")
-//                  .Schemes(""https"", ""http"").URL()
+//	// url.String() will be ""https://example.com""
+//	r := mux.NewRouter()
+//	url, err := r.Host(""example.com"")
+//	             .Schemes(""https"", ""http"").URL()
 //
 // All variables defined in the route are required, and their values must
 // conform to the corresponding patterns.",https://api.github.com/repos/gorilla/mux/contents/route.go?ref=1fa2ee87bf61940bfac616e98513448af97a1813,https://github.com/gorilla/mux/blob/1fa2ee87bf61940bfac616e98513448af97a1813/route.go
abccd7e4d7c117370b7908f51e48decb38b6835b,f836a4e798345d9ca36d97059a6c945bc5ce389e,README.md,,"Sat, 15 Jul 2023 20:07:06 GMT",modified,0,6,6,"@@ -6,12 +6,6 @@
 
 ![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 
----
-
-**The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit**
-
----
-
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=abccd7e4d7c117370b7908f51e48decb38b6835b,https://github.com/gorilla/mux/blob/abccd7e4d7c117370b7908f51e48decb38b6835b/README.md
7456b4e9ae7b67e27ffaa2e497941e77d39bc884,f836a4e798345d9ca36d97059a6c945bc5ce389e,README.md,,"Sat, 15 Jul 2023 14:48:51 GMT",modified,0,6,6,"@@ -6,12 +6,6 @@
 
 ![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 
----
-
-**The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit**
-
----
-
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=7456b4e9ae7b67e27ffaa2e497941e77d39bc884,https://github.com/gorilla/mux/blob/7456b4e9ae7b67e27ffaa2e497941e77d39bc884/README.md
eb99d7a67714bbab6db27f896a8c8c947b51b610,64a20e7dff65748c6ea4ca4833603cc1666fb4e3,README.md,,"Fri, 09 Dec 2022 15:56:57 GMT",modified,1,1,2,"@@ -8,7 +8,7 @@
 
 ---
 
-The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit
+**The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit**
 
 ---
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=eb99d7a67714bbab6db27f896a8c8c947b51b610,https://github.com/gorilla/mux/blob/eb99d7a67714bbab6db27f896a8c8c947b51b610/README.md
5e1e8c8d45ad101414d06762b0f7f6200babc929,35aa29b671da84f8107373348b4504e1d304edd9,README.md,,"Fri, 09 Dec 2022 15:56:37 GMT",modified,1,1,2,"@@ -8,7 +8,7 @@
 
 ---
 
-⚠️ **[The Gorilla Toolkit is looking for a new maintainer](https://github.com/gorilla/mux/issues/659)**
+The Gorilla project has been archived, and is no longer under active maintainenance. You can read more here: https://github.com/gorilla#gorilla-toolkit
 
 ---
 ",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=5e1e8c8d45ad101414d06762b0f7f6200babc929,https://github.com/gorilla/mux/blob/5e1e8c8d45ad101414d06762b0f7f6200babc929/README.md
07eedffb4388b4ed26b86c67aedca1e513e7553b,f09a5b35a8756b1318262e3a04f3e028d0ecb34e,README.md,,"Wed, 17 Aug 2022 20:49:02 GMT",modified,1,1,2,"@@ -576,7 +576,7 @@ func (amw *authenticationMiddleware) Middleware(next http.Handler) http.Handler
 r := mux.NewRouter()
 r.HandleFunc(""/"", handler)
 
-amw := authenticationMiddleware{}
+amw := authenticationMiddleware{tokenUsers: make(map[string]string)}
 amw.Populate()
 
 r.Use(amw.Middleware)",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=07eedffb4388b4ed26b86c67aedca1e513e7553b,https://github.com/gorilla/mux/blob/07eedffb4388b4ed26b86c67aedca1e513e7553b/README.md
c889844abd3601217c96aabc4b2dd89f6d904c01,37c11edc3a4c74a9f192c35db40594da04a14e54,regexp.go,,"Sun, 26 Jun 2022 11:46:01 GMT",modified,4,4,8,"@@ -22,10 +22,10 @@ type routeRegexpOptions struct {
 type regexpType int
 
 const (
-	regexpTypePath   regexpType = 0
-	regexpTypeHost   regexpType = 1
-	regexpTypePrefix regexpType = 2
-	regexpTypeQuery  regexpType = 3
+	regexpTypePath regexpType = iota
+	regexpTypeHost
+	regexpTypePrefix
+	regexpTypeQuery
 )
 
 // newRouteRegexp parses a route template and returns a routeRegexp,",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=c889844abd3601217c96aabc4b2dd89f6d904c01,https://github.com/gorilla/mux/blob/c889844abd3601217c96aabc4b2dd89f6d904c01/regexp.go
91708ff8e35bafc8612f690a25f5dd0be6f16864,c7e6872b1ccda49d372958b2d294fcd8d29aa738,README.md,,"Sun, 12 Dec 2021 16:29:04 GMT",modified,5,1,6,"@@ -6,7 +6,11 @@
 
 ![Gorilla Logo](https://cloud-cdn.questionable.services/gorilla-icon-64.png)
 
-https://www.gorillatoolkit.org/pkg/mux
+---
+
+⚠️ **[The Gorilla Toolkit is looking for a new maintainer](https://github.com/gorilla/mux/issues/659)**
+
+---
 
 Package `gorilla/mux` implements a request router and dispatcher for matching incoming requests to
 their respective handler.",https://api.github.com/repos/gorilla/mux/contents/README.md?ref=91708ff8e35bafc8612f690a25f5dd0be6f16864,https://github.com/gorilla/mux/blob/91708ff8e35bafc8612f690a25f5dd0be6f16864/README.md
91708ff8e35bafc8612f690a25f5dd0be6f16864,907ab91d782bdc91fdb71c30b60bf46976fde46d,mux_httpserver_test.go,,"Sun, 12 Dec 2021 16:29:04 GMT",modified,1,0,1,"@@ -1,3 +1,4 @@
+//go:build go1.9
 // +build go1.9
 
 package mux",https://api.github.com/repos/gorilla/mux/contents/mux_httpserver_test.go?ref=91708ff8e35bafc8612f690a25f5dd0be6f16864,https://github.com/gorilla/mux/blob/91708ff8e35bafc8612f690a25f5dd0be6f16864/mux_httpserver_test.go
3cf0d013e53d62a96c096366d300c84489c26dd5,f126a602ba651622867542c10bcb009cd65ac63f,mux.go,,"Tue, 14 Sep 2021 12:12:19 GMT",modified,2,0,2,"@@ -46,9 +46,11 @@ func NewRouter() *Router {
 // This will send all incoming requests to the router.
 type Router struct {
 	// Configurable Handler to be used when no route matches.
+	// This can be used to render your own 404 Not Found errors.
 	NotFoundHandler http.Handler
 
 	// Configurable Handler to be used when the request method does not match the route.
+	// This can be used to render your own 405 Method Not Allowed errors.
 	MethodNotAllowedHandler http.Handler
 
 	// Routes to be matched, in order.",https://api.github.com/repos/gorilla/mux/contents/mux.go?ref=3cf0d013e53d62a96c096366d300c84489c26dd5,https://github.com/gorilla/mux/blob/3cf0d013e53d62a96c096366d300c84489c26dd5/mux.go
d07530f46e1eec4e40346e24af34dcc6750ad39f,ead3e1d49f7f1ee53f8f75746355afef2498d643,.circleci/config.yml,,"Sat, 12 Sep 2020 19:20:56 GMT",modified,43,60,103,"@@ -1,87 +1,70 @@
-version: 2.0
+version: 2.1
 
 jobs:
-  # Base test configuration for Go library tests Each distinct version should
-  # inherit this base, and override (at least) the container image used.
-  ""test"": &test
+  ""test"":
+    parameters:
+      version:
+        type: string
+        default: ""latest""
+      golint:
+        type: boolean
+        default: true
+      modules:
+        type: boolean
+        default: true
+      goproxy:
+        type: string
+        default: """"
     docker:
-      - image: circleci/golang:latest
+      - image: ""circleci/golang:<< parameters.version >>""
     working_directory: /go/src/github.com/gorilla/mux
-    steps: &steps
-      # Our build steps: we checkout the repo, fetch our deps, lint, and finally
-      # run ""go test"" on the package.
+    environment:
+      GO111MODULE: ""on""
+      GOPROXY: ""<< parameters.goproxy >>""
+    steps:
       - checkout
-      # Logs the version in our build logs, for posterity
-      - run: go version
+      - run:
+          name: ""Print the Go version""
+          command: >
+            go version
       - run:
           name: ""Fetch dependencies""
           command: >
-            go get -t -v ./...
+            if [[ << parameters.modules >> = true ]]; then
+              go mod download
+              export GO111MODULE=on
+            else
+              go get -v ./...
+            fi
       # Only run gofmt, vet & lint against the latest Go version
       - run:
           name: ""Run golint""
           command: >
-            if [ ""${LATEST}"" = true ] && [ -z ""${SKIP_GOLINT}"" ]; then
+            if [ << parameters.version >> = ""latest"" ] && [ << parameters.golint >> = true ]; then
               go get -u golang.org/x/lint/golint
               golint ./...
             fi
       - run:
           name: ""Run gofmt""
           command: >
-            if [[ ""${LATEST}"" = true ]]; then
+            if [[ << parameters.version >> = ""latest"" ]]; then
               diff -u <(echo -n) <(gofmt -d -e .)
             fi
       - run:
           name: ""Run go vet""
-          command:  >
-            if [[ ""${LATEST}"" = true ]]; then
+          command: >
+            if [[ << parameters.version >> = ""latest"" ]]; then
               go vet -v ./...
             fi
-      - run: go test -v -race ./...
-
-  ""latest"":
-    <<: *test
-    environment:
-      LATEST: true
-
-  ""1.12"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.12
-
-  ""1.11"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.11
-
-  ""1.10"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.10
-
-  ""1.9"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.9
-
-  ""1.8"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.8
-
-  ""1.7"":
-    <<: *test
-    docker:
-      - image: circleci/golang:1.7
+      - run:
+          name: ""Run go test (+ race detector)""
+          command: >
+            go test -v -race ./...
 
 workflows:
-  version: 2
-  build:
+  tests:
     jobs:
-      - ""latest""
-      - ""1.12""
-      - ""1.11""
-      - ""1.10""
-      - ""1.9""
-      - ""1.8""
-      - ""1.7""
+      - test:
+          matrix:
+            parameters:
+              version: [""latest"", ""1.15"", ""1.14"", ""1.13"", ""1.12"", ""1.11""]",https://api.github.com/repos/gorilla/mux/contents/.circleci%2Fconfig.yml?ref=d07530f46e1eec4e40346e24af34dcc6750ad39f,https://github.com/gorilla/mux/blob/d07530f46e1eec4e40346e24af34dcc6750ad39f/.circleci%2Fconfig.yml
98cb6bf42e086f6af920b965c38cacc07402d51b,96dbe3371924fa13f0940f6d7e2c803e93a505e2,old_test.go,,"Sat, 11 Jul 2020 20:05:21 GMT",modified,22,1,23,"@@ -260,6 +260,18 @@ var hostMatcherTests = []hostMatcherTest{
 		vars:    map[string]string{""foo"": ""abc"", ""bar"": ""def"", ""baz"": ""ghi""},
 		result:  true,
 	},
+	{
+		matcher: NewRouter().NewRoute().Host(""{foo:[a-z][a-z][a-z]}.{bar:[a-z][a-z][a-z]}.{baz:[a-z][a-z][a-z]}:{port:.*}""),
+		url:     ""http://abc.def.ghi:65535/"",
+		vars:    map[string]string{""foo"": ""abc"", ""bar"": ""def"", ""baz"": ""ghi"", ""port"": ""65535""},
+		result:  true,
+	},
+	{
+		matcher: NewRouter().NewRoute().Host(""{foo:[a-z][a-z][a-z]}.{bar:[a-z][a-z][a-z]}.{baz:[a-z][a-z][a-z]}""),
+		url:     ""http://abc.def.ghi:65535/"",
+		vars:    map[string]string{""foo"": ""abc"", ""bar"": ""def"", ""baz"": ""ghi""},
+		result:  true,
+	},
 	{
 		matcher: NewRouter().NewRoute().Host(""{foo:[a-z][a-z][a-z]}.{bar:[a-z][a-z][a-z]}.{baz:[a-z][a-z][a-z]}""),
 		url:     ""http://a.b.c/"",
@@ -365,6 +377,11 @@ var urlBuildingTests = []urlBuildingTest{
 		vars:  []string{""subdomain"", ""bar""},
 		url:   ""http://bar.domain.com"",
 	},
+	{
+		route: new(Route).Host(""{subdomain}.domain.com:{port:.*}""),
+		vars:  []string{""subdomain"", ""bar"", ""port"", ""65535""},
+		url:   ""http://bar.domain.com:65535"",
+	},
 	{
 		route: new(Route).Host(""foo.domain.com"").Path(""/articles""),
 		vars:  []string{},
@@ -412,7 +429,11 @@ func TestHeaderMatcher(t *testing.T) {
 
 func TestHostMatcher(t *testing.T) {
 	for _, v := range hostMatcherTests {
-		request, _ := http.NewRequest(""GET"", v.url, nil)
+		request, err := http.NewRequest(""GET"", v.url, nil)
+		if err != nil {
+			t.Errorf(""http.NewRequest failed %#v"", err)
+			continue
+		}
 		var routeMatch RouteMatch
 		result := v.matcher.Match(request, &routeMatch)
 		vars := routeMatch.Vars",https://api.github.com/repos/gorilla/mux/contents/old_test.go?ref=98cb6bf42e086f6af920b965c38cacc07402d51b,https://github.com/gorilla/mux/blob/98cb6bf42e086f6af920b965c38cacc07402d51b/old_test.go
98cb6bf42e086f6af920b965c38cacc07402d51b,0144842bb23ee4cdf617a8f179548c25781a4afa,regexp.go,,"Sat, 11 Jul 2020 20:05:21 GMT",modified,6,0,6,"@@ -325,6 +325,12 @@ func (v routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
 	// Store host variables.
 	if v.host != nil {
 		host := getHost(req)
+		if v.host.wildcardHostPort {
+			// Don't be strict on the port match
+			if i := strings.Index(host, "":""); i != -1 {
+				host = host[:i]
+			}
+		}
 		matches := v.host.regexp.FindStringSubmatchIndex(host)
 		if len(matches) > 0 {
 			extractVars(host, matches, v.host.varsN, m.Vars)",https://api.github.com/repos/gorilla/mux/contents/regexp.go?ref=98cb6bf42e086f6af920b965c38cacc07402d51b,https://github.com/gorilla/mux/blob/98cb6bf42e086f6af920b965c38cacc07402d51b/regexp.go
